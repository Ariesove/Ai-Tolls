"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0";
exports.ids = ["vendor-chunks/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/client.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/client.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_MAX_SIZE_BYTES: () => (/* binding */ DEFAULT_MAX_SIZE_BYTES),\n/* harmony export */   DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   mergeRuntimeEnvIntoRun: () => (/* binding */ mergeRuntimeEnvIntoRun)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./experimental/otel/translator.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/translator.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/otel.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/otel.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/messages.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/prompts.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/error.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/prompts_cache.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRun(run, cachedEnvVars, omitTracedRuntimeInfo) {\n    if (omitTracedRuntimeInfo) {\n        return run;\n    }\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getRuntimeEnvironment)();\n    const envVars = cachedEnvVars ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || (\"revision_id\" in run && run.revision_id)\n                ? {\n                    revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ??\n                        envVars.revision_id,\n                }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate) => {\n    const samplingRateStr = configRate?.toString() ??\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"10\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nconst DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;\n/** Default maximum memory (1GB) for queue size limits. */\nconst DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024; // 1GB\nconst SERVER_INFO_REQUEST_TIMEOUT_MS = 10000;\n/** Maximum number of operations to batch in a single request. */\nconst DEFAULT_BATCH_SIZE_LIMIT = 100;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nclass AutoBatchQueue {\n    constructor(maxSizeBytes) {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"maxSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(item.item, `Serializing run with id: ${item.item.id}`).length;\n        // Check if adding this item would exceed the size limit\n        // Allow the run if the queue is empty (to support large single traces)\n        if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {\n            console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. ` +\n                `Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);\n            // Resolve immediately to avoid blocking caller\n            itemPromiseResolve();\n            return itemPromise;\n        }\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop({ upToSizeBytes, upToSize, }) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0 &&\n            popped.length < upToSize) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({\n                action: it.action,\n                item: it.payload,\n                otelContext: it.otelContext,\n                apiKey: it.apiKey,\n                apiUrl: it.apiUrl,\n                size: it.size,\n            })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\nclass Client {\n    get _fetch() {\n        return this.fetchImplementation || (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__._getFetchImplementation)(this.debug);\n    }\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"workspaceId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitTracedRuntimeInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSizeLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cachedLSEnvVarsForMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"_multipartDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"_runCompressionDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"DISABLE_RUN_COMPRESSION\") === \"true\"\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.workspaceId = trimQuotes(config.workspaceId ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"WORKSPACE_ID\"));\n        this.timeout_ms = config.timeout_ms ?? 90_000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            maxRetries: 4,\n            debug: config.debug ?? this.debug,\n        });\n        this.traceBatchConcurrency =\n            config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.fetchImplementation = config.fetchImplementation;\n        // Use maxIngestMemoryBytes for both queues\n        const maxMemory = config.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: this.traceBatchConcurrency,\n            maxQueueSizeBytes: maxMemory,\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.omitTracedRuntimeInfo = config.omitTracedRuntimeInfo ?? false;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.autoBatchQueue = new AutoBatchQueue(maxMemory);\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.batchSizeLimit = config.batchSizeLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getOtelEnabled)()) {\n            this.langSmithToOTELTranslator = new _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__.LangSmithToOTELTranslator();\n        }\n        // Cache metadata env vars once during construction to avoid repeatedly scanning process.env\n        this.cachedLSEnvVarsForMetadata = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n        // Initialize cache\n        if (config.cache === true) {\n            this._cache = new _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_10__.Cache();\n        }\n        else if (config.cache && typeof config.cache === \"object\") {\n            this._cache = config.cache;\n        }\n        else {\n            this._cache = undefined;\n        }\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_5__.__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        if (this.workspaceId) {\n            headers[\"x-tenant-id\"] = this.workspaceId;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n            return res;\n        });\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"GET\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const body = JSON.stringify(bodyParams);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: requestMethod,\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                }\n                else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs) {\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    }\n                    else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                }\n                else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo?.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES);\n    }\n    /**\n     * Get the maximum number of operations to batch in a single request.\n     */\n    async _getBatchSizeLimit() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeLimit ??\n            serverInfo?.batch_ingest_config?.size_limit ??\n            DEFAULT_BATCH_SIZE_LIMIT);\n    }\n    async _getDatasetExamplesMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return (serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false);\n    }\n    drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit, }) {\n        const promises = [];\n        while (this.autoBatchQueue.items.length > 0) {\n            const [batch, done] = this.autoBatchQueue.pop({\n                upToSizeBytes: batchSizeLimitBytes,\n                upToSize: batchSizeLimit,\n            });\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item) => {\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1],\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        // Calculate total batch size for queue tracking\n        const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            }\n            else {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                const useMultipart = !this._multipartDisabled &&\n                    (serverInfo?.batch_ingest_config?.use_multipart_endpoint ?? true);\n                if (useMultipart) {\n                    const useGzip = !this._runCompressionDisabled &&\n                        serverInfo?.instance_flags?.gzip_body_enabled;\n                    try {\n                        await this.multipartIngestRuns(ingestParams, {\n                            ...options,\n                            useGzip,\n                            sizeBytes: batchSizeBytes,\n                        });\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    }\n                    catch (e) {\n                        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                            // Fallback to batch ingest if multipart endpoint returns 404\n                            // Disable multipart for future requests\n                            this._multipartDisabled = true;\n                            await this.batchIngestRuns(ingestParams, {\n                                ...options,\n                                sizeBytes: batchSizeBytes,\n                            });\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams, {\n                        ...options,\n                        sizeBytes: batchSizeBytes,\n                    });\n                }\n            }\n        }\n        catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch) {\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                    else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes ||\n            this.autoBatchQueue.items.length > sizeLimit) {\n            void this.drainAutoBatchQueue({\n                batchSizeLimitBytes: sizeLimitBytes,\n                batchSizeLimit: sizeLimit,\n            });\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue({\n                    batchSizeLimitBytes: sizeLimitBytes,\n                    batchSizeLimit: sizeLimit,\n                });\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/info`, {\n                method: \"GET\",\n                headers: { Accept: \"application/json\" },\n                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get server info\");\n            return res;\n        });\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" +\n                JSON.stringify(json, null, 2) +\n                \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? \"Unspecified status code\"} ${e.message}`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */\n    async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        await this.drainAutoBatchQueue({\n            batchSizeLimitBytes: sizeLimitBytes,\n            batchSizeLimit: sizeLimit,\n        });\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)();\n        const otel_context = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELContext)();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams,\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post\n                .map((item) => item.id)\n                .concat(batchChunks.patch.map((item) => item.id))\n                .join(\",\");\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        await this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"batch create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events, extra, error, serialized };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)) {\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            }\n                            else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` +\n                                    `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.byteLength}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts) {\n            // Add field boundary\n            chunks.push(new Blob([`--${boundary}\\r\\n`]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`,\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\"\\r\\n\"]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start(controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk) => {\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    }\n                    else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts) {\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while (!(result = await reader.read()).done) {\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    finally {\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            },\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__._globalFetchImplementationIsNodeFetch)();\n        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n        const buildStream = () => this._createMultipartStream(parts, boundary);\n        const sendWithRetry = async (bodyFactory) => {\n            return this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n                const body = await bodyFactory();\n                const headers = {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n                };\n                if (options?.apiKey !== undefined) {\n                    headers[\"x-api-key\"] = options.apiKey;\n                }\n                let transformedBody = body;\n                if (options?.useGzip &&\n                    typeof body === \"object\" &&\n                    \"pipeThrough\" in body) {\n                    transformedBody = body.pipeThrough(new CompressionStream(\"gzip\"));\n                    headers[\"Content-Encoding\"] = \"gzip\";\n                }\n                const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                    method: \"POST\",\n                    headers,\n                    body: transformedBody,\n                    duplex: \"half\",\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to send multipart request`, true);\n                return response;\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch or Bun\n            if (!isNodeFetch &&\n                !this.multipartStreamingDisabled &&\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnv)() !== \"bun\") {\n                streamedAttempt = true;\n                res = await sendWithRetry(buildStream);\n            }\n            else {\n                res = await sendWithRetry(buildBuffered);\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) &&\n                res.status === 422 &&\n                (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` +\n                    `This usually means the host does not support chunked uploads. ` +\n                    `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await sendWithRetry(buildBuffered);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            // Re-throw 404 errors so caller can fall back to batch ingest\n            if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                throw e;\n            }\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization &&\n                !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n                return;\n            }\n            else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(run, `Serializing payload to update run with id: ${runId}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n                method: \"PATCH\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update run\", true);\n            return res;\n        });\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id,\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") &&\n                childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order,\n        };\n        if (body.select.includes(\"child_run_ids\")) {\n            (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.\");\n        }\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset, } = props;\n        const sessionId = projectId || (await this.readProject({ projectName })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100,\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while (true) {\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset,\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n            const body = JSON.stringify(filteredPayload);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `Failed to fetch ${path}`);\n                return res;\n            });\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups) {\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const body = JSON.stringify(filteredPayload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/stats`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run stats\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share run\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare run\", true);\n            return res;\n        });\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read run shared link\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared runs\");\n            return res;\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset shared schema\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share dataset\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare dataset\", true);\n            return res;\n        });\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read shared dataset\");\n            return res;\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared examples\");\n            return res;\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail)\n                    ? result.detail.join(\"\\n\")\n                    : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = JSON.stringify({\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"has project\");\n            return res;\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        if (datasetVersion !== undefined) {\n            params.append(\"dataset_version\", datasetVersion);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId_);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete session ${projectId_} (${projectName})`, true);\n            return res;\n        });\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        const csvBlob = new Blob([csvFile], { type: \"text/csv\" });\n        formData.append(\"file\", csvBlob, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload CSV\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create dataset\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify(update);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset\");\n            return res;\n        });\n        return (await response.json());\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */\n    async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify({\n            as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n            tag,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset tags\", true);\n            return res;\n        });\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"index dataset\");\n            return res;\n        });\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                method: \"POST\",\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"fetch similar examples\");\n            return res;\n        });\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs\n            ? options?.datasetName\n            : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments,\n            };\n        }\n        else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"]());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            }\n            else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            }\n            else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({ datasetName: datasetName_ });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName, } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx],\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(generations)\n            ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type,\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\"attachment_urls\", \"outputs\", \"metadata\"].forEach((field) => params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n            for (const rawExample of rawExamples) {\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined,\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    /**\n     * Delete multiple examples by ID.\n     * @param exampleIds - The IDs of the examples to delete\n     * @param options - Optional settings for deletion\n     * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.\n     */\n    async deleteExamples(exampleIds, options) {\n        // Validate all UUIDs\n        exampleIds.forEach((id) => (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id));\n        if (options?.hardDelete) {\n            // Hard delete uses POST to a different platform endpoint\n            const path = this._getPlatformEndpointPath(\"datasets/examples/delete\");\n            await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    body: JSON.stringify({\n                        example_ids: exampleIds,\n                        hard_delete: true,\n                    }),\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"hard delete examples\", true);\n                return res;\n            });\n        }\n        else {\n            // Soft delete uses DELETE with query params\n            const params = new URLSearchParams();\n            exampleIds.forEach((id) => params.append(\"example_ids\", id));\n            await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {\n                    method: \"DELETE\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete examples\", true);\n                return res;\n            });\n        }\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        }\n        else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = { id: exampleId, ...update };\n        }\n        else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        }\n        else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [updateToUse]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        }\n        else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */\n    async readDatasetVersion({ datasetId, datasetName, asOf, tag, }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            resolvedDatasetId = dataset.id;\n        }\n        else {\n            resolvedDatasetId = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(resolvedDatasetId);\n        if ((asOf && tag) || (!asOf && !tag)) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n                method: \"GET\",\n                headers: { ...this.headers },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset version\");\n            return res;\n        });\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id);\n                return id;\n            }),\n            remove,\n        };\n        const body = JSON.stringify(data);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset splits\", true);\n            return res;\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const body = JSON.stringify(feedback);\n        const url = `${this.apiUrl}/feedback`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create feedback\", true);\n            return res;\n        });\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const body = JSON.stringify(feedbackUpdate);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update feedback\", true);\n            return res;\n        });\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            for (const runId of runIds) {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n                queryParams.append(\"run\", runId);\n            }\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create presigned feedback token\");\n            return res;\n        });\n        return await response.json();\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create comparative experiment\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else if (Array.isArray(results)) {\n            results_ = results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n            rubric_instructions: rubricInstructions,\n        };\n        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined)));\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */\n    async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const body = JSON.stringify({\n            name,\n            description,\n            rubric_instructions: rubricInstructions,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const body = JSON.stringify(runIds.map((id, i) => (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `runIds[${i}]`).toString()));\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"add runs to annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */\n    async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueRunId, \"queueRunId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete run from annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */\n    async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/size`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get size from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get latest commit hash\");\n            return res;\n        });\n        const json = await response.json();\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const body = JSON.stringify({ like: like });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `${like ? \"like\" : \"unlike\"} prompt`);\n            return res;\n        });\n        return response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            if (res?.status === 404) {\n                return null;\n            }\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get prompt\");\n            return res;\n        });\n        const result = await response?.json();\n        if (result?.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create prompt\");\n            return res;\n        });\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create commit\");\n            return res;\n        });\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */\n    async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates) {\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n                method: \"PATCH\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update examples\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */\n    async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads) {\n            const exampleId = (example.id ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"]()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n                ...(example.source_run_id && { source_run_id: example.source_run_id }),\n                ...(example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io,\n                }),\n                ...(example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments,\n                }),\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload examples\");\n            return res;\n        });\n        return response.json();\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\",\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Generate a cache key for a prompt.\n     * Format: \"{identifier}\" or \"{identifier}:with_model\"\n     */\n    _getPromptCacheKey(promptIdentifier, includeModel) {\n        const suffix = includeModel ? \":with_model\" : \"\";\n        return `${promptIdentifier}${suffix}`;\n    }\n    /**\n     * Fetch a prompt commit directly from the API (bypassing cache).\n     */\n    async _fetchPromptFromApi(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"pull prompt commit\");\n            return res;\n        });\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        // Check cache first if not skipped\n        if (!options?.skipCache && this._cache) {\n            const cacheKey = this._getPromptCacheKey(promptIdentifier, options?.includeModel);\n            const cached = this._cache.get(cacheKey);\n            if (cached) {\n                return cached;\n            }\n            // Cache miss - fetch from API and cache it\n            const result = await this._fetchPromptFromApi(promptIdentifier, options);\n            this._cache.set(cacheKey, result);\n            return result;\n        }\n        // No cache or skip cache - fetch directly\n        return this._fetchPromptFromApi(promptIdentifier, options);\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n            skipCache: options?.skipCache,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Get the cache instance, if caching is enabled.\n     * Useful for accessing cache metrics or manually managing the cache.\n     */\n    get cache() {\n        return this._cache;\n    }\n    /**\n     * Cleanup resources held by the client.\n     * Stops the cache's background refresh timer.\n     */\n    cleanup() {\n        if (this._cache) {\n            this._cache.stop();\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        /**\n         * traceables use a backgrounded promise before updating runs to avoid blocking\n         * and to allow waiting for child runs to end. Waiting a small amount of time\n         * here ensures that they are able to enqueue their run operation before we await\n         * queued run operations below:\n         *\n         * ```ts\n         * const run = await traceable(async () => {\n         *   return \"Hello, world!\";\n         * }, { client })();\n         *\n         * await client.awaitPendingTraceBatches();\n         * ```\n         */\n        await new Promise((resolve) => setTimeout(resolve, 1));\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),\n            this.batchIngestCaller.queue.onIdle(),\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOTLPTracerComponents)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDa0Q7QUFDc0I7QUFDL0M7QUFDc0M7QUFDMEU7QUFDN0g7QUFDSztBQUNIO0FBQ2dCO0FBQ2lCO0FBQzNCO0FBQ3VEO0FBQ1Q7QUFDeEY7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQXFCO0FBQzVDLHFDQUFxQywwRUFBMkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEVBQStCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPLG1EQUFtRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQiwrRUFBMEIsd0NBQXdDLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQix5Q0FBeUMsYUFBYTtBQUNoSSx1Q0FBdUMsZ0JBQWdCLDZCQUE2QixNQUFNO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQ0FBMkMsOEVBQXVCO0FBQ2xFO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhFQUErQjtBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUVBQXNCO0FBQ3pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNLE9BQU8sV0FBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxnQkFBZ0IsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1GQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/MzI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yLCB9IGZyb20gXCIuL2V4cGVyaW1lbnRhbC9vdGVsL3RyYW5zbGF0b3IuanNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cywgZ2V0T1RFTFRyYWNlLCBnZXRPVEVMQ29udGV4dCwgfSBmcm9tIFwiLi9zaW5nbGV0b25zL290ZWwuanNcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgZ2V0T3RlbEVuYWJsZWQsIGdldEVudiwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydFV1aWQgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVByb21wdElkZW50aWZpZXIgfSBmcm9tIFwiLi91dGlscy9wcm9tcHRzLmpzXCI7XG5pbXBvcnQgeyByYWlzZUZvclN0YXR1cywgaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3IuanNcIjtcbmltcG9ydCB7IENhY2hlIH0gZnJvbSBcIi4vdXRpbHMvcHJvbXB0c19jYWNoZS5qc1wiO1xuaW1wb3J0IHsgX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCwgX2dldEZldGNoSW1wbGVtZW50YXRpb24sIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplIGFzIHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIH0gZnJvbSBcIi4vdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUnVudGltZUVudkludG9SdW4ocnVuLCBjYWNoZWRFbnZWYXJzLCBvbWl0VHJhY2VkUnVudGltZUluZm8pIHtcbiAgICBpZiAob21pdFRyYWNlZFJ1bnRpbWVJbmZvKSB7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCBlbnZWYXJzID0gY2FjaGVkRW52VmFycyA/PyBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEoKTtcbiAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhLm1ldGFkYXRhO1xuICAgIHJ1bi5leHRyYSA9IHtcbiAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgIC4uLnJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAuLi4oZW52VmFycy5yZXZpc2lvbl9pZCB8fCAoXCJyZXZpc2lvbl9pZFwiIGluIHJ1biAmJiBydW4ucmV2aXNpb25faWQpXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uX2lkOiAoXCJyZXZpc2lvbl9pZFwiIGluIHJ1biA/IHJ1bi5yZXZpc2lvbl9pZCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudlZhcnMucmV2aXNpb25faWQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gcnVuO1xufVxuY29uc3QgZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSA9IChjb25maWdSYXRlKSA9PiB7XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlU3RyID0gY29uZmlnUmF0ZT8udG9TdHJpbmcoKSA/P1xuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiVFJBQ0lOR19TQU1QTElOR19SQVRFXCIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGVTdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBwYXJzZUZsb2F0KHNhbXBsaW5nUmF0ZVN0cik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZSA8IDAgfHwgc2FtcGxpbmdSYXRlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExBTkdTTUlUSF9UUkFDSU5HX1NBTVBMSU5HX1JBVEUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEgaWYgc2V0LiBHb3Q6ICR7c2FtcGxpbmdSYXRlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxpbmdSYXRlO1xufTtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHRvQXJyYXkoaXRlcmFibGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmltUXVvdGVzKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL15cIiguKilcIiQvLCBcIiQxXCIpXG4gICAgICAgIC5yZXBsYWNlKC9eJyguKiknJC8sIFwiJDFcIik7XG59XG5jb25zdCBoYW5kbGU0MjkgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2U/LnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpID8/IFwiMTBcIiwgMTApICogMTAwMDtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeUFmdGVyKSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZGlyZWN0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzIGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gZXhpc3Rpbmcgc3RhdHVzIGNoZWNrc1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSkge1xuICAgIGlmICh0eXBlb2Ygc2NvcmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLy8gVHJ1bmNhdGUgYXQgNCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICByZXR1cm4gTnVtYmVyKHNjb3JlLnRvRml4ZWQoNCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9VTkNPTVBSRVNTRURfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyA9IDI0ICogMTAyNCAqIDEwMjQ7XG4vKiogRGVmYXVsdCBtYXhpbXVtIG1lbW9yeSAoMUdCKSBmb3IgcXVldWUgc2l6ZSBsaW1pdHMuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfU0laRV9CWVRFUyA9IDEwMjQgKiAxMDI0ICogMTAyNDsgLy8gMUdCXG5jb25zdCBTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVRfTVMgPSAxMDAwMDtcbi8qKiBNYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIHRvIGJhdGNoIGluIGEgc2luZ2xlIHJlcXVlc3QuICovXG5jb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVQgPSAxMDA7XG5jb25zdCBERUZBVUxUX0FQSV9VUkwgPSBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbmV4cG9ydCBjbGFzcyBBdXRvQmF0Y2hRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZUJ5dGVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplQnl0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhTaXplQnl0ZXMgPSBtYXhTaXplQnl0ZXMgPz8gREVGQVVMVF9NQVhfU0laRV9CWVRFUztcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbMF07XG4gICAgfVxuICAgIHB1c2goaXRlbSkge1xuICAgICAgICBsZXQgaXRlbVByb21pc2VSZXNvbHZlO1xuICAgICAgICBjb25zdCBpdGVtUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIGl0ZW1Qcm9taXNlUmVzb2x2ZSBpcyBzeW5jaHJvbm91cyB3aXRoIHByb21pc2UgY3JlYXRpb246XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL1Byb21pc2VcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaXplID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoaXRlbS5pdGVtLCBgU2VyaWFsaXppbmcgcnVuIHdpdGggaWQ6ICR7aXRlbS5pdGVtLmlkfWApLmxlbmd0aDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWRkaW5nIHRoaXMgaXRlbSB3b3VsZCBleGNlZWQgdGhlIHNpemUgbGltaXRcbiAgICAgICAgLy8gQWxsb3cgdGhlIHJ1biBpZiB0aGUgcXVldWUgaXMgZW1wdHkgKHRvIHN1cHBvcnQgbGFyZ2Ugc2luZ2xlIHRyYWNlcylcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUJ5dGVzICsgc2l6ZSA+IHRoaXMubWF4U2l6ZUJ5dGVzICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBdXRvQmF0Y2hRdWV1ZSBzaXplIGxpbWl0ICgke3RoaXMubWF4U2l6ZUJ5dGVzfSBieXRlcykgZXhjZWVkZWQuIERyb3BwaW5nIHJ1biB3aXRoIGlkOiAke2l0ZW0uaXRlbS5pZH0uIGAgK1xuICAgICAgICAgICAgICAgIGBDdXJyZW50IHF1ZXVlIHNpemU6ICR7dGhpcy5zaXplQnl0ZXN9IGJ5dGVzLCBhdHRlbXB0ZWQgYWRkaXRpb246ICR7c2l6ZX0gYnl0ZXMuYCk7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGJsb2NraW5nIGNhbGxlclxuICAgICAgICAgICAgaXRlbVByb21pc2VSZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogaXRlbS5hY3Rpb24sXG4gICAgICAgICAgICBwYXlsb2FkOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICBvdGVsQ29udGV4dDogaXRlbS5vdGVsQ29udGV4dCxcbiAgICAgICAgICAgIGFwaUtleTogaXRlbS5hcGlLZXksXG4gICAgICAgICAgICBhcGlVcmw6IGl0ZW0uYXBpVXJsLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZTogaXRlbVByb21pc2VSZXNvbHZlLFxuICAgICAgICAgICAgaXRlbVByb21pc2UsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaXplQnl0ZXMgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgIH1cbiAgICBwb3AoeyB1cFRvU2l6ZUJ5dGVzLCB1cFRvU2l6ZSwgfSkge1xuICAgICAgICBpZiAodXBUb1NpemVCeXRlcyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBieXRlcyB0byBwb3Agb2ZmIG1heSBub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgcG9wcGVkU2l6ZUJ5dGVzID0gMDtcbiAgICAgICAgLy8gUG9wIGl0ZW1zIHVudGlsIHdlIHJlYWNoIG9yIGV4Y2VlZCB0aGUgc2l6ZSBsaW1pdFxuICAgICAgICB3aGlsZSAocG9wcGVkU2l6ZUJ5dGVzICsgKHRoaXMucGVlaygpPy5zaXplID8/IDApIDwgdXBUb1NpemVCeXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBwb3BwZWQubGVuZ3RoIDwgdXBUb1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHBvcHBlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQnl0ZXMgLT0gaXRlbS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gb24gdGhlIHF1ZXVlIHdlIHdlcmUgdW5hYmxlIHRvIHBvcCxcbiAgICAgICAgLy8ganVzdCByZXR1cm4gaXQgYXMgYSBzaW5nbGUgYmF0Y2guXG4gICAgICAgIGlmIChwb3BwZWQubGVuZ3RoID09PSAwICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvcHBlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcG9wcGVkU2l6ZUJ5dGVzICs9IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9wcGVkLm1hcCgoaXQpID0+ICh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBpdC5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaXRlbTogaXQucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBvdGVsQ29udGV4dDogaXQub3RlbENvbnRleHQsXG4gICAgICAgICAgICAgICAgYXBpS2V5OiBpdC5hcGlLZXksXG4gICAgICAgICAgICAgICAgYXBpVXJsOiBpdC5hcGlVcmwsXG4gICAgICAgICAgICAgICAgc2l6ZTogaXQuc2l6ZSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICgpID0+IHBvcHBlZC5mb3JFYWNoKChpdCkgPT4gaXQuaXRlbVByb21pc2VSZXNvbHZlKCkpLFxuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGdldCBfZmV0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24gfHwgX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1Zyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndvcmtzcGFjZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEluZ2VzdENhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbWl0VHJhY2VkUnVudGltZUluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2luZ1NhbXBsZVJhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsdGVyZWRQb3N0VXVpZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVHJhY2luZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDI1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplQnl0ZXNMaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFNpemVMaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZXRjaE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfVFJBQ0lOR19CQUNLR1JPVU5EXCIpID09PSBcImZhbHNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlQmF0Y2hDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NlcnZlckluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2dldFNlcnZlckluZm9Qcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hbnVhbEZsdXNoTW9kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hJbXBsZW1lbnRhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZWRMU0VudlZhcnNGb3JNZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbXVsdGlwYXJ0RGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcnVuQ29tcHJlc3Npb25EaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkRJU0FCTEVfUlVOX0NPTVBSRVNTSU9OXCIpID09PSBcInRydWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVidWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfREVCVUdcIikgPT09IFwidHJ1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoY29uZmlnLnRyYWNpbmdTYW1wbGluZ1JhdGUpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy5hcGlVcmwgPSB0aGlzLmFwaVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIGlmICh0aGlzLndlYlVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMud2ViVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtzcGFjZUlkID0gdHJpbVF1b3Rlcyhjb25maWcud29ya3NwYWNlSWQgPz8gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIldPUktTUEFDRV9JRFwiKSk7XG4gICAgICAgIHRoaXMudGltZW91dF9tcyA9IGNvbmZpZy50aW1lb3V0X21zID8/IDkwXzAwMDtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDQsXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA9XG4gICAgICAgICAgICBjb25maWcudHJhY2VCYXRjaENvbmN1cnJlbmN5ID8/IHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5O1xuICAgICAgICBpZiAodGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFjZSBiYXRjaCBjb25jdXJyZW5jeSBtdXN0IGJlIHBvc2l0aXZlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnID0gY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWc7XG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGNvbmZpZy5mZXRjaEltcGxlbWVudGF0aW9uO1xuICAgICAgICAvLyBVc2UgbWF4SW5nZXN0TWVtb3J5Qnl0ZXMgZm9yIGJvdGggcXVldWVzXG4gICAgICAgIGNvbnN0IG1heE1lbW9yeSA9IGNvbmZpZy5tYXhJbmdlc3RNZW1vcnlCeXRlcyA/PyBERUZBVUxUX01BWF9TSVpFX0JZVEVTO1xuICAgICAgICB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKHtcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDQsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogdGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3ksXG4gICAgICAgICAgICBtYXhRdWV1ZVNpemVCeXRlczogbWF4TWVtb3J5LFxuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVJbnB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLm9taXRUcmFjZWRSdW50aW1lSW5mbyA9IGNvbmZpZy5vbWl0VHJhY2VkUnVudGltZUluZm8gPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGNvbmZpZy5hdXRvQmF0Y2hUcmFjaW5nID8/IHRoaXMuYXV0b0JhdGNoVHJhY2luZztcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hRdWV1ZSA9IG5ldyBBdXRvQmF0Y2hRdWV1ZShtYXhNZW1vcnkpO1xuICAgICAgICB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID1cbiAgICAgICAgICAgIGNvbmZpZy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiA/PyB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUJ5dGVzTGltaXQgPSBjb25maWcuYmF0Y2hTaXplQnl0ZXNMaW1pdDtcbiAgICAgICAgdGhpcy5iYXRjaFNpemVMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVMaW1pdDtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBjb25maWcuZmV0Y2hPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm1hbnVhbEZsdXNoTW9kZSA9IGNvbmZpZy5tYW51YWxGbHVzaE1vZGUgPz8gdGhpcy5tYW51YWxGbHVzaE1vZGU7XG4gICAgICAgIGlmIChnZXRPdGVsRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IgPSBuZXcgTGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIG1ldGFkYXRhIGVudiB2YXJzIG9uY2UgZHVyaW5nIGNvbnN0cnVjdGlvbiB0byBhdm9pZCByZXBlYXRlZGx5IHNjYW5uaW5nIHByb2Nlc3MuZW52XG4gICAgICAgIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEgPSBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYWNoZVxuICAgICAgICBpZiAoY29uZmlnLmNhY2hlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5jYWNoZSAmJiB0eXBlb2YgY29uZmlnLmNhY2hlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IGNvbmZpZy5jYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiQVBJX0tFWVwiKTtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpID8/IERFRkFVTFRfQVBJX1VSTDtcbiAgICAgICAgY29uc3QgaGlkZUlucHV0cyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfT1VUUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5LFxuICAgICAgICAgICAgd2ViVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWRlSW5wdXRzOiBoaWRlSW5wdXRzLFxuICAgICAgICAgICAgaGlkZU91dHB1dHM6IGhpZGVPdXRwdXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5lbmRzV2l0aChcIi9hcGkvdjFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGkvdjFcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuaW5jbHVkZXMoXCIvYXBpXCIpICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmVuZHNXaXRoKFwiYXBpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMuYXBpVXJsLnJlcGxhY2UoXCIvYXBpXCIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImRldlwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZGV2LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJldVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZXUuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImJldGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2JldGEuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6IGBsYW5nc21pdGgtanMvJHtfX3ZlcnNpb25fX31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBgJHt0aGlzLmFwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndvcmtzcGFjZUlkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC10ZW5hbnQtaWRcIl0gPSB0aGlzLndvcmtzcGFjZUlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBfZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgocGF0aCkge1xuICAgICAgICAvLyBDaGVjayBpZiBhcGlVcmwgYWxyZWFkeSBlbmRzIHdpdGggL3YxIG9yIC92MS8gdG8gYXZvaWQgZG91YmxlIC92MS92MS8gcGF0aHNcbiAgICAgICAgY29uc3QgbmVlZHNWMVByZWZpeCA9IHRoaXMuYXBpVXJsLnNsaWNlKC0zKSAhPT0gXCIvdjFcIiAmJiB0aGlzLmFwaVVybC5zbGljZSgtNCkgIT09IFwiL3YxL1wiO1xuICAgICAgICByZXR1cm4gbmVlZHNWMVByZWZpeCA/IGAvdjEvcGxhdGZvcm0vJHtwYXRofWAgOiBgL3BsYXRmb3JtLyR7cGF0aH1gO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVJbnB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUlucHV0cyhpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlT3V0cHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHJ1bikge1xuICAgICAgICBjb25zdCBydW5QYXJhbXMgPSB7IC4uLnJ1biB9O1xuICAgICAgICBpZiAocnVuUGFyYW1zLmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMuaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1blBhcmFtcy5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5QYXJhbXMub3V0cHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMub3V0cHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc091dHB1dHMocnVuUGFyYW1zLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5QYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJhbXNTdHJpbmcgPSBxdWVyeVBhcmFtcz8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zU3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqX2dldFBhZ2luYXRlZChwYXRoLCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHlQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keVtkYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VCb2R5W2RhdGFLZXldO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29ycyA9IHJlc3BvbnNlQm9keS5jdXJzb3JzO1xuICAgICAgICAgICAgaWYgKCFjdXJzb3JzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMubmV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keVBhcmFtcy5jdXJzb3IgPSBjdXJzb3JzLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWxsb3dzIG1vY2tpbmcgZm9yIHRlc3RzXG4gICAgX3Nob3VsZFNhbXBsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlO1xuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHJ1bi50cmFjZV9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bi5pZCA9PT0gcnVuLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi50cmFjZV9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgbmV3IHJ1bnMsIHNhbXBsZSBhdCB0cmFjZSBsZXZlbCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSBydW4udHJhY2VfaWQgPz8gcnVuLmlkO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgbWFkZSBhIGRlY2lzaW9uIGFib3V0IHRoaXMgdHJhY2UsIGZvbGxvdyBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmhhcyh0cmFjZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5ldyB0cmFjZXMsIGFwcGx5IHNhbXBsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdHJhY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkU2FtcGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5hZGQodHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoaWxkIHJ1bnMgZm9sbG93IHRoZWlyIHRyYWNlJ3Mgc2FtcGxpbmcgZGVjaXNpb25cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXRjaFNpemVCeXRlc0xpbWl0ID8/XG4gICAgICAgICAgICBzZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX1VOQ09NUFJFU1NFRF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIHRvIGJhdGNoIGluIGEgc2luZ2xlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgX2dldEJhdGNoU2l6ZUxpbWl0KCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hTaXplTGltaXQgPz9cbiAgICAgICAgICAgIHNlcnZlckluZm8/LmJhdGNoX2luZ2VzdF9jb25maWc/LnNpemVfbGltaXQgPz9cbiAgICAgICAgICAgIERFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXREYXRhc2V0RXhhbXBsZXNNdWx0aVBhcnRTdXBwb3J0KCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHNlcnZlckluZm8uaW5zdGFuY2VfZmxhZ3M/LmRhdGFzZXRfZXhhbXBsZXNfbXVsdGlwYXJ0X2VuYWJsZWQgPz8gZmFsc2UpO1xuICAgIH1cbiAgICBkcmFpbkF1dG9CYXRjaFF1ZXVlKHsgYmF0Y2hTaXplTGltaXRCeXRlcywgYmF0Y2hTaXplTGltaXQsIH0pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgW2JhdGNoLCBkb25lXSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucG9wKHtcbiAgICAgICAgICAgICAgICB1cFRvU2l6ZUJ5dGVzOiBiYXRjaFNpemVMaW1pdEJ5dGVzLFxuICAgICAgICAgICAgICAgIHVwVG9TaXplOiBiYXRjaFNpemVMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFiYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzQnlEZXN0aW5hdGlvbiA9IGJhdGNoLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpVXJsID0gaXRlbS5hcGlVcmwgPz8gdGhpcy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gaXRlbS5hcGlLZXkgPz8gdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0ID0gaXRlbS5hcGlLZXkgPT09IHRoaXMuYXBpS2V5ICYmIGl0ZW0uYXBpVXJsID09PSB0aGlzLmFwaVVybDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaEtleSA9IGlzRGVmYXVsdCA/IFwiZGVmYXVsdFwiIDogYCR7YXBpVXJsfXwke2FwaUtleX1gO1xuICAgICAgICAgICAgICAgIGlmICghYWNjW2JhdGNoS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbYmF0Y2hLZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY1tiYXRjaEtleV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hLZXksIGJhdGNoXSBvZiBPYmplY3QuZW50cmllcyhiYXRjaGVzQnlEZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFByb21pc2UgPSB0aGlzLl9wcm9jZXNzQmF0Y2goYmF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBiYXRjaEtleSA9PT0gXCJkZWZhdWx0XCIgPyB1bmRlZmluZWQgOiBiYXRjaEtleS5zcGxpdChcInxcIilbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogYmF0Y2hLZXkgPT09IFwiZGVmYXVsdFwiID8gdW5kZWZpbmVkIDogYmF0Y2hLZXkuc3BsaXQoXCJ8XCIpWzFdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoUHJvbWlzZXMucHVzaChiYXRjaFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgYWxsIGJhdGNoZXMgdG8gY29tcGxldGUsIHRoZW4gY2FsbCB0aGUgb3ZlcmFsbCBkb25lIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBhbGxCYXRjaGVzUHJvbWlzZSA9IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpLmZpbmFsbHkoZG9uZSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGFsbEJhdGNoZXNQcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc0JhdGNoKGJhdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghYmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGJhdGNoIHNpemUgZm9yIHF1ZXVlIHRyYWNraW5nXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZUJ5dGVzID0gYmF0Y2gucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnNpemUgPz8gMCksIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZEJhdGNoVG9PVEVMVHJhbnNsYXRvcihiYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmdlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkNyZWF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZGF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZU11bHRpcGFydCA9ICF0aGlzLl9tdWx0aXBhcnREaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VydmVySW5mbz8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8udXNlX211bHRpcGFydF9lbmRwb2ludCA/PyB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlTXVsdGlwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZUd6aXAgPSAhdGhpcy5fcnVuQ29tcHJlc3Npb25EaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySW5mbz8uaW5zdGFuY2VfZmxhZ3M/Lmd6aXBfYm9keV9lbmFibGVkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdWx0aXBhcnRJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlR3ppcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQnl0ZXM6IGJhdGNoU2l6ZUJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYmF0Y2ggaW5nZXN0IGlmIG11bHRpcGFydCBlbmRwb2ludCByZXR1cm5zIDQwNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgbXVsdGlwYXJ0IGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBhcnREaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdFJ1bnMoaW5nZXN0UGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVCeXRlczogYmF0Y2hTaXplQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplQnl0ZXM6IGJhdGNoU2l6ZUJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHBvcnRpbmcgYmF0Y2g6XCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZW5kQmF0Y2hUb09URUxUcmFuc2xhdG9yKGJhdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb3RlbENvbnRleHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtLmlkICYmIGl0ZW0ub3RlbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RlbENvbnRleHRNYXAuc2V0KGl0ZW0uaXRlbS5pZCwgaXRlbS5vdGVsQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9zdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLml0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IGl0ZW0uaXRlbS50cmFjZV9pZCA/PyBpdGVtLml0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogaXRlbS5pdGVtLnRyYWNlX2lkID8/IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW46IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yLmV4cG9ydEJhdGNoKG9wZXJhdGlvbnMsIG90ZWxDb250ZXh0TWFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0JhdGNoVGltZW91dCk7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5pdGVtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bihpdGVtLml0ZW0sIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEsIHRoaXMub21pdFRyYWNlZFJ1bnRpbWVJbmZvKTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgLy8gUmVseSBvbiBtYW51YWwgZmx1c2hpbmcgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplTGltaXRCeXRlcyA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKTtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0ID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZUJ5dGVzID4gc2l6ZUxpbWl0Qnl0ZXMgfHxcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gc2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplTGltaXRCeXRlczogc2l6ZUxpbWl0Qnl0ZXMsXG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplTGltaXQ6IHNpemVMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0Qnl0ZXM6IHNpemVMaW1pdEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemVMaW1pdDogc2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vaW5mb2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KFNFUlZFUl9JTkZPX1JFUVVFU1RfVElNRU9VVF9NUyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgc2VydmVyIGluZm9cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFxuPT09IExhbmdTbWl0aCBTZXJ2ZXIgQ29uZmlndXJhdGlvbiA9PT1cXG5cIiArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBhc3luYyBfZW5zdXJlU2VydmVySW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtMQU5HU01JVEhdOiBGYWlsZWQgdG8gZmV0Y2ggaW5mbyBvbiBzdXBwb3J0ZWQgb3BlcmF0aW9ucy4gRmFsbGluZyBiYWNrIHRvIGJhdGNoIG9wZXJhdGlvbnMgYW5kIGRlZmF1bHQgbGltaXRzLiBJbmZvOiAke2Uuc3RhdHVzID8/IFwiVW5zcGVjaWZpZWQgc3RhdHVzIGNvZGVcIn0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckluZm8gPz8ge307XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZS50aGVuKChzZXJ2ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VydmVySW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5fZ2V0KFwiL3NldHRpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGN1cnJlbnQgcXVldWVkIHRyYWNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0Qnl0ZXMgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCk7XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdCA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICBiYXRjaFNpemVMaW1pdEJ5dGVzOiBzaXplTGltaXRCeXRlcyxcbiAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0OiBzaXplTGltaXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2xvbmVDdXJyZW50T1RFTENvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IG90ZWxfdHJhY2UgPSBnZXRPVEVMVHJhY2UoKTtcbiAgICAgICAgY29uc3Qgb3RlbF9jb250ZXh0ID0gZ2V0T1RFTENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IG90ZWxfdHJhY2UuZ2V0QWN0aXZlU3BhbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTcGFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90ZWxfdHJhY2Uuc2V0U3BhbihvdGVsX2NvbnRleHQuYWN0aXZlKCksIGN1cnJlbnRTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW3J1bl0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lID8/IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBydW5DcmVhdGUudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgICAgICBvdGVsQ29udGV4dCxcbiAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICBhcGlVcmw6IG9wdGlvbnM/LmFwaVVybCxcbiAgICAgICAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bihydW5DcmVhdGUsIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEsIHRoaXMub21pdFRyYWNlZFJ1bnRpbWVJbmZvKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LndvcmtzcGFjZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LXRlbmFudC1pZFwiXSA9IG9wdGlvbnMud29ya3NwYWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKG1lcmdlZFJ1bkNyZWF0ZVBhcmFtLCBgQ3JlYXRpbmcgcnVuIHdpdGggaWQ6ICR7bWVyZ2VkUnVuQ3JlYXRlUGFyYW0uaWR9YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIHJ1blwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdKTtcbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuVXBkYXRlcz8ubWFwKCh1cGRhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpID8/IFtdKTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0JhdGNoID0ge1xuICAgICAgICAgICAgcG9zdDogcHJlcGFyZWRDcmVhdGVQYXJhbXMsXG4gICAgICAgICAgICBwYXRjaDogcHJlcGFyZWRVcGRhdGVQYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBbXCJwb3N0XCIsIFwicGF0Y2hcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgICAgICBjb25zdCBiYXRjaEl0ZW1zID0gcmF3QmF0Y2hba2V5XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChiYXRjaEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaXMgd3JvbmcgYnV0IHRoaXMgaXMgYSBkZXByZWNhdGVkIGNvZGUgcGF0aCBhbnl3YXlcbiAgICAgICAgICAgICAgICBiYXRjaENodW5rc1trZXldLnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgICAgICBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaENodW5rcy5wb3N0Lmxlbmd0aCA+IDAgfHwgYmF0Y2hDaHVua3MucGF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcnVuSWRzID0gYmF0Y2hDaHVua3MucG9zdFxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChiYXRjaENodW5rcy5wYXRjaC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoYmF0Y2hDaHVua3MsIGBJbmdlc3RpbmcgcnVucyB3aXRoIGlkczogJHtydW5JZHN9YCksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wb3N0QmF0Y2hJbmdlc3RSdW5zKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsV2l0aE9wdGlvbnMoeyBzaXplQnl0ZXM6IG9wdGlvbnM/LnNpemVCeXRlcyB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHtvcHRpb25zPy5hcGlVcmwgPz8gdGhpcy5hcGlVcmx9L3J1bnMvYmF0Y2hgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJiYXRjaCBjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIG11bHRpcGFydEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJhbnNmb3JtIGFuZCBjb252ZXJ0IHRvIGRpY3RzXG4gICAgICAgIGNvbnN0IGFsbEF0dGFjaG1lbnRzID0ge307XG4gICAgICAgIGxldCBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNyZWF0ZSBvZiBydW5DcmVhdGVzID8/IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZENyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGUuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhbGxBdHRhY2htZW50c1twcmVwYXJlZENyZWF0ZS5pZF0gPSBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cztcbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zLnB1c2gocHJlcGFyZWRDcmVhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBydW5VcGRhdGVzID8/IFtdKSB7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5wdXNoKGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcXVpcmUgdHJhY2VfaWQgYW5kIGRvdHRlZF9vcmRlclxuICAgICAgICBjb25zdCBpbnZhbGlkUnVuQ3JlYXRlID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMuZmluZCgocnVuQ3JlYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJ1bkNyZWF0ZS50cmFjZV9pZCA9PT0gdW5kZWZpbmVkIHx8IHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpZFJ1bkNyZWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGFydCBpbmdlc3QgcmVxdWlyZXMgXCJ0cmFjZV9pZFwiIGFuZCBcImRvdHRlZF9vcmRlclwiIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgcnVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW52YWxpZFJ1blVwZGF0ZSA9IHByZXBhcmVkVXBkYXRlUGFyYW1zLmZpbmQoKHJ1blVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChydW5VcGRhdGUudHJhY2VfaWQgPT09IHVuZGVmaW5lZCB8fCBydW5VcGRhdGUuZG90dGVkX29yZGVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRSdW5VcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBhcnQgaW5nZXN0IHJlcXVpcmVzIFwidHJhY2VfaWRcIiBhbmQgXCJkb3R0ZWRfb3JkZXJcIiB0byBiZSBzZXQgd2hlbiB1cGRhdGluZyBhIHJ1bmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbWJpbmUgcG9zdCBhbmQgcGF0Y2ggZGljdHMgd2hlcmUgcG9zc2libGVcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgdGhlIHJ1bnMgaW4gbXVsdGlwYXJ0IHJlcXVlc3RzXG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkQ29udGV4dCA9IFtdO1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW21ldGhvZCwgcGF5bG9hZHNdIG9mIFtcbiAgICAgICAgICAgIFtcInBvc3RcIiwgcHJlcGFyZWRDcmVhdGVQYXJhbXNdLFxuICAgICAgICAgICAgW1wicGF0Y2hcIiwgcHJlcGFyZWRVcGRhdGVQYXJhbXNdLFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9yaWdpbmFsUGF5bG9hZCBvZiBwYXlsb2Fkcykge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgZmllbGRzIHRvIGJlIHNlbnQgYXMgc2VwYXJhdGUgcGFydHNcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgZXZlbnRzLCBleHRyYSwgZXJyb3IsIHNlcmlhbGl6ZWQsIGF0dGFjaG1lbnRzLCAuLi5wYXlsb2FkIH0gPSBvcmlnaW5hbFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0geyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cywgZXh0cmEsIGVycm9yLCBzZXJpYWxpemVkIH07XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBtYWluIHJ1biBwYXlsb2FkXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQYXlsb2FkID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcocGF5bG9hZCwgYFNlcmlhbGl6aW5nIGZvciBtdWx0aXBhcnQgaW5nZXN0aW9uIG9mIHJ1biB3aXRoIGlkOiAke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7bWV0aG9kfS4ke3BheWxvYWQuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkUGF5bG9hZF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFBheWxvYWQubGVuZ3RofWAsIC8vIGVuY29kaW5nPWd6aXBcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBmaWVsZHMgd2UgY29sbGVjdGVkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHZhbHVlLCBgU2VyaWFsaXppbmcgJHtrZXl9IGZvciBtdWx0aXBhcnQgaW5nZXN0aW9uIG9mIHJ1biB3aXRoIGlkOiAke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFZhbHVlXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFZhbHVlLmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50cyA9IGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhbGxBdHRhY2htZW50c1twYXlsb2FkLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGF0dGFjaG1lbnRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29udGVudFR5cGUsIGNvbnRlbnRdID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gYXR0YWNobWVudC5taW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYXR0YWNobWVudCBuYW1lIGRvZXNuJ3QgY29udGFpbiBhICcuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGF0dGFjaG1lbnQgJyR7bmFtZX0nIGZvciBydW4gJHtwYXlsb2FkLmlkfTogSW52YWxpZCBhdHRhY2htZW50IG5hbWUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEF0dGFjaG1lbnQgbmFtZXMgbXVzdCBub3QgY29udGFpbiBwZXJpb2RzICgnLicpLiBQbGVhc2UgcmVuYW1lIHRoZSBhdHRhY2htZW50IGFuZCB0cnkgYWdhaW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYXR0YWNobWVudC4ke3BheWxvYWQuaWR9LiR7bmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke2NvbnRlbnRUeXBlfTsgbGVuZ3RoPSR7Y29udGVudC5ieXRlTGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgY29udGV4dFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkQ29udGV4dC5wdXNoKGB0cmFjZT0ke3BheWxvYWQudHJhY2VfaWR9LGlkPSR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zZW5kTXVsdGlwYXJ0UmVxdWVzdChhY2N1bXVsYXRlZFBhcnRzLCBhY2N1bXVsYXRlZENvbnRleHQuam9pbihcIjsgXCIpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZU5vZGVGZXRjaEJvZHkocGFydHMsIGJvdW5kYXJ5KSB7XG4gICAgICAgIC8vIENyZWF0ZSBtdWx0aXBhcnQgZm9ybSBkYXRhIG1hbnVhbGx5IHVzaW5nIEJsb2JzXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIC8vIEFkZCBmaWVsZCBib3VuZGFyeVxuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2AtLSR7Ym91bmRhcnl9XFxyXFxuYF0pKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtcbiAgICAgICAgICAgICAgICBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtwYXJ0Lm5hbWV9XCJcXHJcXG5gLFxuICAgICAgICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7cGFydC5wYXlsb2FkLnR5cGV9XFxyXFxuXFxyXFxuYCxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHBhcnQucGF5bG9hZCk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbXCJcXHJcXG5cIl0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgZmluYWwgYm91bmRhcnlcbiAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2AtLSR7Ym91bmRhcnl9LS1cXHJcXG5gXSkpO1xuICAgICAgICAvLyBDb21iaW5lIGFsbCBjaHVua3MgaW50byBhIHNpbmdsZSBCbG9iXG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgQmxvYihjaHVua3MpO1xuICAgICAgICAvLyBDb252ZXJ0IEJsb2IgdG8gQXJyYXlCdWZmZXIgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBib2R5LmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZU11bHRpcGFydFN0cmVhbShwYXJ0cywgYm91bmRhcnkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAvLyBDcmVhdGUgYSBSZWFkYWJsZVN0cmVhbSBmb3Igc3RyZWFtaW5nIHRoZSBtdWx0aXBhcnQgZGF0YVxuICAgICAgICAvLyBPbmx5IGRvIHNwZWNpYWwgaGFuZGxpbmcgaWYgd2UncmUgdXNpbmcgbm9kZS1mZXRjaFxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byB3cml0ZSBhIGNodW5rIHRvIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZUNodW5rID0gYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShjaHVuaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgZWFjaCBwYXJ0IHRvIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgYm91bmRhcnkgYW5kIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhgLS0ke2JvdW5kYXJ5fVxcclxcbmApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke3BhcnQubmFtZX1cIlxcclxcbmApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGBDb250ZW50LVR5cGU6ICR7cGFydC5wYXlsb2FkLnR5cGV9XFxyXFxuXFxyXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRTdHJlYW0gPSBwYXJ0LnBheWxvYWQuc3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHBheWxvYWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEocmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgZmluYWwgYm91bmRhcnlcbiAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGAtLSR7Ym91bmRhcnl9LS1cXHJcXG5gKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KHBhcnRzLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBtdWx0aXBhcnQgZm9ybSBkYXRhIGJvdW5kYXJ5XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gXCItLS0tTGFuZ1NtaXRoRm9ybUJvdW5kYXJ5XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgICAgICAgY29uc3QgaXNOb2RlRmV0Y2ggPSBfZ2xvYmFsRmV0Y2hJbXBsZW1lbnRhdGlvbklzTm9kZUZldGNoKCk7XG4gICAgICAgIGNvbnN0IGJ1aWxkQnVmZmVyZWQgPSAoKSA9PiB0aGlzLl9jcmVhdGVOb2RlRmV0Y2hCb2R5KHBhcnRzLCBib3VuZGFyeSk7XG4gICAgICAgIGNvbnN0IGJ1aWxkU3RyZWFtID0gKCkgPT4gdGhpcy5fY3JlYXRlTXVsdGlwYXJ0U3RyZWFtKHBhcnRzLCBib3VuZGFyeSk7XG4gICAgICAgIGNvbnN0IHNlbmRXaXRoUmV0cnkgPSBhc3luYyAoYm9keUZhY3RvcnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGxXaXRoT3B0aW9ucyh7IHNpemVCeXRlczogb3B0aW9ucz8uc2l6ZUJ5dGVzIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgYm9keUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8udXNlR3ppcCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBcInBpcGVUaHJvdWdoXCIgaW4gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEJvZHkgPSBib2R5LnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbShcImd6aXBcIikpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHRyYW5zZm9ybWVkQm9keSxcbiAgICAgICAgICAgICAgICAgICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgRmFpbGVkIHRvIHNlbmQgbXVsdGlwYXJ0IHJlcXVlc3RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBsZXQgc3RyZWFtZWRBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBhdHRlbXB0IHN0cmVhbSBvbmx5IGlmIG5vdCBkaXNhYmxlZCBhbmQgbm90IHVzaW5nIG5vZGUtZmV0Y2ggb3IgQnVuXG4gICAgICAgICAgICBpZiAoIWlzTm9kZUZldGNoICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICBnZXRFbnYoKSAhPT0gXCJidW5cIikge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkQXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgc2VuZFdpdGhSZXRyeShidWlsZFN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBzZW5kV2l0aFJldHJ5KGJ1aWxkQnVmZmVyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc3RyZWFtIGZhaWxzLCBmYWxsYmFjayB0byBidWZmZXJlZCBib2R5XG4gICAgICAgICAgICBpZiAoKCF0aGlzLm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkIHx8IHN0cmVhbWVkQXR0ZW1wdCkgJiZcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzID09PSA0MjIgJiZcbiAgICAgICAgICAgICAgICAob3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsKSAhPT0gREVGQVVMVF9BUElfVVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTdHJlYW1pbmcgbXVsdGlwYXJ0IHVwbG9hZCB0byAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnQgZmFpbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFRoaXMgdXN1YWxseSBtZWFucyB0aGUgaG9zdCBkb2VzIG5vdCBzdXBwb3J0IGNodW5rZWQgdXBsb2Fkcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyB3aXRoIGEgYnVmZmVyZWQgdXBsb2FkIGZvciBvcGVyYXRpb24gXCIke2NvbnRleHR9XCIuYCk7XG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBzdHJlYW1pbmcgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdpdGggZnVsbHktYnVmZmVyZWQgYm9keVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IHNlbmRXaXRoUmV0cnkoYnVpbGRCdWZmZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBSZS10aHJvdyA0MDQgZXJyb3JzIHNvIGNhbGxlciBjYW4gZmFsbCBiYWNrIHRvIGJhdGNoIGluZ2VzdFxuICAgICAgICAgICAgaWYgKGlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvcihlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7ZS5tZXNzYWdlLnRyaW0oKX1cXG5cXG5Db250ZXh0OiAke2NvbnRleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJhdGNoZXMgYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgd2FpdCB0byBlbnN1cmUgdHJhY2UgZmluaXNoZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ud29ya3NwYWNlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtdGVuYW50LWlkXCJdID0gb3B0aW9ucy53b3Jrc3BhY2VJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcocnVuLCBgU2VyaWFsaXppbmcgcGF5bG9hZCB0byB1cGRhdGUgcnVuIHdpdGggaWQ6ICR7cnVuSWR9YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1bihydW5JZCwgeyBsb2FkQ2hpbGRSdW5zIH0gPSB7IGxvYWRDaGlsZFJ1bnM6IGZhbHNlIH0pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGxldCBydW4gPSBhd2FpdCB0aGlzLl9nZXQoYC9ydW5zLyR7cnVuSWR9YCk7XG4gICAgICAgIGlmIChsb2FkQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBydW4gPSBhd2FpdCB0aGlzLl9sb2FkQ2hpbGRSdW5zKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuVXJsKHsgcnVuSWQsIHJ1biwgcHJvamVjdE9wdHMsIH0pIHtcbiAgICAgICAgaWYgKHJ1biAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbklkO1xuICAgICAgICAgICAgaWYgKHJ1bi5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcnVuLnNlc3Npb25faWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3RPcHRzPy5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiUFJPSkVDVFwiKSB8fCBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtzZXNzaW9uSWR9L3IvJHtydW4uaWR9P3BvbGw9dHJ1ZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJ1bl8uYXBwX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1biAke3J1bklkfSBoYXMgbm8gYXBwX3BhdGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEhvc3RVcmwoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cnVuXy5hcHBfcGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBydW5JZCBvciBydW5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xvYWRDaGlsZFJ1bnMocnVuKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUnVucyA9IGF3YWl0IHRvQXJyYXkodGhpcy5saXN0UnVucyh7XG4gICAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgICAgICAgcHJvamVjdElkOiBydW4uc2Vzc2lvbl9pZCxcbiAgICAgICAgICAgIHRyYWNlSWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0cmVlbWFwID0ge307XG4gICAgICAgIGNvbnN0IHJ1bnMgPSB7fTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBkb3R0ZWQgb3JkZXIgcmVxdWlyZWQgd2hlbiB0aGUgbWlncmF0aW9uIGZpbmlzaGVzXG4gICAgICAgIGNoaWxkUnVucy5zb3J0KChhLCBiKSA9PiAoYT8uZG90dGVkX29yZGVyID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUoYj8uZG90dGVkX29yZGVyID8/IFwiXCIpKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiBjaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBydW4gJHtjaGlsZFJ1bi5pZH0gaGFzIG5vIHBhcmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkUnVuLmRvdHRlZF9vcmRlcj8uc3RhcnRzV2l0aChydW4uZG90dGVkX29yZGVyID8/IFwiXCIpICYmXG4gICAgICAgICAgICAgICAgY2hpbGRSdW4uaWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgICAgIHJ1bnNbY2hpbGRSdW4uaWRdID0gY2hpbGRSdW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bi5pZF0gfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgcnVuSWQgaW4gdHJlZW1hcCkge1xuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSBydW4uaWQpIHtcbiAgICAgICAgICAgICAgICBydW5zW3J1bklkXS5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBydW5zIGZyb20gdGhlIExhbmdTbWl0aCBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHByb2plY3RJZCAtIFRoZSBJRCBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwYXJlbnRSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcGFyZW50IHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHRyYWNlSWQgLSBUaGUgSUQgb2YgdGhlIHRyYWNlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlRXhhbXBsZUlkIC0gVGhlIElEIG9mIHRoZSByZWZlcmVuY2UgZXhhbXBsZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gaXNSb290IC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gb25seSByZXR1cm4gcm9vdCBydW5zLlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gdHJlZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIG90aGVyIHJ1bnMgaW4gdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBydW5zIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFJ1bj59IC0gVGhlIHJ1bnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3QgcHJvamVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IExMTSBhbmQgQ2hhdCBydW5zIGluIHRoZSBsYXN0IDI0IGhvdXJzXG4gICAgICogY29uc3QgdG9kYXlzTExNUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgc3RhcnRfdGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgICAqICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgdHJhY2VzIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHJvb3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBleGVjdXRpb25fb3JkZXI6IDEsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyB3aXRob3V0IGVycm9yc1xuICAgICAqIGNvbnN0IGNvcnJlY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBlcnJvcjogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyBieSBydW4gSURcbiAgICAgKiBjb25zdCBydW5JZHMgPSBbXG4gICAgICogICBcImEzNjA5MmQyLTRhZDUtNGZiNC05YzBkLTBkYmE5YTJlZDgzNlwiLFxuICAgICAqICAgXCI5Mzk4ZTZiZS05NjRmLTRhYTQtOGFlOS1hZDc4Y2Q0YjcwNzRcIixcbiAgICAgKiBdO1xuICAgICAqIGNvbnN0IHNlbGVjdGVkUnVucyA9IGNsaWVudC5saXN0UnVucyh7IHJ1bl9pZHM6IHJ1bklkcyB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgXCJjaGFpblwiIHR5cGUgcnVucyB0aGF0IHRvb2sgbW9yZSB0aGFuIDEwIHNlY29uZHMgYW5kIGhhZCBgdG90YWxfdG9rZW5zYCBncmVhdGVyIHRoYW4gNTAwMFxuICAgICAqIGNvbnN0IGNoYWluUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGVxKHJ1bl90eXBlLCBcImNoYWluXCIpLCBndChsYXRlbmN5LCAxMCksIGd0KHRvdGFsX3Rva2VucywgNTAwMCkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBjYWxsZWQgXCJleHRyYWN0b3JcIiB3aG9zZSByb290IG9mIHRoZSB0cmFjZSB3YXMgYXNzaWduZWQgZmVlZGJhY2sgXCJ1c2VyX3Njb3JlXCIgc2NvcmUgb2YgMVxuICAgICAqIGNvbnN0IGdvb2RFeHRyYWN0b3JSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdlcShuYW1lLCBcImV4dHJhY3RvclwiKScsXG4gICAgICogICB0cmFjZUZpbHRlcjogJ2FuZChlcShmZWVkYmFja19rZXksIFwidXNlcl9zY29yZVwiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDEpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgdGhhdCBzdGFydGVkIGFmdGVyIGEgc3BlY2lmaWMgdGltZXN0YW1wIGFuZCBlaXRoZXIgaGF2ZSBcImVycm9yXCIgbm90IGVxdWFsIHRvIG51bGwgb3IgYSBcIkNvcnJlY3RuZXNzXCIgZmVlZGJhY2sgc2NvcmUgZXF1YWwgdG8gMFxuICAgICAqIGNvbnN0IGNvbXBsZXhSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZ3Qoc3RhcnRfdGltZSwgXCIyMDIzLTA3LTE1VDEyOjM0OjU2WlwiKSwgb3IobmVxKGVycm9yLCBudWxsKSwgYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJDb3JyZWN0bmVzc1wiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDAuMCkpKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHdoZXJlIGB0YWdzYCBpbmNsdWRlIFwiZXhwZXJpbWVudGFsXCIgb3IgXCJiZXRhXCIgYW5kIGBsYXRlbmN5YCBpcyBncmVhdGVyIHRoYW4gMiBzZWNvbmRzXG4gICAgICogY29uc3QgdGFnZ2VkUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKG9yKGhhcyh0YWdzLCBcImV4cGVyaW1lbnRhbFwiKSwgaGFzKHRhZ3MsIFwiYmV0YVwiKSksIGd0KGxhdGVuY3ksIDIpKScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RSdW5zKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgcGFyZW50UnVuSWQsIHRyYWNlSWQsIHJlZmVyZW5jZUV4YW1wbGVJZCwgc3RhcnRUaW1lLCBleGVjdXRpb25PcmRlciwgaXNSb290LCBydW5UeXBlLCBlcnJvciwgaWQsIHF1ZXJ5LCBmaWx0ZXIsIHRyYWNlRmlsdGVyLCB0cmVlRmlsdGVyLCBsaW1pdCwgc2VsZWN0LCBvcmRlciwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgcHJvamVjdElkcyA9IFtdO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0SWQpID8gcHJvamVjdElkIDogW3Byb2plY3RJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0TmFtZXMgPSBBcnJheS5pc0FycmF5KHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgID8gcHJvamVjdE5hbWVcbiAgICAgICAgICAgICAgICA6IFtwcm9qZWN0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0SWRzXyA9IGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpO1xuICAgICAgICAgICAgcHJvamVjdElkcy5wdXNoKC4uLnByb2plY3RJZHNfKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0X3NlbGVjdCA9IFtcbiAgICAgICAgICAgIFwiYXBwX3BhdGhcIixcbiAgICAgICAgICAgIFwiY29tcGxldGlvbl9jb3N0XCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fdG9rZW5zXCIsXG4gICAgICAgICAgICBcImRvdHRlZF9vcmRlclwiLFxuICAgICAgICAgICAgXCJlbmRfdGltZVwiLFxuICAgICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgXCJldmVudHNcIixcbiAgICAgICAgICAgIFwiZXh0cmFcIixcbiAgICAgICAgICAgIFwiZmVlZGJhY2tfc3RhdHNcIixcbiAgICAgICAgICAgIFwiZmlyc3RfdG9rZW5fdGltZVwiLFxuICAgICAgICAgICAgXCJpZFwiLFxuICAgICAgICAgICAgXCJpbnB1dHNcIixcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgXCJvdXRwdXRzXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRcIixcbiAgICAgICAgICAgIFwicGFyZW50X3J1bl9pZHNcIixcbiAgICAgICAgICAgIFwicHJvbXB0X2Nvc3RcIixcbiAgICAgICAgICAgIFwicHJvbXB0X3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLFxuICAgICAgICAgICAgXCJydW5fdHlwZVwiLFxuICAgICAgICAgICAgXCJzZXNzaW9uX2lkXCIsXG4gICAgICAgICAgICBcInN0YXJ0X3RpbWVcIixcbiAgICAgICAgICAgIFwic3RhdHVzXCIsXG4gICAgICAgICAgICBcInRhZ3NcIixcbiAgICAgICAgICAgIFwidG90YWxfY29zdFwiLFxuICAgICAgICAgICAgXCJ0b3RhbF90b2tlbnNcIixcbiAgICAgICAgICAgIFwidHJhY2VfaWRcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHNlc3Npb246IHByb2plY3RJZHMubGVuZ3RoID8gcHJvamVjdElkcyA6IG51bGwsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHRyYWNlX2ZpbHRlcjogdHJhY2VGaWx0ZXIsXG4gICAgICAgICAgICB0cmVlX2ZpbHRlcjogdHJlZUZpbHRlcixcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uT3JkZXIsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSA/IHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIHRyYWNlOiB0cmFjZUlkLFxuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3QgPyBzZWxlY3QgOiBkZWZhdWx0X3NlbGVjdCxcbiAgICAgICAgICAgIGlzX3Jvb3Q6IGlzUm9vdCxcbiAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYm9keS5zZWxlY3QuaW5jbHVkZXMoXCJjaGlsZF9ydW5faWRzXCIpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcIkRlcHJlY2F0ZWQ6ICdjaGlsZF9ydW5faWRzJyBpbiB0aGUgbGlzdFJ1bnMgc2VsZWN0IHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bnNZaWVsZGVkID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnNZaWVsZGVkID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVucy5sZW5ndGggKyBydW5zWWllbGRlZCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1J1bnMgPSBydW5zLnNsaWNlKDAsIGxpbWl0IC0gcnVuc1lpZWxkZWQpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogbmV3UnVucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bnNZaWVsZGVkICs9IHJ1bnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RHcm91cFJ1bnMocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBncm91cEJ5LCBmaWx0ZXIsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIG9mZnNldCwgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwcm9qZWN0SWQgfHwgKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGNvbnN0IGJhc2VCb2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgZ3JvdXBfYnk6IGdyb3VwQnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSA/IGVuZFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBsaW1pdDogTnVtYmVyKGxpbWl0KSB8fCAxMDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL3J1bnMvZ3JvdXBcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofWA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlQm9keSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGN1cnJlbnRPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGN1cnJlbnRCb2R5KS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgeyBncm91cHMsIHRvdGFsIH0gPSBpdGVtcztcbiAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiBncm91cHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGdyb3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY3VycmVudE9mZnNldCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0YXRzKHsgaWQsIHRyYWNlLCBwYXJlbnRSdW4sIHJ1blR5cGUsIHByb2plY3ROYW1lcywgcHJvamVjdElkcywgcmVmZXJlbmNlRXhhbXBsZUlkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvciwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGlzUm9vdCwgZGF0YVNvdXJjZVR5cGUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZHNfID0gcHJvamVjdElkcyB8fCBbXTtcbiAgICAgICAgaWYgKHByb2plY3ROYW1lcykge1xuICAgICAgICAgICAgcHJvamVjdElkc18gPSBbXG4gICAgICAgICAgICAgICAgLi4uKHByb2plY3RJZHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNlLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzXyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWRzLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgZGF0YV9zb3VyY2VfdHlwZTogZGF0YVNvdXJjZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gdGhlIHBheWxvYWRcbiAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRQYXlsb2FkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zL3N0YXRzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBydW4gc3RhdHNcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaGFyZVJ1bihydW5JZCwgeyBzaGFyZUlkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZUlkIHx8IHV1aWQudjQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInNoYXJlIHJ1blwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZVJ1bihydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidW5zaGFyZSBydW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBydW4gc2hhcmVkIGxpbmtcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RTaGFyZWRSdW5zKHNoYXJlVG9rZW4sIHsgcnVuSWRzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZVRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJ1bklkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIG9mIHJ1bklkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImlkXCIsIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L3J1bnMke3F1ZXJ5UGFyYW1zfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwibGlzdCBzaGFyZWQgcnVuc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBkYXRhc2V0IHNoYXJlZCBzY2hlbWFcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJzaGFyZSBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidW5zaGFyZSBkYXRhc2V0XCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTaGFyZWREYXRhc2V0KHNoYXJlVG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBzaGFyZWQgZGF0YXNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNoYXJlZCBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFyZVRva2VuIFRoZSBzaGFyZSB0b2tlbiB0byBnZXQgZXhhbXBsZXMgZm9yLiBBIHNoYXJlIHRva2VuIGlzIHRoZSBVVUlEIChvciBMYW5nU21pdGggVVJMLCBpbmNsdWRpbmcgVVVJRCkgZ2VuZXJhdGVkIHdoZW4gZXhwbGljaXRseSBtYXJraW5nIGFuIGV4YW1wbGUgYXMgcHVibGljLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBsaXN0aW5nIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgdW5kZWZpbmVkfSBbb3B0aW9ucy5leGFtcGxlSWRzXSBBIGxpc3Qgb2YgZXhhbXBsZSBJRHMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEV4YW1wbGVbXT59IFRoZSBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFNoYXJlZEV4YW1wbGVzKHNoYXJlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5leGFtcGxlSWRzKSB7XG4gICAgICAgICAgICBwYXJhbXMuaWQgPSBvcHRpb25zLmV4YW1wbGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4gdXJsUGFyYW1zLmFwcGVuZChrZXksIHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2V4YW1wbGVzPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJsaXN0IHNoYXJlZCBleGFtcGxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChcImRldGFpbFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzLlxcblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XFxuTWVzc2FnZTogJHtBcnJheS5pc0FycmF5KHJlc3VsdC5kZXRhaWwpXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LmRldGFpbC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCJVbnNwZWNpZmllZCBlcnJvclwifWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBzaGFyZWQgZXhhbXBsZXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGV4YW1wbGUpID0+ICh7XG4gICAgICAgICAgICAuLi5leGFtcGxlLFxuICAgICAgICAgICAgX2hvc3RVcmw6IHRoaXMuZ2V0SG9zdFVybCgpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgcHJvamVjdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc1Byb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGhlYWQgcmVxdWVzdFxuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImhhcyBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gcmVsZWFzZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3MgT0sgYW5kIHdlJ3JlIHF1ZXJ5aW5nIGJ5IG5hbWUsIG5lZWQgdG8gY2hlY2sgdGhlIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvamVjdElkIHF1ZXJ5aW5nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgaW5jbHVkZVN0YXRzLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvc2Vzc2lvbnNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZCk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlU3RhdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImluY2x1ZGVfc3RhdHNcIiwgaW5jbHVkZVN0YXRzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvamVjdFtpZD0ke3Byb2plY3RJZH0sIG5hbWU9JHtwcm9qZWN0TmFtZX1dIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2VbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZXRQcm9qZWN0VXJsKHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lIH0pO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9wcm9qZWN0cy9wLyR7cHJvamVjdC5pZH1gO1xuICAgIH1cbiAgICBhc3luYyBnZXREYXRhc2V0VXJsKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lIH0pO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9kYXRhc2V0cy8ke2RhdGFzZXQuaWR9YDtcbiAgICB9XG4gICAgYXN5bmMgX2dldFRlbmFudElkKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVuYW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcHJvamVjdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3Nlc3Npb25zXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgdGhpcy5fdGVuYW50SWQgPSBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb2plY3RzIGZvdW5kIHRvIHJlc29sdmUgdGVuYW50LlwiKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9qZWN0cyh7IHByb2plY3RJZHMsIG5hbWUsIG5hbWVDb250YWlucywgcmVmZXJlbmNlRGF0YXNldElkLCByZWZlcmVuY2VEYXRhc2V0TmFtZSwgaW5jbHVkZVN0YXRzLCBkYXRhc2V0VmVyc2lvbiwgcmVmZXJlbmNlRnJlZSwgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJkYXRhc2V0X3ZlcnNpb25cIiwgZGF0YXNldFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZnJlZVwiLCByZWZlcmVuY2VGcmVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGRlbGV0ZSBzZXNzaW9uICR7cHJvamVjdElkX30gKCR7cHJvamVjdE5hbWV9KWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZGaWxlXSwgeyB0eXBlOiBcInRleHQvY3N2XCIgfSk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgY3N2QmxvYiwgZmlsZU5hbWUpO1xuICAgICAgICBpbnB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbnB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwib3V0cHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZGF0YV90eXBlXCIsIGRhdGFUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGxvYWQgQ1NWXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgaW5wdXRzU2NoZW1hLCBvdXRwdXRzU2NoZW1hLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRzU2NoZW1hKSB7XG4gICAgICAgICAgICBib2R5LmlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiA9IGlucHV0c1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0c1NjaGVtYSkge1xuICAgICAgICAgICAgYm9keS5vdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uID0gb3V0cHV0c1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogc2VyaWFsaXplZEJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgZGF0YXNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgJiYgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBkYXRhc2V0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YXNldFtpZD0ke2RhdGFzZXRJZH0sIG5hbWU9JHtkYXRhc2V0TmFtZX1dIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2VbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJub3QgZm91bmRcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRpZmZEYXRhc2V0VmVyc2lvbnMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBmcm9tVmVyc2lvbiwgdG9WZXJzaW9uLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBmcm9tX3ZlcnNpb246IHR5cGVvZiBmcm9tVmVyc2lvbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gZnJvbVZlcnNpb25cbiAgICAgICAgICAgICAgICA6IGZyb21WZXJzaW9uLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB0b192ZXJzaW9uOiB0eXBlb2YgdG9WZXJzaW9uID09PSBcInN0cmluZ1wiID8gdG9WZXJzaW9uIDogdG9WZXJzaW9uLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChgL2RhdGFzZXRzLyR7ZGF0YXNldElkX30vdmVyc2lvbnMvZGlmZmAsIHVybFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRPcGVuYWlGaW5ldHVuaW5nKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldC50b1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZGF0YXNldElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBkYXRhc2V0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgZGF0YXNldE5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVwiLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YXNldHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKHBhdGgsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBkYXRhc2V0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBkYXRhc2V0XG4gICAgICogQHBhcmFtIHByb3BzIFRoZSBkYXRhc2V0IGRldGFpbHMgdG8gdXBkYXRlXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgZGF0YXNldFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXQocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCAuLi51cGRhdGUgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9kYXRhc2V0SWQgPSBkYXRhc2V0SWQgPz8gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGFzc2VydFV1aWQoX2RhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGUpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7X2RhdGFzZXRJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHRhZyBvbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFnIGlzIGFscmVhZHkgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiB0aGlzIGRhdGFzZXQsXG4gICAgICogdGhlIHRhZyB3aWxsIGJlIG1vdmVkIHRvIHRoZSBuZXcgdmVyc2lvbi4gVGhlIGFzX29mIHBhcmFtZXRlciBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoaWNoIHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqXG4gICAgICogSXQgbXVzdCBiZSBhbiBleGFjdCB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IHRvIHN1Y2NlZWQuIFlvdSBjYW5cbiAgICAgKiB1c2UgdGhlIFwicmVhZERhdGFzZXRWZXJzaW9uXCIgbWV0aG9kIHRvIGZpbmQgdGhlIGV4YWN0IHZlcnNpb25cbiAgICAgKiB0byBhcHBseSB0aGUgdGFncyB0by5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLmRhdGFzZXRJZCBUaGUgSUQgb2YgdGhlIGRhdGFzZXQgdG8gdXBkYXRlLiBNdXN0IGJlIHByb3ZpZGVkIGlmIFwiZGF0YXNldE5hbWVcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5kYXRhc2V0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byB1cGRhdGUuIE11c3QgYmUgcHJvdmlkZWQgaWYgXCJkYXRhc2V0SWRcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5hc09mIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqIEBwYXJhbSBwYXJhbXMudGFnIFRoZSBuZXcgdGFnIHRvIGFwcGx5IHRvIHRoZSBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXRUYWcocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB0YWcgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9kYXRhc2V0SWQgPSBkYXRhc2V0SWQgPz8gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGFzc2VydFV1aWQoX2RhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBhc19vZjogdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCIgPyBhc09mIDogYXNPZi50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdGFnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtfZGF0YXNldElkfS90YWdzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGRhdGFzZXQgdGFnc1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkX31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGRlbGV0ZSAke3BhdGh9YCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW5kZXhEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgdGFnLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZF8gJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICYmIGRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRhdGFzZXRJZF8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L2luZGV4YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImluZGV4IGRhdGFzZXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXRzIHlvdSBydW4gYSBzaW1pbGFyaXR5IHNlYXJjaCBxdWVyeSBvbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlcyB0aGUgZGF0YXNldCB0byBiZSBpbmRleGVkLiBQbGVhc2Ugc2VlIHRoZSBgaW5kZXhEYXRhc2V0YCBtZXRob2QgdG8gc2V0IHVwIGluZGV4aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0cyAgICAgIFRoZSBpbnB1dCBvbiB3aGljaCB0byBydW4gdGhlIHNpbWlsYXJpdHkgc2VhcmNoLiBNdXN0IGhhdmUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgIHNhbWUgc2NoZW1hIGFzIHRoZSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFzZXRJZCAgIFRoZSBkYXRhc2V0IHRvIHNlYXJjaCBmb3Igc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW1pdCAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXhhbXBsZXMgdG8gcmV0dXJuLiBXaWxsIHJldHVybiB0aGUgdG9wIGBsaW1pdGAgbW9zdFxuICAgICAqICAgICAgICAgICAgICAgICAgICBzaW1pbGFyIGV4YW1wbGVzIGluIG9yZGVyIG9mIG1vc3Qgc2ltaWxhciB0byBsZWFzdCBzaW1pbGFyLiBJZiBubyBzaW1pbGFyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGV4YW1wbGVzIGFyZSBmb3VuZCwgcmFuZG9tIGV4YW1wbGVzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyICAgICAgQSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBzZWFyY2guIE9ubHkgZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZCB0aGF0XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1hdGNoIHRoZSBmaWx0ZXIgc3RyaW5nLiBTb21lIGV4YW1wbGVzIG9mIGZpbHRlcnNcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIGVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gYW5kKG5lcShtZXRhZGF0YS5teS5uZXN0ZWQua2V5LCBcInZhbHVlXCIpLCBuZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIikpXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gb3IoZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIiksIGVxKG1ldGFkYXRhLm15a2V5LCBcIm90aGVydmFsdWVcIikpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAgICAgICAgICAgQSBsaXN0IG9mIHNpbWlsYXIgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YXNldF9pZCA9IFwiMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwXCJcbiAgICAgKiBpbnB1dHMgPSB7XCJ0ZXh0XCI6IFwiSG93IG1hbnkgcGVvcGxlIGxpdmUgaW4gQmVybGluP1wifVxuICAgICAqIGxpbWl0ID0gNVxuICAgICAqIGV4YW1wbGVzID0gYXdhaXQgY2xpZW50LnNpbWlsYXJFeGFtcGxlcyhpbnB1dHMsIGRhdGFzZXRfaWQsIGxpbWl0KVxuICAgICAqL1xuICAgIGFzeW5jIHNpbWlsYXJFeGFtcGxlcyhpbnB1dHMsIGRhdGFzZXRJZCwgbGltaXQsIHsgZmlsdGVyLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFbXCJmaWx0ZXJcIl0gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NlYXJjaGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJmZXRjaCBzaW1pbGFyIGV4YW1wbGVzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFtcImV4YW1wbGVzXCJdO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0c09yVXBkYXRlLCBvdXRwdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc0V4YW1wbGVDcmVhdGUoaW5wdXRzT3JVcGRhdGUpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0cyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm92aWRlIG91dHB1dHMgb3Igb3B0aW9ucyB3aGVuIHVzaW5nIEV4YW1wbGVDcmVhdGUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gb3V0cHV0cyA/IG9wdGlvbnM/LmRhdGFzZXRJZCA6IGlucHV0c09yVXBkYXRlLmRhdGFzZXRfaWQ7XG4gICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IG91dHB1dHNcbiAgICAgICAgICAgID8gb3B0aW9ucz8uZGF0YXNldE5hbWVcbiAgICAgICAgICAgIDogaW5wdXRzT3JVcGRhdGUuZGF0YXNldF9uYW1lO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdF8gPSAob3V0cHV0cyA/IG9wdGlvbnM/LmNyZWF0ZWRBdCA6IGlucHV0c09yVXBkYXRlLmNyZWF0ZWRfYXQpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAoIWlzRXhhbXBsZUNyZWF0ZShpbnB1dHNPclVwZGF0ZSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNPclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRBdF8/LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaWQ6IG9wdGlvbnM/LmV4YW1wbGVJZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc3BsaXQ6IG9wdGlvbnM/LnNwbGl0LFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IG9wdGlvbnM/LnNvdXJjZVJ1bklkLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiBvcHRpb25zPy51c2VTb3VyY2VSdW5JTyxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogb3B0aW9ucz8udXNlU291cmNlUnVuQXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IG9wdGlvbnM/LmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbnB1dHNPclVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIFtkYXRhXSk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKHJlc3BvbnNlLmV4YW1wbGVfaWRzPy5bMF0gPz8gdXVpZC52NCgpKTtcbiAgICAgICAgcmV0dXJuIGV4YW1wbGU7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGVzKHByb3BzT3JVcGxvYWRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzT3JVcGxvYWRzKSkge1xuICAgICAgICAgICAgaWYgKHByb3BzT3JVcGxvYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZHMgPSBwcm9wc09yVXBsb2FkcztcbiAgICAgICAgICAgIGxldCBkYXRhc2V0SWRfID0gdXBsb2Fkc1swXS5kYXRhc2V0X2lkO1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gdXBsb2Fkc1swXS5kYXRhc2V0X25hbWU7XG4gICAgICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIHVwbG9hZHMpO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS5leGFtcGxlX2lkcy5tYXAoKGlkKSA9PiB0aGlzLnJlYWRFeGFtcGxlKGlkKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBtZXRhZGF0YSwgc3BsaXRzLCBzb3VyY2VSdW5JZHMsIHVzZVNvdXJjZVJ1bklPcywgdXNlU291cmNlUnVuQXR0YWNobWVudHMsIGF0dGFjaG1lbnRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHNPclVwbG9hZHM7XG4gICAgICAgIGlmIChpbnB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGlucHV0cyB3aGVuIHVzaW5nIGxlZ2FjeSBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSBkYXRhc2V0TmFtZTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IGlucHV0cy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YT8uW2lkeF0sXG4gICAgICAgICAgICAgICAgc3BsaXQ6IHNwbGl0cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgc291cmNlX3J1bl9pZDogc291cmNlUnVuSWRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogdXNlU291cmNlUnVuSU9zPy5baWR4XSxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogdXNlU291cmNlUnVuQXR0YWNobWVudHM/LltpZHhdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgZm9ybWF0dGVkRXhhbXBsZXMpO1xuICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLmV4YW1wbGVfaWRzLm1hcCgoaWQpID0+IHRoaXMucmVhZEV4YW1wbGUoaWQpKSk7XG4gICAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTExNRXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQgfSwgeyBvdXRwdXQ6IGdlbmVyYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNoYXRFeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaW5hbElucHV0ID0gaW5wdXQubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbE91dHB1dCA9IGlzTGFuZ0NoYWluTWVzc2FnZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgID8gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQ6IGZpbmFsSW5wdXQgfSwgeyBvdXRwdXQ6IGZpbmFsT3V0cHV0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByYXdFeGFtcGxlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgICAgICBjb25zdCB7IGF0dGFjaG1lbnRfdXJscywgLi4ucmVzdCB9ID0gcmF3RXhhbXBsZTtcbiAgICAgICAgY29uc3QgZXhhbXBsZSA9IHJlc3Q7XG4gICAgICAgIGlmIChhdHRhY2htZW50X3VybHMpIHtcbiAgICAgICAgICAgIGV4YW1wbGUuYXR0YWNobWVudHMgPSBPYmplY3QuZW50cmllcyhhdHRhY2htZW50X3VybHMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5LnNsaWNlKFwiYXR0YWNobWVudC5cIi5sZW5ndGgpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2lnbmVkX3VybDogdmFsdWUucHJlc2lnbmVkX3VybCxcbiAgICAgICAgICAgICAgICAgICAgbWltZV90eXBlOiB2YWx1ZS5taW1lX3R5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGFtcGxlO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEV4YW1wbGVzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZXhhbXBsZUlkcywgYXNPZiwgc3BsaXRzLCBpbmxpbmVTM1VybHMsIG1ldGFkYXRhLCBsaW1pdCwgb2Zmc2V0LCBmaWx0ZXIsIGluY2x1ZGVBdHRhY2htZW50cywgfSA9IHt9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBhIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZGF0YXNldDogZGF0YXNldElkXyB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldF92ZXJzaW9uID0gYXNPZlxuICAgICAgICAgICAgPyB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gYXNPZlxuICAgICAgICAgICAgICAgIDogYXNPZj8udG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkYXRhc2V0X3ZlcnNpb24pIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJhc19vZlwiLCBkYXRhc2V0X3ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlubGluZVMzVXJsc18gPSBpbmxpbmVTM1VybHMgPz8gdHJ1ZTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImlubGluZV9zM191cmxzXCIsIGlubGluZVMzVXJsc18udG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BsaXQgb2Ygc3BsaXRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInNwbGl0c1wiLCBzcGxpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXRhZGF0YSA9IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVwiLCBzZXJpYWxpemVkTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwib2Zmc2V0XCIsIG9mZnNldC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJmaWx0ZXJcIiwgZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZUF0dGFjaG1lbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBbXCJhdHRhY2htZW50X3VybHNcIiwgXCJvdXRwdXRzXCIsIFwibWV0YWRhdGFcIl0uZm9yRWFjaCgoZmllbGQpID0+IHBhcmFtcy5hcHBlbmQoXCJzZWxlY3RcIiwgZmllbGQpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcmF3RXhhbXBsZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2V4YW1wbGVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmF3RXhhbXBsZSBvZiByYXdFeGFtcGxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0YWNobWVudF91cmxzLCAuLi5yZXN0IH0gPSByYXdFeGFtcGxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSByZXN0O1xuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50X3VybHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZS5hdHRhY2htZW50cyA9IE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRfdXJscykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW2tleS5zbGljZShcImF0dGFjaG1lbnQuXCIubGVuZ3RoKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2lnbmVkX3VybDogdmFsdWUucHJlc2lnbmVkX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lX3R5cGU6IHZhbHVlLm1pbWVfdHlwZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBleGFtcGxlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGkgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZGVsZXRlICR7cGF0aH1gLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgbXVsdGlwbGUgZXhhbXBsZXMgYnkgSUQuXG4gICAgICogQHBhcmFtIGV4YW1wbGVJZHMgLSBUaGUgSURzIG9mIHRoZSBleGFtcGxlcyB0byBkZWxldGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzIGZvciBkZWxldGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhhcmREZWxldGUgLSBJZiB0cnVlLCBwZXJtYW5lbnRseSBkZWxldGUgZXhhbXBsZXMuIElmIGZhbHNlIChkZWZhdWx0KSwgc29mdCBkZWxldGUgdGhlbS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlcyhleGFtcGxlSWRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGFsbCBVVUlEc1xuICAgICAgICBleGFtcGxlSWRzLmZvckVhY2goKGlkKSA9PiBhc3NlcnRVdWlkKGlkKSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5oYXJkRGVsZXRlKSB7XG4gICAgICAgICAgICAvLyBIYXJkIGRlbGV0ZSB1c2VzIFBPU1QgdG8gYSBkaWZmZXJlbnQgcGxhdGZvcm0gZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aChcImRhdGFzZXRzL2V4YW1wbGVzL2RlbGV0ZVwiKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfSR7cGF0aH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlX2lkczogZXhhbXBsZUlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhcmRfZGVsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJoYXJkIGRlbGV0ZSBleGFtcGxlc1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTb2Z0IGRlbGV0ZSB1c2VzIERFTEVURSB3aXRoIHF1ZXJ5IHBhcmFtc1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgZXhhbXBsZUlkcy5mb3JFYWNoKChpZCkgPT4gcGFyYW1zLmFwcGVuZChcImV4YW1wbGVfaWRzXCIsIGlkKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXM/JHtwYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImRlbGV0ZSBleGFtcGxlc1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWRPclVwZGF0ZSwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBleGFtcGxlSWQ7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIGV4YW1wbGVJZCA9IGV4YW1wbGVJZE9yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhhbXBsZUlkID0gZXhhbXBsZUlkT3JVcGRhdGUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBsZXQgdXBkYXRlVG9Vc2U7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0geyBpZDogZXhhbXBsZUlkLCAuLi51cGRhdGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0gZXhhbXBsZUlkT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKHVwZGF0ZVRvVXNlLmRhdGFzZXRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gdXBkYXRlVG9Vc2UuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKGV4YW1wbGVJZCk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBleGFtcGxlLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgW3VwZGF0ZVRvVXNlXSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzKHVwZGF0ZSkge1xuICAgICAgICAvLyBXZSB3aWxsIG5haXZlbHkgZ2V0IGRhdGFzZXQgaWQgZnJvbSBmaXJzdCBleGFtcGxlIGFuZCBhc3N1bWUgaXQgd29ya3MgZm9yIGFsbFxuICAgICAgICBsZXQgZGF0YXNldElkO1xuICAgICAgICBpZiAodXBkYXRlWzBdLmRhdGFzZXRfaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUodXBkYXRlWzBdLmlkKTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGV4YW1wbGUuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IHVwZGF0ZVswXS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhc2V0IHZlcnNpb24gYnkgY2xvc2VzdCBkYXRlIG9yIGV4YWN0IHRhZy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHRvIHJlc29sdmUgdGhlIG5lYXJlc3QgdmVyc2lvbiB0byBhIGdpdmVuIHRpbWVzdGFtcCBvciBmb3IgYSBnaXZlbiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YXNldElkIFRoZSBJRCBvZiB0aGUgZGF0YXNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGFzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNPZiBUaGUgdGltZXN0YW1wIG9mIHRoZSBkYXRhc2V0IHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGFnIFRoZSB0YWcgb2YgdGhlIGRhdGFzZXQgdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICovXG4gICAgYXN5bmMgcmVhZERhdGFzZXRWZXJzaW9uKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgdGFnLCB9KSB7XG4gICAgICAgIGxldCByZXNvbHZlZERhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHJlc29sdmVkRGF0YXNldElkKTtcbiAgICAgICAgaWYgKChhc09mICYmIHRhZykgfHwgKCFhc09mICYmICF0YWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGFjdGx5IG9uZSBvZiBhc09mIGFuZCB0YWcgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKGFzT2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiID8gYXNPZiA6IGFzT2YudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke3Jlc29sdmVkRGF0YXNldElkfS92ZXJzaW9uPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBkYXRhc2V0IHZlcnNpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdERhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHNwbGl0TmFtZSwgZXhhbXBsZUlkcywgcmVtb3ZlID0gZmFsc2UsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc3BsaXRfbmFtZTogc3BsaXROYW1lLFxuICAgICAgICAgICAgZXhhbXBsZXM6IGV4YW1wbGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVtb3ZlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vc3BsaXRzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGRhdGFzZXQgc3BsaXRzXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBrZXksIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCBzb3VyY2VJbmZvLCBmZWVkYmFja1NvdXJjZVR5cGUgPSBcImFwaVwiLCBzb3VyY2VSdW5JZCwgZmVlZGJhY2tJZCwgZmVlZGJhY2tDb25maWcsIHByb2plY3RJZCwgY29tcGFyYXRpdmVFeHBlcmltZW50SWQsIH0pIHtcbiAgICAgICAgaWYgKCFydW5JZCAmJiAhcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bklkICYmIHByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIGNhbiBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFja19zb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBmZWVkYmFja1NvdXJjZVR5cGUgPz8gXCJhcGlcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzb3VyY2VJbmZvID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlUnVuSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0pIHtcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdID0geyBydW5faWQ6IHNvdXJjZVJ1bklkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0/LnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdLnJ1bl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2sgPSB7XG4gICAgICAgICAgICBpZDogZmVlZGJhY2tJZCA/PyB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2NvcmU6IF9mb3JtYXRGZWVkYmFja1Njb3JlKHNjb3JlKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgICAgIGNvbXBhcmF0aXZlX2V4cGVyaW1lbnRfaWQ6IGNvbXBhcmF0aXZlRXhwZXJpbWVudElkLFxuICAgICAgICAgICAgZmVlZGJhY2tDb25maWcsXG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBwcm9qZWN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShmZWVkYmFjayk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9mZWVkYmFja2A7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWVkYmFjaztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVlZGJhY2soZmVlZGJhY2tJZCwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIH0pIHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tVcGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wic2NvcmVcIl0gPSBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShmZWVkYmFja1VwZGF0ZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBmZWVkYmFja1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZWFkRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBkZWxldGUgJHtwYXRofWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIG9mIHJ1bklkcykge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInJ1blwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwic291cmNlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZmVlZGJhY2tzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFja1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmZWVkYmFja3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbiBhbmQgVVJMLlxuICAgICAqXG4gICAgICogVGhlIHRva2VuIGNhbiBiZSB1c2VkIHRvIGF1dGhvcml6ZSBmZWVkYmFjayBtZXRyaWNzIHdpdGhvdXRcbiAgICAgKiBuZWVkaW5nIGFuIEFQSSBrZXkuIFRoaXMgaXMgdXNlZnVsIGZvciBnaXZpbmcgYnJvd3Nlci1iYXNlZFxuICAgICAqIGFwcGxpY2F0aW9ucyB0aGUgYWJpbGl0eSB0byBzdWJtaXQgZmVlZGJhY2sgd2l0aG91dCBuZWVkaW5nXG4gICAgICogdG8gZXhwb3NlIGFuIEFQSSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHBhcmFtIGZlZWRiYWNrS2V5IFRoZSBmZWVkYmFjayBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXhwaXJhdGlvbiBUaGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZlZWRiYWNrSW5nZXN0VG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUHJlc2lnbmVkRmVlZGJhY2tUb2tlbihydW5JZCwgZmVlZGJhY2tLZXksIHsgZXhwaXJhdGlvbiwgZmVlZGJhY2tDb25maWcsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIGZlZWRiYWNrX2tleTogZmVlZGJhY2tLZXksXG4gICAgICAgICAgICBmZWVkYmFja19jb25maWc6IGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXhwaXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfYXRcIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwaXJhdGlvbj8uaG91cnMgfHwgZXhwaXJhdGlvbj8ubWludXRlcyB8fCBleHBpcmF0aW9uPy5kYXlzKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSB7XG4gICAgICAgICAgICAgICAgaG91cnM6IDMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svdG9rZW5zYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogc2VyaWFsaXplZEJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbXBhcmF0aXZlRXhwZXJpbWVudCh7IG5hbWUsIGV4cGVyaW1lbnRJZHMsIHJlZmVyZW5jZURhdGFzZXRJZCwgY3JlYXRlZEF0LCBkZXNjcmlwdGlvbiwgbWV0YWRhdGEsIGlkLCB9KSB7XG4gICAgICAgIGlmIChleHBlcmltZW50SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGV4cGVyaW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZURhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IGV4cGVyaW1lbnRJZHNbMF0sXG4gICAgICAgICAgICB9KSkucmVmZXJlbmNlX2RhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWZlcmVuY2UgZGF0YXNldCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXhwZXJpbWVudF9pZHM6IGV4cGVyaW1lbnRJZHMsXG4gICAgICAgICAgICByZWZlcmVuY2VfZGF0YXNldF9pZDogcmVmZXJlbmNlRGF0YXNldElkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiAoY3JlYXRlZEF0ID8/IG5ldyBEYXRlKCkpPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWV0YWRhdGEpXG4gICAgICAgICAgICBib2R5LmV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy9jb21wYXJhdGl2ZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIGNvbXBhcmF0aXZlIGV4cGVyaW1lbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW5zIGZvciBhIGdpdmVuIHJ1biBJRC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgaXRlcmFibGUgb2YgRmVlZGJhY2tJbmdlc3RUb2tlbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBydW5faWQ6IHJ1bklkIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHRva2VucyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2svdG9rZW5zXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0b2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbGVjdEV2YWxSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHNfO1xuICAgICAgICBpZiAoXCJyZXN1bHRzXCIgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0c18gPSByZXN1bHRzLnJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgcmVzdWx0c18gPSByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0c18gPSBbcmVzdWx0c107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHNfO1xuICAgIH1cbiAgICBhc3luYyBfbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGV2YWx1YXRvclJlc3BvbnNlLCBydW4sIHNvdXJjZUluZm8pIHtcbiAgICAgICAgY29uc3QgZXZhbFJlc3VsdHMgPSB0aGlzLl9zZWxlY3RFdmFsUmVzdWx0cyhldmFsdWF0b3JSZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcyBvZiBldmFsUmVzdWx0cykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZUluZm9fID0gc291cmNlSW5mbyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXMuZXZhbHVhdG9ySW5mbykge1xuICAgICAgICAgICAgICAgIHNvdXJjZUluZm9fID0geyAuLi5yZXMuZXZhbHVhdG9ySW5mbywgLi4uc291cmNlSW5mb18gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydW5JZF8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcy50YXJnZXRSdW5JZCkge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJlcy50YXJnZXRSdW5JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bikge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJ1bi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlZWRiYWNrcy5wdXNoKGF3YWl0IHRoaXMuY3JlYXRlRmVlZGJhY2socnVuSWRfLCByZXMua2V5LCB7XG4gICAgICAgICAgICAgICAgc2NvcmU6IHJlcy5zY29yZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHJlcy5jb21tZW50LFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb246IHJlcy5jb3JyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgICAgIHNvdXJjZVJ1bklkOiByZXMuc291cmNlUnVuSWQsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDb25maWc6IHJlcy5mZWVkYmFja0NvbmZpZyxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1NvdXJjZVR5cGU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2V2YWxSZXN1bHRzLCBmZWVkYmFja3NdO1xuICAgIH1cbiAgICBhc3luYyBsb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLl9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBUEkgZm9yIG1hbmFnaW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgYW5ub3RhdGlvbiBxdWV1ZXMgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgbGlzdGluZyBhbm5vdGF0aW9uIHF1ZXVlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWRzIC0gVGhlIElEcyBvZiB0aGUgcXVldWVzIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVldWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZUNvbnRhaW5zIC0gVGhlIHN1YnN0cmluZyB0aGF0IHRoZSBxdWV1ZSBuYW1lIHNob3VsZCBjb250YWluXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcXVldWVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIEFubm90YXRpb25RdWV1ZSBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RBbm5vdGF0aW9uUXVldWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlSWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIGxpbWl0IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChxdWV1ZUlkcykge1xuICAgICAgICAgICAgcXVldWVJZHMuZm9yRWFjaCgoaWQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKGlkLCBgcXVldWVJZHNbJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRzXCIsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgKGxpbWl0ICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbihsaW1pdCwgMTAwKSA6IDEwMCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcXVldWVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9hbm5vdGF0aW9uLXF1ZXVlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcXVldWVzO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGNvdW50ID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIG9uIHRoZSBMYW5nU21pdGggQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBBbm5vdGF0aW9uUXVldWUgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5ub3RhdGlvblF1ZXVlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiwgcXVldWVJZCwgcnVicmljSW5zdHJ1Y3Rpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaWQ6IHF1ZXVlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVicmljX2luc3RydWN0aW9uczogcnVicmljSW5zdHJ1Y3Rpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhib2R5KS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKSkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogc2VyaWFsaXplZEJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgQW5ub3RhdGlvblF1ZXVlV2l0aERldGFpbHMgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgcmVhZEFubm90YXRpb25RdWV1ZShxdWV1ZUlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInJlYWQgYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdXBkYXRpbmcgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5ldyBuYW1lIGZvciB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIG5ldyBkZXNjcmlwdGlvbiBmb3IgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVBbm5vdGF0aW9uUXVldWUocXVldWVJZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBydWJyaWNJbnN0cnVjdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBydWJyaWNfaW5zdHJ1Y3Rpb25zOiBydWJyaWNJbnN0cnVjdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGFubm90YXRpb24gcXVldWVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIGRlbGV0ZVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUFubm90YXRpb25RdWV1ZShxdWV1ZUlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZGVsZXRlIGFubm90YXRpb24gcXVldWVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJ1bnMgdG8gYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gcnVuSWRzIC0gVGhlIElEcyBvZiB0aGUgcnVucyB0byBiZSBhZGRlZCB0byB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJ1bnNUb0Fubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBydW5JZHMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHJ1bklkcy5tYXAoKGlkLCBpKSA9PiBhc3NlcnRVdWlkKGlkLCBgcnVuSWRzWyR7aX1dYCkudG9TdHJpbmcoKSkpO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5zYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImFkZCBydW5zIHRvIGFubm90YXRpb24gcXVldWVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcnVuIGZyb20gYW4gYW5ub3RhdGlvbiBxdWV1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBydW4gdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFJ1bldpdGhBbm5vdGF0aW9uUXVldWVJbmZvIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcnVuIGlzIG5vdCBmb3VuZCBhdCB0aGUgZ2l2ZW4gaW5kZXggb3IgZm9yIG90aGVyIEFQSS1yZWxhdGVkIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFJ1bkZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGAvYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVuYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfSR7YmFzZVVybH0vJHtpbmRleH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1biBmcm9tIGFuIGFuIGFubm90YXRpb24gcXVldWUuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlIHRoZSBydW4gZnJvbVxuICAgICAqIEBwYXJhbSBxdWV1ZVJ1bklkIC0gVGhlIElEIG9mIHRoZSBydW4gdG8gZGVsZXRlIGZyb20gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIHF1ZXVlUnVuSWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVucy8ke2Fzc2VydFV1aWQocXVldWVSdW5JZCwgXCJxdWV1ZVJ1bklkXCIpfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImRlbGV0ZSBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2l6ZSBvZiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2l6ZUZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3NpemVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBzaXplIGZyb20gYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfY3VycmVudFRlbmFudElzT3duZXIob3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gb3duZXIgPT0gXCItXCIgfHwgc2V0dGluZ3MudGVuYW50X2hhbmRsZSA9PT0gb3duZXI7XG4gICAgfVxuICAgIGFzeW5jIF9vd25lckNvbmZsaWN0RXJyb3IoYWN0aW9uLCBvd25lcikge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYENhbm5vdCAke2FjdGlvbn0gZm9yIGFub3RoZXIgdGVuYW50LlxcblxuICAgICAgQ3VycmVudCB0ZW5hbnQ6ICR7c2V0dGluZ3MudGVuYW50X2hhbmRsZX1cXG5cbiAgICAgIFJlcXVlc3RlZCB0ZW5hbnQ6ICR7b3duZXJ9YCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRMYXRlc3RDb21taXRIYXNoKHByb21wdE93bmVyQW5kTmFtZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9Lz9saW1pdD0kezF9Jm9mZnNldD0kezB9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgbGF0ZXN0IGNvbW1pdCBoYXNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChqc29uLmNvbW1pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uLmNvbW1pdHNbMF0uY29tbWl0X2hhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgbGlrZSkge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoeyBsaWtlOiBsaWtlIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2xpa2VzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGAke2xpa2UgPyBcImxpa2VcIiA6IFwidW5saWtlXCJ9IHByb21wdGApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNoLnN1YnN0cmluZygwLCA4KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9odWIvJHtvd25lcn0vJHtwcm9tcHROYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBhd2FpdCB0aGlzLmdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuICEhcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBsaWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgdW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0Q29tbWl0cyhwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjb21taXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChgL2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9L2AsIG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgKHJlcykgPT4gcmVzLmNvbW1pdHMpKSB7XG4gICAgICAgICAgICB5aWVsZCogY29tbWl0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb21wdHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2ZpZWxkXCIsIG9wdGlvbnM/LnNvcnRGaWVsZCA/PyBcInVwZGF0ZWRfYXRcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2RpcmVjdGlvblwiLCBcImRlc2NcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19hcmNoaXZlZFwiLCAoISFvcHRpb25zPy5pc0FyY2hpdmVkKS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19wdWJsaWNcIiwgb3B0aW9ucy5pc1B1YmxpYy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb21wdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3JlcG9zXCIsIHBhcmFtcywgKHJlcykgPT4gcmVzLnJlcG9zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb21wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXM/LnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZ2V0IHByb21wdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZT8uanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0Py5yZXBvKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAmJiAhc2V0dGluZ3MudGVuYW50X2hhbmRsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGEgcHVibGljIHByb21wdCB3aXRob3V0IGZpcnN0XFxuXG4gICAgICAgIGNyZWF0aW5nIGEgTGFuZ0NoYWluIEh1YiBoYW5kbGUuXG4gICAgICAgIFlvdSBjYW4gYWRkIGEgaGFuZGxlIGJ5IGNyZWF0aW5nIGEgcHVibGljIHByb21wdCBhdDpcXG5cbiAgICAgICAgaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tL3Byb21wdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLl9vd25lckNvbmZsaWN0RXJyb3IoXCJjcmVhdGUgYSBwcm9tcHRcIiwgb3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZXBvX2hhbmRsZTogcHJvbXB0TmFtZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5kZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnJlYWRtZSAmJiB7IHJlYWRtZTogb3B0aW9ucy5yZWFkbWUgfSksXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8udGFncyAmJiB7IHRhZ3M6IG9wdGlvbnMudGFncyB9KSxcbiAgICAgICAgICAgIGlzX3B1YmxpYzogISFvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3JlcG9zL2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgcHJvbXB0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgcmVwbyB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVwbztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBkb2VzIG5vdCBleGlzdCwgeW91IG11c3QgY3JlYXRlIGl0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFBhcmVudENvbW1pdEhhc2ggPSBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoID09PSBcImxhdGVzdFwiIHx8ICFvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2dldExhdGVzdENvbW1pdEhhc2goYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gKVxuICAgICAgICAgICAgOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgbWFuaWZlc3Q6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSksXG4gICAgICAgICAgICBwYXJlbnRfY29tbWl0OiByZXNvbHZlZFBhcmVudENvbW1pdEhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIGNvbW1pdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9tcHRVcmwoYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX0ke3Jlc3VsdC5jb21taXRfaGFzaCA/IGA6JHtyZXN1bHQuY29tbWl0X2hhc2h9YCA6IFwiXCJ9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBleGFtcGxlcyB3aXRoIGF0dGFjaG1lbnRzIHVzaW5nIG11bHRpcGFydCBmb3JtIGRhdGEuXG4gICAgICogQHBhcmFtIHVwZGF0ZXMgTGlzdCBvZiBFeGFtcGxlVXBkYXRlV2l0aEF0dGFjaG1lbnRzIG9iamVjdHMgdG8gdXBzZXJ0XG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSB1cGRhdGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMgPSBbXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyA9IFtdKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2dldERhdGFzZXRFeGFtcGxlc011bHRpUGFydFN1cHBvcnQoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgTGFuZ1NtaXRoIGRlcGxveW1lbnQgZG9lcyBub3QgYWxsb3cgdXNpbmcgdGhlIG11bHRpcGFydCBleGFtcGxlcyBlbmRwb2ludCwgcGxlYXNlIHVwZ3JhZGUgeW91ciBkZXBsb3ltZW50IHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBleGFtcGxlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJZCA9IGV4YW1wbGUuaWQ7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIGV4YW1wbGUgYm9keVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJvZHkgPSB7XG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogZXhhbXBsZS5tZXRhZGF0YSB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zcGxpdCAmJiB7IHNwbGl0OiBleGFtcGxlLnNwbGl0IH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFkZCBtYWluIGV4YW1wbGUgZGF0YVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRFeGFtcGxlID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZUJvZHksIGBTZXJpYWxpemluZyBib2R5IGZvciBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRFeGFtcGxlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZXhhbXBsZUlkLCBleGFtcGxlQmxvYik7XG4gICAgICAgICAgICAvLyBBZGQgaW5wdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5wdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5pbnB1dHMsIGBTZXJpYWxpemluZyBpbnB1dHMgZm9yIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZElucHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uaW5wdXRzYCwgaW5wdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgb3V0cHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRPdXRwdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5vdXRwdXRzLCBgU2VyaWFsaXppbmcgb3V0cHV0cyB3aGxlIHVwZGF0aW5nIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRPdXRwdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5vdXRwdXRzYCwgb3V0cHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF0dGFjaG1lbnRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXhhbXBsZS5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW1lVHlwZSwgZGF0YV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50QmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7bWltZVR5cGV9OyBsZW5ndGg9JHtkYXRhLmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnQuJHtuYW1lfWAsIGF0dGFjaG1lbnRCbG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5hdHRhY2htZW50c19vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRBdHRhY2htZW50c09wZXJhdGlvbnMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmF0dGFjaG1lbnRzX29wZXJhdGlvbnMsIGBTZXJpYWxpemluZyBhdHRhY2htZW50cyB3aGlsZSB1cGRhdGluZyBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRBdHRhY2htZW50c09wZXJhdGlvbnNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnRzX29wZXJhdGlvbnNgLCBhdHRhY2htZW50c09wZXJhdGlvbnNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc2V0SWRUb1VzZSA9IGRhdGFzZXRJZCA/PyB1cGRhdGVzWzBdPy5kYXRhc2V0X2lkO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHt0aGlzLl9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aChgZGF0YXNldHMvJHtkYXRhc2V0SWRUb1VzZX0vZXhhbXBsZXNgKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGV4YW1wbGVzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCBleGFtcGxlcyB3aXRoIGF0dGFjaG1lbnRzIHVzaW5nIG11bHRpcGFydCBmb3JtIGRhdGEuXG4gICAgICogQHBhcmFtIHVwbG9hZHMgTGlzdCBvZiBFeGFtcGxlVXBsb2FkV2l0aEF0dGFjaG1lbnRzIG9iamVjdHMgdG8gdXBsb2FkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSB1cGxvYWQgcmVzcG9uc2VcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIExhbmdTbWl0aCB2ZXJzaW9ucywgcGxlYXNlIHVzZSBgY3JlYXRlRXhhbXBsZXNgIGluc3RlYWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMgPSBbXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2FkcyA9IFtdKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2dldERhdGFzZXRFeGFtcGxlc011bHRpUGFydFN1cHBvcnQoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgTGFuZ1NtaXRoIGRlcGxveW1lbnQgZG9lcyBub3QgYWxsb3cgdXNpbmcgdGhlIG11bHRpcGFydCBleGFtcGxlcyBlbmRwb2ludCwgcGxlYXNlIHVwZ3JhZGUgeW91ciBkZXBsb3ltZW50IHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBleGFtcGxlIG9mIHVwbG9hZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJZCA9IChleGFtcGxlLmlkID8/IHV1aWQudjQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gZXhhbXBsZSBib2R5XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQm9keSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBleGFtcGxlLmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogZXhhbXBsZS5tZXRhZGF0YSB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zcGxpdCAmJiB7IHNwbGl0OiBleGFtcGxlLnNwbGl0IH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNvdXJjZV9ydW5faWQgJiYgeyBzb3VyY2VfcnVuX2lkOiBleGFtcGxlLnNvdXJjZV9ydW5faWQgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUudXNlX3NvdXJjZV9ydW5faW8gJiYge1xuICAgICAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogZXhhbXBsZS51c2Vfc291cmNlX3J1bl9pbyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS51c2Vfc291cmNlX3J1bl9hdHRhY2htZW50cyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiBleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFkZCBtYWluIGV4YW1wbGUgZGF0YVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRFeGFtcGxlID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZUJvZHksIGBTZXJpYWxpemluZyBib2R5IGZvciB1cGxvYWRlZCBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRFeGFtcGxlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZXhhbXBsZUlkLCBleGFtcGxlQmxvYik7XG4gICAgICAgICAgICAvLyBBZGQgaW5wdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5wdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5pbnB1dHMsIGBTZXJpYWxpemluZyBpbnB1dHMgZm9yIHVwbG9hZGVkIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZElucHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uaW5wdXRzYCwgaW5wdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgb3V0cHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRPdXRwdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5vdXRwdXRzLCBgU2VyaWFsaXppbmcgb3V0cHV0cyBmb3IgdXBsb2FkZWQgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZE91dHB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9Lm91dHB1dHNgLCBvdXRwdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXR0YWNobWVudHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhleGFtcGxlLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW21pbWVUeXBlLCBkYXRhXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRCbG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHttaW1lVHlwZX07IGxlbmd0aD0ke2RhdGEuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudC4ke25hbWV9YCwgYXR0YWNobWVudEJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHt0aGlzLl9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aChgZGF0YXNldHMvJHtkYXRhc2V0SWR9L2V4YW1wbGVzYCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBsb2FkIGV4YW1wbGVzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZV0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcInVwZGF0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucz8ucmVhZG1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnJlYWRtZSA9IG9wdGlvbnMucmVhZG1lO1xuICAgICAgICBpZiAob3B0aW9ucz8udGFncyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC50YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfcHVibGljID0gb3B0aW9ucy5pc1B1YmxpYztcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzQXJjaGl2ZWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfYXJjaGl2ZWQgPSBvcHRpb25zLmlzQXJjaGl2ZWQ7XG4gICAgICAgIC8vIENoZWNrIGlmIHBheWxvYWQgaXMgZW1wdHlcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdXBkYXRlIG9wdGlvbnMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBwcm9tcHRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiZGVsZXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImRlbGV0ZSBwcm9tcHRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBjYWNoZSBrZXkgZm9yIGEgcHJvbXB0LlxuICAgICAqIEZvcm1hdDogXCJ7aWRlbnRpZmllcn1cIiBvciBcIntpZGVudGlmaWVyfTp3aXRoX21vZGVsXCJcbiAgICAgKi9cbiAgICBfZ2V0UHJvbXB0Q2FjaGVLZXkocHJvbXB0SWRlbnRpZmllciwgaW5jbHVkZU1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGluY2x1ZGVNb2RlbCA/IFwiOndpdGhfbW9kZWxcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtwcm9tcHRJZGVudGlmaWVyfSR7c3VmZml4fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgcHJvbXB0IGNvbW1pdCBkaXJlY3RseSBmcm9tIHRoZSBBUEkgKGJ5cGFzc2luZyBjYWNoZSkuXG4gICAgICovXG4gICAgYXN5bmMgX2ZldGNoUHJvbXB0RnJvbUFwaShwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgY29tbWl0SGFzaF0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaH0ke29wdGlvbnM/LmluY2x1ZGVNb2RlbCA/IFwiP2luY2x1ZGVfbW9kZWw9dHJ1ZVwiIDogXCJcIn1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInB1bGwgcHJvbXB0IGNvbW1pdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHByb21wdE5hbWUsXG4gICAgICAgICAgICBjb21taXRfaGFzaDogcmVzdWx0LmNvbW1pdF9oYXNoLFxuICAgICAgICAgICAgbWFuaWZlc3Q6IHJlc3VsdC5tYW5pZmVzdCxcbiAgICAgICAgICAgIGV4YW1wbGVzOiByZXN1bHQuZXhhbXBsZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCBpZiBub3Qgc2tpcHBlZFxuICAgICAgICBpZiAoIW9wdGlvbnM/LnNraXBDYWNoZSAmJiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLl9nZXRQcm9tcHRDYWNoZUtleShwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zPy5pbmNsdWRlTW9kZWwpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FjaGUgbWlzcyAtIGZldGNoIGZyb20gQVBJIGFuZCBjYWNoZSBpdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZmV0Y2hQcm9tcHRGcm9tQXBpKHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGNhY2hlS2V5LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBjYWNoZSBvciBza2lwIGNhY2hlIC0gZmV0Y2ggZGlyZWN0bHlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUHJvbXB0RnJvbUFwaShwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgYGltcG9ydCB7IHB1bGwgfSBmcm9tIFwibGFuZ2NoYWluL2h1YlwiYCBpbnN0ZWFkLlxuICAgICAqIFVzaW5nIHRoaXMgbWV0aG9kIGRpcmVjdGx5IHJldHVybnMgdGhlIEpTT04gc3RyaW5nIG9mIHRoZSBwcm9tcHQgcmF0aGVyIHRoYW4gYSBMYW5nQ2hhaW4gb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3B1bGxQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHRPYmplY3QgPSBhd2FpdCB0aGlzLnB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgaW5jbHVkZU1vZGVsOiBvcHRpb25zPy5pbmNsdWRlTW9kZWwsXG4gICAgICAgICAgICBza2lwQ2FjaGU6IG9wdGlvbnM/LnNraXBDYWNoZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IEpTT04uc3RyaW5naWZ5KHByb21wdE9iamVjdC5tYW5pZmVzdCk7XG4gICAgICAgIHJldHVybiBwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgdXBkYXRlIHByb21wdCBtZXRhZGF0YVxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLnNvbWUoKGtleSkgPT4ga2V5ICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnM/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgaXNQdWJsaWM6IG9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zPy50YWdzLFxuICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucz8ub2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbW1pdCB3aXRoIHRoZSBuZXcgbWFuaWZlc3RcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5jcmVhdGVDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucz8ub2JqZWN0LCB7XG4gICAgICAgICAgICBwYXJlbnRDb21taXRIYXNoOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgYSBwdWJsaWMgZGF0YXNldCB0byB5b3VyIG93biBsYW5nc21pdGggdGVuYW50LlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGlzIGlkZW1wb3RlbnQuIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWUsXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmcuXG4gIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk9yVXJsIFRoZSB0b2tlbiBvZiB0aGUgcHVibGljIGRhdGFzZXQgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGNsb25pbmcgdGhlIGRhdGFzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZUFwaVVybF0gVGhlIFVSTCBvZiB0aGUgbGFuZ3NtaXRoIHNlcnZlciB3aGVyZSB0aGUgZGF0YSBpcyBob3N0ZWQuIERlZmF1bHRzIHRvIHRoZSBBUEkgVVJMIG9mIHlvdXIgY3VycmVudCBjbGllbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRhdGFzZXROYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGUgaW4geW91ciB0ZW5hbnQuIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRoZSBwdWJsaWMgZGF0YXNldC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjbG9uZVB1YmxpY0RhdGFzZXQodG9rZW5PclVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlQXBpVXJsID0gdGhpcy5hcGlVcmwsIGRhdGFzZXROYW1lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBbcGFyc2VkQXBpVXJsLCB0b2tlblV1aWRdID0gdGhpcy5wYXJzZVRva2VuT3JVcmwodG9rZW5PclVybCwgc291cmNlQXBpVXJsKTtcbiAgICAgICAgY29uc3Qgc291cmNlQ2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAgICAgICAgICBhcGlVcmw6IHBhcnNlZEFwaVVybCxcbiAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyIEFQSSBrZXkgbm90IG5lZWRlZCBhbnltb3JlIGluIG1vc3QgY2FzZXMsIGJ1dFxuICAgICAgICAgICAgLy8gc29tZSBwcml2YXRlIGRlcGxveW1lbnRzIG1heSBoYXZlIEFQSSBrZXktYmFzZWQgcmF0ZSBsaW1pdGluZ1xuICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBjYXVzZSB0aGlzIHRvIGZhaWwgaWYgd2UgcHJvdmlkZSBubyB2YWx1ZS5cbiAgICAgICAgICAgIGFwaUtleTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZHMgPSBhd2FpdCBzb3VyY2VDbGllbnQucmVhZFNoYXJlZERhdGFzZXQodG9rZW5VdWlkKTtcbiAgICAgICAgY29uc3QgZmluYWxEYXRhc2V0TmFtZSA9IGRhdGFzZXROYW1lIHx8IGRzLm5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5oYXNEYXRhc2V0KHsgZGF0YXNldElkOiBmaW5hbERhdGFzZXROYW1lIH0pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfSBhbHJlYWR5IGV4aXN0cyBpbiB5b3VyIHRlbmFudC4gU2tpcHBpbmcuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBgLmhhc0RhdGFzZXRgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRhdGFzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICAvLyBuby1vcCBpbiB0aGF0IGNhc2VcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBleGFtcGxlcyBmaXJzdCwgdGhlbiBjcmVhdGUgdGhlIGRhdGFzZXRcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBzb3VyY2VDbGllbnQubGlzdFNoYXJlZEV4YW1wbGVzKHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLmNyZWF0ZURhdGFzZXQoZmluYWxEYXRhc2V0TmFtZSwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGRzLmRhdGFfdHlwZSB8fCBcImt2XCIsXG4gICAgICAgICAgICBpbnB1dHNTY2hlbWE6IGRzLmlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdXRwdXRzU2NoZW1hOiBkcy5vdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUV4YW1wbGVzKHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGV4YW1wbGVzLm1hcCgoZSkgPT4gZS5pbnB1dHMpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IGV4YW1wbGVzLmZsYXRNYXAoKGUpID0+IChlLm91dHB1dHMgPyBbZS5vdXRwdXRzXSA6IFtdKSksXG4gICAgICAgICAgICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNyZWF0aW5nIGRhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfS4gYCArXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIGRlbGV0ZSBpdCBtYW51YWxseS5cIik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlVG9rZW5PclVybCh1cmxPclRva2VuLCBhcGlVcmwsIG51bVBhcnRzID0gMiwga2luZCA9IFwiZGF0YXNldFwiKSB7XG4gICAgICAgIC8vIFRyeSBwYXJzaW5nIGFzIFVVSURcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQodXJsT3JUb2tlbik7IC8vIFdpbGwgdGhyb3cgaWYgaXQncyBub3QgYSBVVUlELlxuICAgICAgICAgICAgcmV0dXJuIFthcGlVcmwsIHVybE9yVG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBuby1vcCBpZiBpdCdzIG5vdCBhIHV1aWRcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBhcyBVUkxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsT3JUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBwYXJzZWRVcmwucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocGFydCkgPT4gcGFydCAhPT0gXCJcIik7XG4gICAgICAgICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA+PSBudW1QYXJ0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVXVpZCA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gbnVtUGFydHNdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB0b2tlblV1aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTDogJHt1cmxPclRva2VufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTCBvciB0b2tlbjogJHt1cmxPclRva2VufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUgaW5zdGFuY2UsIGlmIGNhY2hpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiBVc2VmdWwgZm9yIGFjY2Vzc2luZyBjYWNoZSBtZXRyaWNzIG9yIG1hbnVhbGx5IG1hbmFnaW5nIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBnZXQgY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCByZXNvdXJjZXMgaGVsZCBieSB0aGUgY2xpZW50LlxuICAgICAqIFN0b3BzIHRoZSBjYWNoZSdzIGJhY2tncm91bmQgcmVmcmVzaCB0aW1lci5cbiAgICAgKi9cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBd2FpdHMgYWxsIHBlbmRpbmcgdHJhY2UgYmF0Y2hlcy4gVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgd2hlcmVcbiAgICAgKiB5b3UgbmVlZCB0byBiZSBzdXJlIHRoYXQgYWxsIHRyYWNpbmcgcmVxdWVzdHMgZmluaXNoIGJlZm9yZSBleGVjdXRpb24gZW5kcyxcbiAgICAgKiBzdWNoIGFzIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgLy8gVHJhY2luZyBoYXBwZW5zIGhlcmVcbiAgICAgKiAgIC4uLlxuICAgICAqIH0gZmluYWxseSB7XG4gICAgICogICBhd2FpdCBjbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgY3VycmVudGx5IHBlbmRpbmcgdHJhY2VzIGhhdmUgc2VudC5cbiAgICAgKi9cbiAgICBhc3luYyBhd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddOiBXaGVuIHRyYWNpbmcgaW4gbWFudWFsIGZsdXNoIG1vZGUsIHlvdSBtdXN0IGNhbGwgYGF3YWl0IGNsaWVudC5mbHVzaCgpYCBtYW51YWxseSB0byBzdWJtaXQgdHJhY2UgYmF0Y2hlcy5cIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyYWNlYWJsZXMgdXNlIGEgYmFja2dyb3VuZGVkIHByb21pc2UgYmVmb3JlIHVwZGF0aW5nIHJ1bnMgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgICogYW5kIHRvIGFsbG93IHdhaXRpbmcgZm9yIGNoaWxkIHJ1bnMgdG8gZW5kLiBXYWl0aW5nIGEgc21hbGwgYW1vdW50IG9mIHRpbWVcbiAgICAgICAgICogaGVyZSBlbnN1cmVzIHRoYXQgdGhleSBhcmUgYWJsZSB0byBlbnF1ZXVlIHRoZWlyIHJ1biBvcGVyYXRpb24gYmVmb3JlIHdlIGF3YWl0XG4gICAgICAgICAqIHF1ZXVlZCBydW4gb3BlcmF0aW9ucyBiZWxvdzpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcnVuID0gYXdhaXQgdHJhY2VhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICogICByZXR1cm4gXCJIZWxsbywgd29ybGQhXCI7XG4gICAgICAgICAqIH0sIHsgY2xpZW50IH0pKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGF3YWl0IGNsaWVudC5hd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubWFwKCh7IGl0ZW1Qcm9taXNlIH0pID0+IGl0ZW1Qcm9taXNlKSxcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIucXVldWUub25JZGxlKCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpPy5ERUZBVUxUX0xBTkdTTUlUSF9TUEFOX1BST0NFU1NPUj8uZm9yY2VGbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFeGFtcGxlQ3JlYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIFwiZGF0YXNldF9pZFwiIGluIGlucHV0IHx8IFwiZGF0YXNldF9uYW1lXCIgaW4gaW5wdXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/env.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/env.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\"TRACING_V2\", \"TRACING\"];\n    return !!envVars.find((envVar) => (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEVBQStCO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzP2JkMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuZXhwb3J0IGNvbnN0IGlzVHJhY2luZ0VuYWJsZWQgPSAodHJhY2luZ0VuYWJsZWQpID0+IHtcbiAgICBpZiAodHJhY2luZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0VuYWJsZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVudlZhcnMgPSBbXCJUUkFDSU5HX1YyXCIsIFwiVFJBQ0lOR1wiXTtcbiAgICByZXR1cm4gISFlbnZWYXJzLmZpbmQoKGVudlZhcikgPT4gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShlbnZWYXIpID09PSBcInRydWVcIik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/constants.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/constants.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_SDK_LLM_OPERATIONS: () => (/* binding */ AI_SDK_LLM_OPERATIONS),\n/* harmony export */   AI_SDK_TOOL_OPERATIONS: () => (/* binding */ AI_SDK_TOOL_OPERATIONS),\n/* harmony export */   GENAI_COMPLETION: () => (/* binding */ GENAI_COMPLETION),\n/* harmony export */   GENAI_PROMPT: () => (/* binding */ GENAI_PROMPT),\n/* harmony export */   GEN_AI_ASSISTANT_MESSAGE: () => (/* binding */ GEN_AI_ASSISTANT_MESSAGE),\n/* harmony export */   GEN_AI_CHOICE: () => (/* binding */ GEN_AI_CHOICE),\n/* harmony export */   GEN_AI_OPERATION_NAME: () => (/* binding */ GEN_AI_OPERATION_NAME),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_BODY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_BODY),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_QUERY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_QUERY),\n/* harmony export */   GEN_AI_REQUEST_FREQUENCY_PENALTY: () => (/* binding */ GEN_AI_REQUEST_FREQUENCY_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_MAX_TOKENS: () => (/* binding */ GEN_AI_REQUEST_MAX_TOKENS),\n/* harmony export */   GEN_AI_REQUEST_MODEL: () => (/* binding */ GEN_AI_REQUEST_MODEL),\n/* harmony export */   GEN_AI_REQUEST_PRESENCE_PENALTY: () => (/* binding */ GEN_AI_REQUEST_PRESENCE_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_TEMPERATURE: () => (/* binding */ GEN_AI_REQUEST_TEMPERATURE),\n/* harmony export */   GEN_AI_REQUEST_TOP_P: () => (/* binding */ GEN_AI_REQUEST_TOP_P),\n/* harmony export */   GEN_AI_RESPONSE_FINISH_REASONS: () => (/* binding */ GEN_AI_RESPONSE_FINISH_REASONS),\n/* harmony export */   GEN_AI_RESPONSE_ID: () => (/* binding */ GEN_AI_RESPONSE_ID),\n/* harmony export */   GEN_AI_RESPONSE_MODEL: () => (/* binding */ GEN_AI_RESPONSE_MODEL),\n/* harmony export */   GEN_AI_RESPONSE_SERVICE_TIER: () => (/* binding */ GEN_AI_RESPONSE_SERVICE_TIER),\n/* harmony export */   GEN_AI_RESPONSE_SYSTEM_FINGERPRINT: () => (/* binding */ GEN_AI_RESPONSE_SYSTEM_FINGERPRINT),\n/* harmony export */   GEN_AI_SERIALIZED_DOC: () => (/* binding */ GEN_AI_SERIALIZED_DOC),\n/* harmony export */   GEN_AI_SERIALIZED_NAME: () => (/* binding */ GEN_AI_SERIALIZED_NAME),\n/* harmony export */   GEN_AI_SERIALIZED_SIGNATURE: () => (/* binding */ GEN_AI_SERIALIZED_SIGNATURE),\n/* harmony export */   GEN_AI_SYSTEM: () => (/* binding */ GEN_AI_SYSTEM),\n/* harmony export */   GEN_AI_SYSTEM_MESSAGE: () => (/* binding */ GEN_AI_SYSTEM_MESSAGE),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_TOTAL_TOKENS: () => (/* binding */ GEN_AI_USAGE_TOTAL_TOKENS),\n/* harmony export */   GEN_AI_USER_MESSAGE: () => (/* binding */ GEN_AI_USER_MESSAGE),\n/* harmony export */   LANGSMITH_DOTTED_ORDER: () => (/* binding */ LANGSMITH_DOTTED_ORDER),\n/* harmony export */   LANGSMITH_IS_ROOT: () => (/* binding */ LANGSMITH_IS_ROOT),\n/* harmony export */   LANGSMITH_METADATA: () => (/* binding */ LANGSMITH_METADATA),\n/* harmony export */   LANGSMITH_NAME: () => (/* binding */ LANGSMITH_NAME),\n/* harmony export */   LANGSMITH_PARENT_RUN_ID: () => (/* binding */ LANGSMITH_PARENT_RUN_ID),\n/* harmony export */   LANGSMITH_REFERENCE_EXAMPLE_ID: () => (/* binding */ LANGSMITH_REFERENCE_EXAMPLE_ID),\n/* harmony export */   LANGSMITH_REQUEST_HEADERS: () => (/* binding */ LANGSMITH_REQUEST_HEADERS),\n/* harmony export */   LANGSMITH_REQUEST_STREAMING: () => (/* binding */ LANGSMITH_REQUEST_STREAMING),\n/* harmony export */   LANGSMITH_RUNTIME: () => (/* binding */ LANGSMITH_RUNTIME),\n/* harmony export */   LANGSMITH_RUN_ID: () => (/* binding */ LANGSMITH_RUN_ID),\n/* harmony export */   LANGSMITH_RUN_TYPE: () => (/* binding */ LANGSMITH_RUN_TYPE),\n/* harmony export */   LANGSMITH_SESSION_ID: () => (/* binding */ LANGSMITH_SESSION_ID),\n/* harmony export */   LANGSMITH_SESSION_NAME: () => (/* binding */ LANGSMITH_SESSION_NAME),\n/* harmony export */   LANGSMITH_TAGS: () => (/* binding */ LANGSMITH_TAGS),\n/* harmony export */   LANGSMITH_TRACEABLE: () => (/* binding */ LANGSMITH_TRACEABLE),\n/* harmony export */   LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID: () => (/* binding */ LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID),\n/* harmony export */   LANGSMITH_TRACE_ID: () => (/* binding */ LANGSMITH_TRACE_ID),\n/* harmony export */   LANGSMITH_USAGE_METADATA: () => (/* binding */ LANGSMITH_USAGE_METADATA)\n/* harmony export */ });\n// OpenTelemetry GenAI semantic convention attribute names\nconst GEN_AI_OPERATION_NAME = \"gen_ai.operation.name\";\nconst GEN_AI_SYSTEM = \"gen_ai.system\";\nconst GEN_AI_REQUEST_MODEL = \"gen_ai.request.model\";\nconst GEN_AI_RESPONSE_MODEL = \"gen_ai.response.model\";\nconst GEN_AI_USAGE_INPUT_TOKENS = \"gen_ai.usage.input_tokens\";\nconst GEN_AI_USAGE_OUTPUT_TOKENS = \"gen_ai.usage.output_tokens\";\nconst GEN_AI_USAGE_TOTAL_TOKENS = \"gen_ai.usage.total_tokens\";\nconst GEN_AI_REQUEST_MAX_TOKENS = \"gen_ai.request.max_tokens\";\nconst GEN_AI_REQUEST_TEMPERATURE = \"gen_ai.request.temperature\";\nconst GEN_AI_REQUEST_TOP_P = \"gen_ai.request.top_p\";\nconst GEN_AI_REQUEST_FREQUENCY_PENALTY = \"gen_ai.request.frequency_penalty\";\nconst GEN_AI_REQUEST_PRESENCE_PENALTY = \"gen_ai.request.presence_penalty\";\nconst GEN_AI_RESPONSE_FINISH_REASONS = \"gen_ai.response.finish_reasons\";\nconst GENAI_PROMPT = \"gen_ai.prompt\";\nconst GENAI_COMPLETION = \"gen_ai.completion\";\nconst GEN_AI_REQUEST_EXTRA_QUERY = \"gen_ai.request.extra_query\";\nconst GEN_AI_REQUEST_EXTRA_BODY = \"gen_ai.request.extra_body\";\nconst GEN_AI_SERIALIZED_NAME = \"gen_ai.serialized.name\";\nconst GEN_AI_SERIALIZED_SIGNATURE = \"gen_ai.serialized.signature\";\nconst GEN_AI_SERIALIZED_DOC = \"gen_ai.serialized.doc\";\nconst GEN_AI_RESPONSE_ID = \"gen_ai.response.id\";\nconst GEN_AI_RESPONSE_SERVICE_TIER = \"gen_ai.response.service_tier\";\nconst GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = \"gen_ai.response.system_fingerprint\";\nconst GEN_AI_USAGE_INPUT_TOKEN_DETAILS = \"gen_ai.usage.input_token_details\";\nconst GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = \"gen_ai.usage.output_token_details\";\n// LangSmith custom attributes\nconst LANGSMITH_SESSION_ID = \"langsmith.trace.session_id\";\nconst LANGSMITH_SESSION_NAME = \"langsmith.trace.session_name\";\nconst LANGSMITH_RUN_TYPE = \"langsmith.span.kind\";\nconst LANGSMITH_NAME = \"langsmith.trace.name\";\nconst LANGSMITH_METADATA = \"langsmith.metadata\";\nconst LANGSMITH_TAGS = \"langsmith.span.tags\";\nconst LANGSMITH_RUNTIME = \"langsmith.span.runtime\";\nconst LANGSMITH_REQUEST_STREAMING = \"langsmith.request.streaming\";\nconst LANGSMITH_REQUEST_HEADERS = \"langsmith.request.headers\";\nconst LANGSMITH_RUN_ID = \"langsmith.span.id\";\nconst LANGSMITH_TRACE_ID = \"langsmith.trace.id\";\nconst LANGSMITH_DOTTED_ORDER = \"langsmith.span.dotted_order\";\nconst LANGSMITH_PARENT_RUN_ID = \"langsmith.span.parent_id\";\nconst LANGSMITH_USAGE_METADATA = \"langsmith.usage_metadata\";\nconst LANGSMITH_REFERENCE_EXAMPLE_ID = \"langsmith.reference_example_id\";\nconst LANGSMITH_TRACEABLE = \"langsmith.traceable\";\nconst LANGSMITH_IS_ROOT = \"langsmith.is_root\";\nconst LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = \"langsmith.traceable_parent_otel_span_id\";\n// GenAI event names\nconst GEN_AI_SYSTEM_MESSAGE = \"gen_ai.system.message\";\nconst GEN_AI_USER_MESSAGE = \"gen_ai.user.message\";\nconst GEN_AI_ASSISTANT_MESSAGE = \"gen_ai.assistant.message\";\nconst GEN_AI_CHOICE = \"gen_ai.choice\";\nconst AI_SDK_LLM_OPERATIONS = [\n    \"ai.generateText.doGenerate\",\n    \"ai.streamText.doStream\",\n    \"ai.generateObject.doGenerate\",\n    \"ai.streamObject.doStream\",\n];\nconst AI_SDK_TOOL_OPERATIONS = [\"ai.toolCall\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC9jb25zdGFudHMuanM/ZjZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcGVuVGVsZW1ldHJ5IEdlbkFJIHNlbWFudGljIGNvbnZlbnRpb24gYXR0cmlidXRlIG5hbWVzXG5leHBvcnQgY29uc3QgR0VOX0FJX09QRVJBVElPTl9OQU1FID0gXCJnZW5fYWkub3BlcmF0aW9uLm5hbWVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNID0gXCJnZW5fYWkuc3lzdGVtXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfTU9ERUwgPSBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX01PREVMID0gXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TID0gXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUyA9IFwiZ2VuX2FpLnVzYWdlLnRvdGFsX3Rva2Vuc1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX01BWF9UT0tFTlMgPSBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRSA9IFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9UT1BfUCA9IFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSA9IFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZID0gXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TID0gXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9QUk9NUFQgPSBcImdlbl9haS5wcm9tcHRcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9DT01QTEVUSU9OID0gXCJnZW5fYWkuY29tcGxldGlvblwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZID0gXCJnZW5fYWkucmVxdWVzdC5leHRyYV9xdWVyeVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFkgPSBcImdlbl9haS5yZXF1ZXN0LmV4dHJhX2JvZHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9OQU1FID0gXCJnZW5fYWkuc2VyaWFsaXplZC5uYW1lXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NFUklBTElaRURfU0lHTkFUVVJFID0gXCJnZW5fYWkuc2VyaWFsaXplZC5zaWduYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9ET0MgPSBcImdlbl9haS5zZXJpYWxpemVkLmRvY1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9JRCA9IFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX1NFUlZJQ0VfVElFUiA9IFwiZ2VuX2FpLnJlc3BvbnNlLnNlcnZpY2VfdGllclwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9TWVNURU1fRklOR0VSUFJJTlQgPSBcImdlbl9haS5yZXNwb25zZS5zeXN0ZW1fZmluZ2VycHJpbnRcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUyA9IFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2VuX2RldGFpbHNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5fZGV0YWlsc1wiO1xuLy8gTGFuZ1NtaXRoIGN1c3RvbSBhdHRyaWJ1dGVzXG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fSUQgPSBcImxhbmdzbWl0aC50cmFjZS5zZXNzaW9uX2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fTkFNRSA9IFwibGFuZ3NtaXRoLnRyYWNlLnNlc3Npb25fbmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fVFlQRSA9IFwibGFuZ3NtaXRoLnNwYW4ua2luZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9OQU1FID0gXCJsYW5nc21pdGgudHJhY2UubmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9NRVRBREFUQSA9IFwibGFuZ3NtaXRoLm1ldGFkYXRhXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RBR1MgPSBcImxhbmdzbWl0aC5zcGFuLnRhZ3NcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUlVOVElNRSA9IFwibGFuZ3NtaXRoLnNwYW4ucnVudGltZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SRVFVRVNUX1NUUkVBTUlORyA9IFwibGFuZ3NtaXRoLnJlcXVlc3Quc3RyZWFtaW5nXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUyA9IFwibGFuZ3NtaXRoLnJlcXVlc3QuaGVhZGVyc1wiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fSUQgPSBcImxhbmdzbWl0aC5zcGFuLmlkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RSQUNFX0lEID0gXCJsYW5nc21pdGgudHJhY2UuaWRcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfRE9UVEVEX09SREVSID0gXCJsYW5nc21pdGguc3Bhbi5kb3R0ZWRfb3JkZXJcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUEFSRU5UX1JVTl9JRCA9IFwibGFuZ3NtaXRoLnNwYW4ucGFyZW50X2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1VTQUdFX01FVEFEQVRBID0gXCJsYW5nc21pdGgudXNhZ2VfbWV0YWRhdGFcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUkVGRVJFTkNFX0VYQU1QTEVfSUQgPSBcImxhbmdzbWl0aC5yZWZlcmVuY2VfZXhhbXBsZV9pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9UUkFDRUFCTEUgPSBcImxhbmdzbWl0aC50cmFjZWFibGVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfSVNfUk9PVCA9IFwibGFuZ3NtaXRoLmlzX3Jvb3RcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfVFJBQ0VBQkxFX1BBUkVOVF9PVEVMX1NQQU5fSUQgPSBcImxhbmdzbWl0aC50cmFjZWFibGVfcGFyZW50X290ZWxfc3Bhbl9pZFwiO1xuLy8gR2VuQUkgZXZlbnQgbmFtZXNcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNX01FU1NBR0UgPSBcImdlbl9haS5zeXN0ZW0ubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9VU0VSX01FU1NBR0UgPSBcImdlbl9haS51c2VyLm1lc3NhZ2VcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfQVNTSVNUQU5UX01FU1NBR0UgPSBcImdlbl9haS5hc3Npc3RhbnQubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9DSE9JQ0UgPSBcImdlbl9haS5jaG9pY2VcIjtcbmV4cG9ydCBjb25zdCBBSV9TREtfTExNX09QRVJBVElPTlMgPSBbXG4gICAgXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgIFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG5dO1xuZXhwb3J0IGNvbnN0IEFJX1NES19UT09MX09QRVJBVElPTlMgPSBbXCJhaS50b29sQ2FsbFwiXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/translator.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/translator.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithToOTELTranslator: () => (/* binding */ LangSmithToOTELTranslator)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/constants.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../singletons/otel.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/otel.js\");\n\n\nconst WELL_KNOWN_OPERATION_NAMES = {\n    llm: \"chat\",\n    tool: \"execute_tool\",\n    retriever: \"embeddings\",\n    embedding: \"embeddings\",\n    prompt: \"chat\",\n};\nfunction getOperationName(runType) {\n    return WELL_KNOWN_OPERATION_NAMES[runType] || runType;\n}\nclass LangSmithToOTELTranslator {\n    constructor() {\n        Object.defineProperty(this, \"spans\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    exportBatch(operations, otelContextMap) {\n        for (const op of operations) {\n            try {\n                if (!op.run) {\n                    continue;\n                }\n                if (op.operation === \"post\") {\n                    const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));\n                    if (span && !op.run.end_time) {\n                        this.spans.set(op.id, span);\n                    }\n                }\n                else {\n                    this.updateSpanForRun(op, op.run);\n                }\n            }\n            catch (e) {\n                console.error(`Error processing operation ${op.id}:`, e);\n            }\n        }\n    }\n    createSpanForRun(op, runInfo, otelContext) {\n        const activeSpan = otelContext && (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)().getSpan(otelContext);\n        if (!activeSpan) {\n            return;\n        }\n        try {\n            return this.finishSpanSetup(activeSpan, runInfo, op);\n        }\n        catch (e) {\n            console.error(`Failed to create span for run ${op.id}:`, e);\n            return undefined;\n        }\n    }\n    finishSpanSetup(span, runInfo, op) {\n        // Set all attributes\n        this.setSpanAttributes(span, runInfo, op);\n        // Set status based on error\n        if (runInfo.error) {\n            span.setStatus({ code: 2 }); // ERROR status\n            span.recordException(new Error(runInfo.error));\n        }\n        else {\n            span.setStatus({ code: 1 }); // OK status\n        }\n        // End the span if end_time is present\n        if (runInfo.end_time) {\n            span.end(new Date(runInfo.end_time));\n        }\n        return span;\n    }\n    updateSpanForRun(op, runInfo) {\n        try {\n            const span = this.spans.get(op.id);\n            if (!span) {\n                console.debug(`No span found for run ${op.id} during update`);\n                return;\n            }\n            // Update attributes\n            this.setSpanAttributes(span, runInfo, op);\n            // Update status based on error\n            if (runInfo.error) {\n                span.setStatus({ code: 2 }); // ERROR status\n                span.recordException(new Error(runInfo.error));\n            }\n            else {\n                span.setStatus({ code: 1 }); // OK status\n            }\n            // End the span if end_time is present\n            const endTime = runInfo.end_time;\n            if (endTime) {\n                span.end(new Date(endTime));\n                this.spans.delete(op.id);\n            }\n        }\n        catch (e) {\n            console.error(`Failed to update span for run ${op.id}:`, e);\n        }\n    }\n    extractModelName(runInfo) {\n        // Try to get model name from metadata\n        if (runInfo.extra?.metadata) {\n            const metadata = runInfo.extra.metadata;\n            // First check for ls_model_name in metadata\n            if (metadata.ls_model_name) {\n                return metadata.ls_model_name;\n            }\n            // Then check invocation_params for model info\n            if (metadata.invocation_params) {\n                const invocationParams = metadata.invocation_params;\n                if (invocationParams.model) {\n                    return invocationParams.model;\n                }\n                else if (invocationParams.model_name) {\n                    return invocationParams.model_name;\n                }\n            }\n        }\n        return;\n    }\n    setSpanAttributes(span, runInfo, op) {\n        if (\"run_type\" in runInfo && runInfo.run_type) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_RUN_TYPE, runInfo.run_type);\n            // Set GenAI attributes according to OTEL semantic conventions\n            const operationName = getOperationName(runInfo.run_type || \"chain\");\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_OPERATION_NAME, operationName);\n        }\n        if (\"name\" in runInfo && runInfo.name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_NAME, runInfo.name);\n        }\n        if (\"session_id\" in runInfo && runInfo.session_id) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_ID, runInfo.session_id);\n        }\n        if (\"session_name\" in runInfo && runInfo.session_name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_NAME, runInfo.session_name);\n        }\n        // Set gen_ai.system\n        this.setGenAiSystem(span, runInfo);\n        // Set model name if available\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, modelName);\n        }\n        // Set token usage information\n        if (\"prompt_tokens\" in runInfo &&\n            typeof runInfo.prompt_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);\n        }\n        if (\"completion_tokens\" in runInfo &&\n            typeof runInfo.completion_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);\n        }\n        if (\"total_tokens\" in runInfo && typeof runInfo.total_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);\n        }\n        // Set other parameters from invocation_params\n        this.setInvocationParameters(span, runInfo);\n        // Set metadata and tags if available\n        const metadata = runInfo.extra?.metadata || {};\n        for (const [key, value] of Object.entries(metadata)) {\n            if (value !== null && value !== undefined) {\n                span.setAttribute(`${_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_METADATA}.${key}`, String(value));\n            }\n        }\n        const tags = runInfo.tags;\n        if (tags && Array.isArray(tags)) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, tags.join(\", \"));\n        }\n        else if (tags) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, String(tags));\n        }\n        // Support additional serialized attributes, if present\n        if (\"serialized\" in runInfo && typeof runInfo.serialized === \"object\") {\n            const serialized = runInfo.serialized;\n            if (serialized.name) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_NAME, String(serialized.name));\n            }\n            if (serialized.signature) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));\n            }\n            if (serialized.doc) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_DOC, String(serialized.doc));\n            }\n        }\n        // Set inputs/outputs if available\n        this.setIOAttributes(span, op);\n    }\n    setGenAiSystem(span, runInfo) {\n        // Default to \"langchain\" if we can't determine the system\n        let system = \"langchain\";\n        // Extract model name to determine the system\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            const modelLower = modelName.toLowerCase();\n            if (modelLower.includes(\"anthropic\") || modelLower.startsWith(\"claude\")) {\n                system = \"anthropic\";\n            }\n            else if (modelLower.includes(\"bedrock\")) {\n                system = \"aws.bedrock\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"openai\")) {\n                system = \"az.ai.openai\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"inference\")) {\n                system = \"az.ai.inference\";\n            }\n            else if (modelLower.includes(\"cohere\")) {\n                system = \"cohere\";\n            }\n            else if (modelLower.includes(\"deepseek\")) {\n                system = \"deepseek\";\n            }\n            else if (modelLower.includes(\"gemini\")) {\n                system = \"gemini\";\n            }\n            else if (modelLower.includes(\"groq\")) {\n                system = \"groq\";\n            }\n            else if (modelLower.includes(\"watson\") || modelLower.includes(\"ibm\")) {\n                system = \"ibm.watsonx.ai\";\n            }\n            else if (modelLower.includes(\"mistral\")) {\n                system = \"mistral_ai\";\n            }\n            else if (modelLower.includes(\"gpt\") || modelLower.includes(\"openai\")) {\n                system = \"openai\";\n            }\n            else if (modelLower.includes(\"perplexity\") ||\n                modelLower.includes(\"sonar\")) {\n                system = \"perplexity\";\n            }\n            else if (modelLower.includes(\"vertex\")) {\n                system = \"vertex_ai\";\n            }\n            else if (modelLower.includes(\"xai\") || modelLower.includes(\"grok\")) {\n                system = \"xai\";\n            }\n        }\n        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SYSTEM, system);\n    }\n    setInvocationParameters(span, runInfo) {\n        if (!runInfo.extra?.metadata?.invocation_params) {\n            return;\n        }\n        const invocationParams = runInfo.extra.metadata.invocation_params;\n        // Set relevant invocation parameters\n        if (invocationParams.max_tokens !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);\n        }\n        if (invocationParams.temperature !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);\n        }\n        if (invocationParams.top_p !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);\n        }\n        if (invocationParams.frequency_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);\n        }\n        if (invocationParams.presence_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);\n        }\n    }\n    setIOAttributes(span, op) {\n        if (op.run.inputs) {\n            try {\n                const inputs = op.run.inputs;\n                if (typeof inputs === \"object\" && inputs !== null) {\n                    if (inputs.model && Array.isArray(inputs.messages)) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, inputs.model);\n                    }\n                    // Set additional request attributes if available\n                    if (inputs.stream !== undefined) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_STREAMING, inputs.stream);\n                    }\n                    if (inputs.extra_headers) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));\n                    }\n                    if (inputs.extra_query) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));\n                    }\n                    if (inputs.extra_body) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_PROMPT, JSON.stringify(inputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process inputs for run ${op.id}`, e);\n            }\n        }\n        if (op.run.outputs) {\n            try {\n                const outputs = op.run.outputs;\n                // Extract token usage from outputs (for LLM runs)\n                const tokenUsage = this.getUnifiedRunTokens(outputs);\n                if (tokenUsage) {\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);\n                }\n                if (outputs && typeof outputs === \"object\") {\n                    if (outputs.model) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_MODEL, String(outputs.model));\n                    }\n                    // Extract additional response attributes\n                    if (outputs.id) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_ID, outputs.id);\n                    }\n                    if (outputs.choices && Array.isArray(outputs.choices)) {\n                        const finishReasons = outputs.choices\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .map((choice) => choice.finish_reason)\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .filter((reason) => reason)\n                            .map(String);\n                        if (finishReasons.length > 0) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(\", \"));\n                        }\n                    }\n                    if (outputs.service_tier) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);\n                    }\n                    if (outputs.system_fingerprint) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);\n                    }\n                    if (outputs.usage_metadata &&\n                        typeof outputs.usage_metadata === \"object\") {\n                        const usageMetadata = outputs.usage_metadata;\n                        if (usageMetadata.input_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));\n                        }\n                        if (usageMetadata.output_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));\n                        }\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_COMPLETION, JSON.stringify(outputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process outputs for run ${op.id}`, e);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getUnifiedRunTokens(outputs) {\n        if (!outputs) {\n            return null;\n        }\n        // Search in non-generations lists\n        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);\n        if (tokenUsage) {\n            return tokenUsage;\n        }\n        // Find if direct kwarg in outputs\n        const keys = Object.keys(outputs);\n        for (const key of keys) {\n            const haystack = outputs[key];\n            if (!haystack || typeof haystack !== \"object\") {\n                continue;\n            }\n            tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);\n            if (tokenUsage) {\n                return tokenUsage;\n            }\n            if (haystack.lc === 1 &&\n                haystack.kwargs &&\n                typeof haystack.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        // Find in generations\n        const generations = outputs.generations || [];\n        if (!Array.isArray(generations)) {\n            return null;\n        }\n        const flatGenerations = Array.isArray(generations[0])\n            ? generations.flat()\n            : generations;\n        for (const generation of flatGenerations) {\n            if (typeof generation === \"object\" &&\n                generation.message &&\n                typeof generation.message === \"object\" &&\n                generation.message.kwargs &&\n                typeof generation.message.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extractUnifiedRunTokens(outputs) {\n        if (!outputs || typeof outputs !== \"object\") {\n            return null;\n        }\n        if (typeof outputs.input_tokens !== \"number\" ||\n            typeof outputs.output_tokens !== \"number\") {\n            return null;\n        }\n        return [outputs.input_tokens, outputs.output_tokens];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlFQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcz80MmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGdldE9URUxUcmFjZSB9IGZyb20gXCIuLi8uLi9zaW5nbGV0b25zL290ZWwuanNcIjtcbmNvbnN0IFdFTExfS05PV05fT1BFUkFUSU9OX05BTUVTID0ge1xuICAgIGxsbTogXCJjaGF0XCIsXG4gICAgdG9vbDogXCJleGVjdXRlX3Rvb2xcIixcbiAgICByZXRyaWV2ZXI6IFwiZW1iZWRkaW5nc1wiLFxuICAgIGVtYmVkZGluZzogXCJlbWJlZGRpbmdzXCIsXG4gICAgcHJvbXB0OiBcImNoYXRcIixcbn07XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25OYW1lKHJ1blR5cGUpIHtcbiAgICByZXR1cm4gV0VMTF9LTk9XTl9PUEVSQVRJT05fTkFNRVNbcnVuVHlwZV0gfHwgcnVuVHlwZTtcbn1cbmV4cG9ydCBjbGFzcyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3BhbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhwb3J0QmF0Y2gob3BlcmF0aW9ucywgb3RlbENvbnRleHRNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghb3AucnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3Aub3BlcmF0aW9uID09PSBcInBvc3RcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5jcmVhdGVTcGFuRm9yUnVuKG9wLCBvcC5ydW4sIG90ZWxDb250ZXh0TWFwLmdldChvcC5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbiAmJiAhb3AucnVuLmVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYW5zLnNldChvcC5pZCwgc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3BhbkZvclJ1bihvcCwgb3AucnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3Npbmcgb3BlcmF0aW9uICR7b3AuaWR9OmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVNwYW5Gb3JSdW4ob3AsIHJ1bkluZm8sIG90ZWxDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBvdGVsQ29udGV4dCAmJiBnZXRPVEVMVHJhY2UoKS5nZXRTcGFuKG90ZWxDb250ZXh0KTtcbiAgICAgICAgaWYgKCFhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFNwYW5TZXR1cChhY3RpdmVTcGFuLCBydW5JbmZvLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgc3BhbiBmb3IgcnVuICR7b3AuaWR9OmAsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2hTcGFuU2V0dXAoc3BhbiwgcnVuSW5mbywgb3ApIHtcbiAgICAgICAgLy8gU2V0IGFsbCBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuc2V0U3BhbkF0dHJpYnV0ZXMoc3BhbiwgcnVuSW5mbywgb3ApO1xuICAgICAgICAvLyBTZXQgc3RhdHVzIGJhc2VkIG9uIGVycm9yXG4gICAgICAgIGlmIChydW5JbmZvLmVycm9yKSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IDIgfSk7IC8vIEVSUk9SIHN0YXR1c1xuICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24obmV3IEVycm9yKHJ1bkluZm8uZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMSB9KTsgLy8gT0sgc3RhdHVzXG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIHRoZSBzcGFuIGlmIGVuZF90aW1lIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHJ1bkluZm8uZW5kX3RpbWUpIHtcbiAgICAgICAgICAgIHNwYW4uZW5kKG5ldyBEYXRlKHJ1bkluZm8uZW5kX3RpbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgdXBkYXRlU3BhbkZvclJ1bihvcCwgcnVuSW5mbykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbnMuZ2V0KG9wLmlkKTtcbiAgICAgICAgICAgIGlmICghc3Bhbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYE5vIHNwYW4gZm91bmQgZm9yIHJ1biAke29wLmlkfSBkdXJpbmcgdXBkYXRlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuc2V0U3BhbkF0dHJpYnV0ZXMoc3BhbiwgcnVuSW5mbywgb3ApO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBiYXNlZCBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKHJ1bkluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IDIgfSk7IC8vIEVSUk9SIHN0YXR1c1xuICAgICAgICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKG5ldyBFcnJvcihydW5JbmZvLmVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IDEgfSk7IC8vIE9LIHN0YXR1c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5kIHRoZSBzcGFuIGlmIGVuZF90aW1lIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBydW5JbmZvLmVuZF90aW1lO1xuICAgICAgICAgICAgaWYgKGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLmVuZChuZXcgRGF0ZShlbmRUaW1lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFucy5kZWxldGUob3AuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIHNwYW4gZm9yIHJ1biAke29wLmlkfTpgLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyYWN0TW9kZWxOYW1lKHJ1bkluZm8pIHtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBtb2RlbCBuYW1lIGZyb20gbWV0YWRhdGFcbiAgICAgICAgaWYgKHJ1bkluZm8uZXh0cmE/Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJ1bkluZm8uZXh0cmEubWV0YWRhdGE7XG4gICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBmb3IgbHNfbW9kZWxfbmFtZSBpbiBtZXRhZGF0YVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmxzX21vZGVsX25hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEubHNfbW9kZWxfbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZW4gY2hlY2sgaW52b2NhdGlvbl9wYXJhbXMgZm9yIG1vZGVsIGluZm9cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5pbnZvY2F0aW9uX3BhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludm9jYXRpb25QYXJhbXMgPSBtZXRhZGF0YS5pbnZvY2F0aW9uX3BhcmFtcztcbiAgICAgICAgICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5tb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52b2NhdGlvblBhcmFtcy5tb2RlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW52b2NhdGlvblBhcmFtcy5tb2RlbF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZvY2F0aW9uUGFyYW1zLm1vZGVsX25hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3BhbkF0dHJpYnV0ZXMoc3BhbiwgcnVuSW5mbywgb3ApIHtcbiAgICAgICAgaWYgKFwicnVuX3R5cGVcIiBpbiBydW5JbmZvICYmIHJ1bkluZm8ucnVuX3R5cGUpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfUlVOX1RZUEUsIHJ1bkluZm8ucnVuX3R5cGUpO1xuICAgICAgICAgICAgLy8gU2V0IEdlbkFJIGF0dHJpYnV0ZXMgYWNjb3JkaW5nIHRvIE9URUwgc2VtYW50aWMgY29udmVudGlvbnNcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbk5hbWUgPSBnZXRPcGVyYXRpb25OYW1lKHJ1bkluZm8ucnVuX3R5cGUgfHwgXCJjaGFpblwiKTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfT1BFUkFUSU9OX05BTUUsIG9wZXJhdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm5hbWVcIiBpbiBydW5JbmZvICYmIHJ1bkluZm8ubmFtZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9OQU1FLCBydW5JbmZvLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInNlc3Npb25faWRcIiBpbiBydW5JbmZvICYmIHJ1bkluZm8uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9TRVNTSU9OX0lELCBydW5JbmZvLnNlc3Npb25faWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInNlc3Npb25fbmFtZVwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5zZXNzaW9uX25hbWUpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfU0VTU0lPTl9OQU1FLCBydW5JbmZvLnNlc3Npb25fbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGdlbl9haS5zeXN0ZW1cbiAgICAgICAgdGhpcy5zZXRHZW5BaVN5c3RlbShzcGFuLCBydW5JbmZvKTtcbiAgICAgICAgLy8gU2V0IG1vZGVsIG5hbWUgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMuZXh0cmFjdE1vZGVsTmFtZShydW5JbmZvKTtcbiAgICAgICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX01PREVMLCBtb2RlbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0b2tlbiB1c2FnZSBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoXCJwcm9tcHRfdG9rZW5zXCIgaW4gcnVuSW5mbyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJ1bkluZm8ucHJvbXB0X3Rva2VucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTlMsIHJ1bkluZm8ucHJvbXB0X3Rva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29tcGxldGlvbl90b2tlbnNcIiBpbiBydW5JbmZvICYmXG4gICAgICAgICAgICB0eXBlb2YgcnVuSW5mby5jb21wbGV0aW9uX3Rva2VucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TLCBydW5JbmZvLmNvbXBsZXRpb25fdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJ0b3RhbF90b2tlbnNcIiBpbiBydW5JbmZvICYmIHR5cGVvZiBydW5JbmZvLnRvdGFsX3Rva2VucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9UT1RBTF9UT0tFTlMsIHJ1bkluZm8udG90YWxfdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3RoZXIgcGFyYW1ldGVycyBmcm9tIGludm9jYXRpb25fcGFyYW1zXG4gICAgICAgIHRoaXMuc2V0SW52b2NhdGlvblBhcmFtZXRlcnMoc3BhbiwgcnVuSW5mbyk7XG4gICAgICAgIC8vIFNldCBtZXRhZGF0YSBhbmQgdGFncyBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBydW5JbmZvLmV4dHJhPy5tZXRhZGF0YSB8fCB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGAke2NvbnN0YW50cy5MQU5HU01JVEhfTUVUQURBVEF9LiR7a2V5fWAsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ3MgPSBydW5JbmZvLnRhZ3M7XG4gICAgICAgIGlmICh0YWdzICYmIEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfVEFHUywgdGFncy5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZ3MpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfVEFHUywgU3RyaW5nKHRhZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdXBwb3J0IGFkZGl0aW9uYWwgc2VyaWFsaXplZCBhdHRyaWJ1dGVzLCBpZiBwcmVzZW50XG4gICAgICAgIGlmIChcInNlcmlhbGl6ZWRcIiBpbiBydW5JbmZvICYmIHR5cGVvZiBydW5JbmZvLnNlcmlhbGl6ZWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBydW5JbmZvLnNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TRVJJQUxJWkVEX05BTUUsIFN0cmluZyhzZXJpYWxpemVkLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfU0VSSUFMSVpFRF9TSUdOQVRVUkUsIFN0cmluZyhzZXJpYWxpemVkLnNpZ25hdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQuZG9jKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TRVJJQUxJWkVEX0RPQywgU3RyaW5nKHNlcmlhbGl6ZWQuZG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGlucHV0cy9vdXRwdXRzIGlmIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLnNldElPQXR0cmlidXRlcyhzcGFuLCBvcCk7XG4gICAgfVxuICAgIHNldEdlbkFpU3lzdGVtKHNwYW4sIHJ1bkluZm8pIHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBcImxhbmdjaGFpblwiIGlmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc3lzdGVtXG4gICAgICAgIGxldCBzeXN0ZW0gPSBcImxhbmdjaGFpblwiO1xuICAgICAgICAvLyBFeHRyYWN0IG1vZGVsIG5hbWUgdG8gZGV0ZXJtaW5lIHRoZSBzeXN0ZW1cbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5leHRyYWN0TW9kZWxOYW1lKHJ1bkluZm8pO1xuICAgICAgICBpZiAobW9kZWxOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbExvd2VyID0gbW9kZWxOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImFudGhyb3BpY1wiKSB8fCBtb2RlbExvd2VyLnN0YXJ0c1dpdGgoXCJjbGF1ZGVcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImFudGhyb3BpY1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImJlZHJvY2tcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImF3cy5iZWRyb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYXp1cmVcIikgJiZcbiAgICAgICAgICAgICAgICBtb2RlbExvd2VyLmluY2x1ZGVzKFwib3BlbmFpXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJhei5haS5vcGVuYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJhenVyZVwiKSAmJlxuICAgICAgICAgICAgICAgIG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJpbmZlcmVuY2VcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImF6LmFpLmluZmVyZW5jZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImNvaGVyZVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiY29oZXJlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiZGVlcHNlZWtcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImRlZXBzZWVrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ2VtaW5pXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJnZW1pbmlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJncm9xXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJncm9xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwid2F0c29uXCIpIHx8IG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJpYm1cIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImlibS53YXRzb254LmFpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwibWlzdHJhbFwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwibWlzdHJhbF9haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImdwdFwiKSB8fCBtb2RlbExvd2VyLmluY2x1ZGVzKFwib3BlbmFpXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJvcGVuYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJwZXJwbGV4aXR5XCIpIHx8XG4gICAgICAgICAgICAgICAgbW9kZWxMb3dlci5pbmNsdWRlcyhcInNvbmFyXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJwZXJwbGV4aXR5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwidmVydGV4XCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJ2ZXJ0ZXhfYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJ4YWlcIikgfHwgbW9kZWxMb3dlci5pbmNsdWRlcyhcImdyb2tcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInhhaVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfU1lTVEVNLCBzeXN0ZW0pO1xuICAgIH1cbiAgICBzZXRJbnZvY2F0aW9uUGFyYW1ldGVycyhzcGFuLCBydW5JbmZvKSB7XG4gICAgICAgIGlmICghcnVuSW5mby5leHRyYT8ubWV0YWRhdGE/Lmludm9jYXRpb25fcGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW52b2NhdGlvblBhcmFtcyA9IHJ1bkluZm8uZXh0cmEubWV0YWRhdGEuaW52b2NhdGlvbl9wYXJhbXM7XG4gICAgICAgIC8vIFNldCByZWxldmFudCBpbnZvY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMubWF4X3Rva2VucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfTUFYX1RPS0VOUywgaW52b2NhdGlvblBhcmFtcy5tYXhfdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy50ZW1wZXJhdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfVEVNUEVSQVRVUkUsIGludm9jYXRpb25QYXJhbXMudGVtcGVyYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLnRvcF9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9UT1BfUCwgaW52b2NhdGlvblBhcmFtcy50b3BfcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMuZnJlcXVlbmN5X3BlbmFsdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX0ZSRVFVRU5DWV9QRU5BTFRZLCBpbnZvY2F0aW9uUGFyYW1zLmZyZXF1ZW5jeV9wZW5hbHR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5wcmVzZW5jZV9wZW5hbHR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZLCBpbnZvY2F0aW9uUGFyYW1zLnByZXNlbmNlX3BlbmFsdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldElPQXR0cmlidXRlcyhzcGFuLCBvcCkge1xuICAgICAgICBpZiAob3AucnVuLmlucHV0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBvcC5ydW4uaW5wdXRzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRzID09PSBcIm9iamVjdFwiICYmIGlucHV0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLm1vZGVsICYmIEFycmF5LmlzQXJyYXkoaW5wdXRzLm1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX01PREVMLCBpbnB1dHMubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhZGRpdGlvbmFsIHJlcXVlc3QgYXR0cmlidXRlcyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5zdHJlYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9SRVFVRVNUX1NUUkVBTUlORywgaW5wdXRzLnN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5leHRyYV9oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUywgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLmV4dHJhX2hlYWRlcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmV4dHJhX3F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfRVhUUkFfUVVFUlksIEpTT04uc3RyaW5naWZ5KGlucHV0cy5leHRyYV9xdWVyeSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuZXh0cmFfYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFksIEpTT04uc3RyaW5naWZ5KGlucHV0cy5leHRyYV9ib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTkFJX1BST01QVCwgSlNPTi5zdHJpbmdpZnkoaW5wdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYEZhaWxlZCB0byBwcm9jZXNzIGlucHV0cyBmb3IgcnVuICR7b3AuaWR9YCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLnJ1bi5vdXRwdXRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBvcC5ydW4ub3V0cHV0cztcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRva2VuIHVzYWdlIGZyb20gb3V0cHV0cyAoZm9yIExMTSBydW5zKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVXNhZ2UgPSB0aGlzLmdldFVuaWZpZWRSdW5Ub2tlbnMob3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuVXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTlMsIHRva2VuVXNhZ2VbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMsIHRva2VuVXNhZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUywgdG9rZW5Vc2FnZVswXSArIHRva2VuVXNhZ2VbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0cyAmJiB0eXBlb2Ygb3V0cHV0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5tb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9NT0RFTCwgU3RyaW5nKG91dHB1dHMubW9kZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGFkZGl0aW9uYWwgcmVzcG9uc2UgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9JRCwgb3V0cHV0cy5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuY2hvaWNlcyAmJiBBcnJheS5pc0FycmF5KG91dHB1dHMuY2hvaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmlzaFJlYXNvbnMgPSBvdXRwdXRzLmNob2ljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGNob2ljZSkgPT4gY2hvaWNlLmZpbmlzaF9yZWFzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChyZWFzb24pID0+IHJlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoUmVhc29ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9GSU5JU0hfUkVBU09OUywgZmluaXNoUmVhc29ucy5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLnNlcnZpY2VfdGllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9TRVJWSUNFX1RJRVIsIG91dHB1dHMuc2VydmljZV90aWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zeXN0ZW1fZmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVTUE9OU0VfU1lTVEVNX0ZJTkdFUlBSSU5ULCBvdXRwdXRzLnN5c3RlbV9maW5nZXJwcmludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMudXNhZ2VfbWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRzLnVzYWdlX21ldGFkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2FnZU1ldGFkYXRhID0gb3V0cHV0cy51c2FnZV9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2FnZU1ldGFkYXRhLmlucHV0X3Rva2VuX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOX0RFVEFJTFMsIEpTT04uc3RyaW5naWZ5KHVzYWdlTWV0YWRhdGEuaW5wdXRfdG9rZW5fZGV0YWlscykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlTWV0YWRhdGEub3V0cHV0X3Rva2VuX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTl9ERVRBSUxTLCBKU09OLnN0cmluZ2lmeSh1c2FnZU1ldGFkYXRhLm91dHB1dF90b2tlbl9kZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTkFJX0NPTVBMRVRJT04sIEpTT04uc3RyaW5naWZ5KG91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgRmFpbGVkIHRvIHByb2Nlc3Mgb3V0cHV0cyBmb3IgcnVuICR7b3AuaWR9YCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXRVbmlmaWVkUnVuVG9rZW5zKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKCFvdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggaW4gbm9uLWdlbmVyYXRpb25zIGxpc3RzXG4gICAgICAgIGxldCB0b2tlblVzYWdlID0gdGhpcy5leHRyYWN0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRva2VuVXNhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlblVzYWdlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgaWYgZGlyZWN0IGt3YXJnIGluIG91dHB1dHNcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG91dHB1dHMpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBoYXlzdGFjayA9IG91dHB1dHNba2V5XTtcbiAgICAgICAgICAgIGlmICghaGF5c3RhY2sgfHwgdHlwZW9mIGhheXN0YWNrICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlblVzYWdlID0gdGhpcy5leHRyYWN0VW5pZmllZFJ1blRva2VucyhoYXlzdGFjay51c2FnZV9tZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblVzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhheXN0YWNrLmxjID09PSAxICYmXG4gICAgICAgICAgICAgICAgaGF5c3RhY2sua3dhcmdzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGhheXN0YWNrLmt3YXJncyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKGhheXN0YWNrLmt3YXJncy51c2FnZV9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuVXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgaW4gZ2VuZXJhdGlvbnNcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBvdXRwdXRzLmdlbmVyYXRpb25zIHx8IFtdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VuZXJhdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGF0R2VuZXJhdGlvbnMgPSBBcnJheS5pc0FycmF5KGdlbmVyYXRpb25zWzBdKVxuICAgICAgICAgICAgPyBnZW5lcmF0aW9ucy5mbGF0KClcbiAgICAgICAgICAgIDogZ2VuZXJhdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGlvbiBvZiBmbGF0R2VuZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2VuZXJhdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBnZW5lcmF0aW9uLm1lc3NhZ2UgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2Uua3dhcmdzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGdlbmVyYXRpb24ubWVzc2FnZS5rd2FyZ3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlblVzYWdlID0gdGhpcy5leHRyYWN0VW5pZmllZFJ1blRva2VucyhnZW5lcmF0aW9uLm1lc3NhZ2Uua3dhcmdzLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5Vc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMob3V0cHV0cykge1xuICAgICAgICBpZiAoIW91dHB1dHMgfHwgdHlwZW9mIG91dHB1dHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0cy5pbnB1dF90b2tlbnMgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRzLm91dHB1dF90b2tlbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbb3V0cHV0cy5pbnB1dF90b2tlbnMsIG91dHB1dHMub3V0cHV0X3Rva2Vuc107XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/experimental/otel/translator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* reexport safe */ _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_5__.Cache),\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _utils_project_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation),\n/* harmony export */   uuid7: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/project.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uuid.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/uuid.js\");\n/* harmony import */ var _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/prompts_cache.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache.js\");\n\n\n\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.4.9\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDRztBQUMyQjtBQUNUO0FBQ1Y7QUFDQztBQUNsRDtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/ZjVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQsIH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG5leHBvcnQgeyBnZXREZWZhdWx0UHJvamVjdE5hbWUgfSBmcm9tIFwiLi91dGlscy9wcm9qZWN0LmpzXCI7XG5leHBvcnQgeyB1dWlkNywgdXVpZDdGcm9tVGltZSB9IGZyb20gXCIuL3V1aWQuanNcIjtcbmV4cG9ydCB7IENhY2hlLCB9IGZyb20gXCIuL3V0aWxzL3Byb21wdHNfY2FjaGUuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjQuOVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/run_trees.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/error.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./singletons/constants.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/constants.js\");\n/* harmony import */ var _utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/context_vars.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/context_vars.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/project.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+uuid@10.0.0/node_modules/uuid/dist/esm-node/v5.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst TIMESTAMP_LENGTH = 36;\n// DNS namespace for UUID v5 (same as Python's uuid.NAMESPACE_DNS)\nconst UUID_NAMESPACE_DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\nfunction getReplicaKey(replica) {\n    // Generate a unique key by hashing the replica's identifying properties\n    // This ensures each unique replica (combination of projectName, apiUrl, workspaceId, apiKey) gets a unique key\n    // Sort keys to ensure consistent hashing\n    const sortedKeys = Object.keys(replica).sort();\n    const keyData = sortedKeys\n        .map((key) => `${key}:${replica[key] ?? \"\"}`)\n        .join(\"|\");\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(keyData, UUID_NAMESPACE_DNS);\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);\n    return {\n        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,\n        microsecondPrecisionDatestring,\n    };\n}\nconst HEADER_SAFE_REPLICA_FIELDS = new Set([\n    \"projectName\",\n    \"updates\",\n    \"reroot\",\n]);\nfunction filterReplicaForHeaders(replica) {\n    const filtered = {};\n    for (const key of Object.keys(replica)) {\n        if (HEADER_SAFE_REPLICA_FIELDS.has(key)) {\n            filtered[key] = replica[key];\n        }\n    }\n    return filtered;\n}\n/**\n * Baggage header information\n */\nclass Baggage {\n    constructor(metadata, tags, project_name, replicas) {\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n        this.project_name = project_name;\n        this.replicas = replicas;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        let project_name;\n        let replicas;\n        for (const item of items) {\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            }\n            else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n            else if (key === \"langsmith-project\") {\n                project_name = value;\n            }\n            else if (key === \"langsmith-replicas\") {\n                const parsed = JSON.parse(value);\n                replicas = parsed.map((replica) => {\n                    if (Array.isArray(replica)) {\n                        return replica;\n                    }\n                    return filterReplicaForHeaders(replica);\n                });\n            }\n        }\n        return new Baggage(metadata, tags, project_name, replicas);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        if (this.project_name) {\n            items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */\n        Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Projects to replicate this run to with optional updates.\n         */\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"distributedParentId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @interface\n         */\n        Object.defineProperty(this, \"_serialized_start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal\n         */\n        Object.defineProperty(this, \"_awaitInputsOnPost\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, { ...originalConfig });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata,\n        };\n        config.extra = { ...config.extra, metadata: dedupedMetadata };\n        if (\"id\" in config && config.id == null) {\n            delete config.id;\n        }\n        Object.assign(this, { ...defaultConfig, ...config, client });\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        // Generate serialized start time for ID generation\n        if (!this.dotted_order) {\n            this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);\n        }\n        // Generate id from serialized start_time if not provided\n        if (!this.id) {\n            this.id = (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__.uuid7FromTime)(this._serialized_start_time ?? this.start_time);\n        }\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            }\n            else {\n                this.trace_id = this.id;\n            }\n        }\n        this.replicas = _ensureWriteReplicas(this.replicas);\n        // Now set the dotted order with the actual ID\n        if (!this.dotted_order) {\n            const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + dottedOrder;\n            }\n            else {\n                this.dotted_order = dottedOrder;\n            }\n        }\n    }\n    set metadata(metadata) {\n        this.extra = {\n            ...this.extra,\n            metadata: {\n                ...this.extra?.metadata,\n                ...metadata,\n            },\n        };\n    }\n    get metadata() {\n        return this.extra?.metadata;\n    }\n    static getDefaultConfig() {\n        const start_time = Date.now();\n        return {\n            run_type: \"chain\",\n            project_name: (0,_utils_project_js__WEBPACK_IMPORTED_MODULE_6__.getDefaultProjectName)(),\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time,\n            serialized: {},\n            inputs: {},\n            extra: {},\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_0__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        // Handle replicas: if child has its own replicas, use those; otherwise inherit parent's (with reroot stripped)\n        // Reroot should only apply to the run where it's explicitly configured, not propagate down\n        const inheritedReplicas = this.replicas?.map((replica) => {\n            const { reroot, ...rest } = replica;\n            return rest;\n        });\n        const childReplicas = config.replicas ?? inheritedReplicas;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            replicas: childReplicas,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order,\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY] =\n                this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ??\n            this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = { ...presentConfig };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks)\n                ? newConfig.callbacks.copy?.()\n                : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, { _parentRunId: child.id });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers\n                    ?.find(isLangChainTracerLike)\n                    ?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while (current != null && !visited.has(current.id)) {\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra\n                ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } }\n                : { metadata };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        // Avoid overwriting the runtime environment if it's already set\n        if (runExtra?.runtime?.library === undefined) {\n            if (!runExtra.runtime) {\n                runExtra.runtime = {};\n            }\n            if (runtimeEnv) {\n                for (const [k, v] of Object.entries(runtimeEnv)) {\n                    if (!runExtra.runtime[k]) {\n                        runExtra.runtime[k] = v;\n                    }\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        }\n        else {\n            parent_run_id = run.parent_run?.id ?? run.parent_run_id;\n            child_runs = [];\n        }\n        return {\n            id: run.id,\n            name: run.name,\n            start_time: run._serialized_start_time ?? run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments,\n            events: run.events,\n        };\n    }\n    _sliceParentId(parentId, run) {\n        /**\n         * Slice the parent id from dotted order.\n         * Additionally check if the current run is a child of the parent. If so, update\n         * the parent_run_id to undefined, and set the trace id to the new root id after\n         * parent_id.\n         */\n        if (run.dotted_order) {\n            const segs = run.dotted_order.split(\".\");\n            let startIdx = null;\n            // Find the index of the parent ID in the dotted order\n            for (let idx = 0; idx < segs.length; idx++) {\n                const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                if (segId === parentId) {\n                    startIdx = idx;\n                    break;\n                }\n            }\n            if (startIdx !== null) {\n                // Trim segments to start after parent_id (exclusive)\n                const trimmedSegs = segs.slice(startIdx + 1);\n                // Rebuild dotted_order\n                run.dotted_order = trimmedSegs.join(\".\");\n                if (trimmedSegs.length > 0) {\n                    run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);\n                }\n                else {\n                    run.trace_id = run.id;\n                }\n            }\n        }\n        if (run.parent_run_id === parentId) {\n            // We've found the new root node.\n            run.parent_run_id = undefined;\n        }\n    }\n    _setReplicaTraceRoot(replicaKey, traceRootId) {\n        // Set the replica trace root in context vars on this run and all descendants\n        const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n        replicaTraceRoots[replicaKey] = traceRootId;\n        (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.setContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);\n        // Recursively update all descendants to avoid race conditions\n        // around run tree creation vs processing time\n        for (const child of this.child_runs) {\n            child._setReplicaTraceRoot(replicaKey, traceRootId);\n        }\n    }\n    _remapForProject(params) {\n        const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId, } = params;\n        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n        // Skip remapping if project name is the same\n        if (projectName === this.project_name) {\n            return {\n                ...baseRun,\n                session_name: projectName,\n            };\n        }\n        // Apply reroot logic before ID remapping\n        if (reroot) {\n            if (distributedParentId) {\n                // If we have a distributed parent ID, slice at that point\n                this._sliceParentId(distributedParentId, baseRun);\n            }\n            else {\n                // If no distributed parent ID, simply make this run a root run\n                // by removing parent_run_id and resetting trace info\n                baseRun.parent_run_id = undefined;\n                // Keep the current run as the trace root\n                if (baseRun.dotted_order) {\n                    // Reset dotted order to just this run\n                    const segs = baseRun.dotted_order.split(\".\");\n                    if (segs.length > 0) {\n                        baseRun.dotted_order = segs[segs.length - 1];\n                        baseRun.trace_id = baseRun.id;\n                    }\n                }\n            }\n            // Store this run's original ID in context vars so descendants know the new trace root\n            // We store the original ID (before remapping) so it can be found in dotted_order\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            this._setReplicaTraceRoot(replicaKey, baseRun.id);\n        }\n        // If an ancestor was rerooted for this replica, update trace_id and dotted_order\n        // to reflect the new trace hierarchy. This is tracked via context variables.\n        let ancestorRerootedTraceId;\n        if (!reroot) {\n            const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            ancestorRerootedTraceId = replicaTraceRoots[replicaKey];\n            if (ancestorRerootedTraceId) {\n                // An ancestor was rerooted for this replica, so set our trace_id\n                // to the ancestor's original (unmapped) ID. It will be remapped along with other IDs.\n                baseRun.trace_id = ancestorRerootedTraceId;\n                // Also slice the dotted_order to start from the new trace root\n                // This ensures descendants of a rerooted ancestor have correct hierarchy\n                if (baseRun.dotted_order) {\n                    const segs = baseRun.dotted_order.split(\".\");\n                    let rootIdx = null;\n                    // Find the new trace root's segment in dotted_order\n                    for (let idx = 0; idx < segs.length; idx++) {\n                        const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                        if (segId === ancestorRerootedTraceId) {\n                            rootIdx = idx;\n                            break;\n                        }\n                    }\n                    if (rootIdx !== null) {\n                        // Keep segments from new trace root onwards\n                        const trimmedSegs = segs.slice(rootIdx);\n                        baseRun.dotted_order = trimmedSegs.join(\".\");\n                    }\n                }\n            }\n        }\n        // Remap IDs for the replica using uuid5 (deterministic)\n        // This ensures consistency across runs in the same replica\n        const oldId = baseRun.id;\n        const newId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);\n        // Remap trace_id\n        let newTraceId;\n        if (baseRun.trace_id) {\n            newTraceId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        else {\n            newTraceId = newId;\n        }\n        // Remap parent_run_id\n        let newParentId;\n        if (baseRun.parent_run_id) {\n            newParentId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        // Remap dotted_order segments\n        let newDottedOrder;\n        if (baseRun.dotted_order) {\n            const segs = baseRun.dotted_order.split(\".\");\n            const remappedSegs = segs.map((seg) => {\n                // Extract the UUID from the segment (last TIMESTAMP_LENGTH characters)\n                const segId = seg.slice(-TIMESTAMP_LENGTH);\n                const remappedId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);\n                // Replace the UUID part while keeping the timestamp prefix\n                return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;\n            });\n            newDottedOrder = remappedSegs.join(\".\");\n        }\n        return {\n            ...baseRun,\n            id: newId,\n            trace_id: newTraceId,\n            parent_run_id: newParentId,\n            dotted_order: newDottedOrder,\n            session_name: projectName,\n        };\n    }\n    async postRun(excludeChildRuns = true) {\n        // Applies when `processInputs` is an async function\n        if (this._awaitInputsOnPost) {\n            this.inputs = await this.inputs;\n        }\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getRuntimeEnvironment)();\n            if (this.replicas && this.replicas.length > 0) {\n                for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this\n                    .replicas) {\n                    const runCreate = this._remapForProject({\n                        projectName: projectName ?? this.project_name,\n                        runtimeEnv,\n                        excludeChildRuns: true,\n                        reroot,\n                        distributedParentId: this.distributedParentId,\n                        apiUrl,\n                        apiKey,\n                        workspaceId,\n                    });\n                    await this.client.createRun(runCreate, {\n                        apiKey,\n                        apiUrl,\n                        workspaceId,\n                    });\n                }\n            }\n            else {\n                const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n                await this.client.createRun(runCreate);\n            }\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs) {\n                    await childRun.postRun(false);\n                }\n            }\n            this.child_runs = [];\n        }\n        catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun(options) {\n        if (this.replicas && this.replicas.length > 0) {\n            for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot, } of this.replicas) {\n                const runData = this._remapForProject({\n                    projectName: projectName ?? this.project_name,\n                    runtimeEnv: undefined,\n                    excludeChildRuns: true,\n                    reroot,\n                    distributedParentId: this.distributedParentId,\n                    apiUrl,\n                    apiKey,\n                    workspaceId,\n                });\n                const updatePayload = {\n                    id: runData.id,\n                    name: runData.name,\n                    run_type: runData.run_type,\n                    start_time: runData.start_time,\n                    outputs: runData.outputs,\n                    error: runData.error,\n                    parent_run_id: runData.parent_run_id,\n                    session_name: runData.session_name,\n                    reference_example_id: runData.reference_example_id,\n                    end_time: runData.end_time,\n                    dotted_order: runData.dotted_order,\n                    trace_id: runData.trace_id,\n                    events: runData.events,\n                    tags: runData.tags,\n                    extra: runData.extra,\n                    attachments: this.attachments,\n                    ...updates,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    updatePayload.inputs = runData.inputs;\n                }\n                await this.client.updateRun(runData.id, updatePayload, {\n                    apiKey,\n                    apiUrl,\n                    workspaceId,\n                });\n            }\n        }\n        else {\n            try {\n                const runUpdate = {\n                    name: this.name,\n                    run_type: this.run_type,\n                    start_time: this._serialized_start_time ?? this.start_time,\n                    end_time: this.end_time,\n                    error: this.error,\n                    outputs: this.outputs,\n                    parent_run_id: this.parent_run?.id ?? this.parent_run_id,\n                    reference_example_id: this.reference_example_id,\n                    extra: this.extra,\n                    events: this.events,\n                    dotted_order: this.dotted_order,\n                    trace_id: this.trace_id,\n                    tags: this.tags,\n                    attachments: this.attachments,\n                    session_name: this.project_name,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    runUpdate.inputs = this.inputs;\n                }\n                await this.client.updateRun(this.id, runUpdate);\n            }\n            catch (error) {\n                console.error(`Error in patchRun for run ${this.id}`, error);\n            }\n        }\n        this.child_runs = [];\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */\n    addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event,\n            });\n        }\n        else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString(),\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName,\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? [])),\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata,\n                },\n            },\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({ \"langsmith-trace\": dottedOrder });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\"\n            ? {\n                \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n                baggage: headers.get(\"baggage\"),\n            }\n            : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\")\n            return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part) => {\n            const [strTime, uuid] = part.split(\"Z\");\n            return { strTime, time: Date.parse(strTime + \"Z\"), uuid };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder,\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n            config.project_name = baggage.project_name;\n            config.replicas = baggage.replicas;\n        }\n        const runTree = new RunTree(config);\n        // Set the distributed parent ID to this run's ID for rerooting\n        runTree.distributedParentId = runTree.id;\n        return runTree;\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader(),\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)) {\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return (x != null &&\n        typeof x.createChild === \"function\" &&\n        typeof x.postRun === \"function\");\n}\nfunction isLangChainTracerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        typeof x.name === \"string\" &&\n        x.name === \"langchain_tracer\");\n}\nfunction containsLangChainTracerLike(x) {\n    return (Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback)));\n}\nfunction isCallbackManagerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        Array.isArray(x.handlers));\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    const callbacks = x?.callbacks;\n    return (x != null &&\n        typeof callbacks === \"object\" &&\n        // Callback manager with a langchain tracer\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (containsLangChainTracerLike(callbacks?.handlers) ||\n            // Or it's an array with a LangChainTracerLike object within it\n            containsLangChainTracerLike(callbacks)));\n}\nfunction _getWriteReplicasFromEnv() {\n    const envVar = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGSMITH_RUNS_ENDPOINTS\");\n    if (!envVar)\n        return [];\n    try {\n        const parsed = JSON.parse(envVar);\n        if (Array.isArray(parsed)) {\n            const replicas = [];\n            for (const item of parsed) {\n                if (typeof item !== \"object\" || item === null) {\n                    console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected object, got ${typeof item}`);\n                    continue;\n                }\n                if (typeof item.api_url !== \"string\") {\n                    console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_url}`);\n                    continue;\n                }\n                if (typeof item.api_key !== \"string\") {\n                    console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_key}`);\n                    continue;\n                }\n                replicas.push({\n                    apiUrl: item.api_url.replace(/\\/$/, \"\"),\n                    apiKey: item.api_key,\n                });\n            }\n            return replicas;\n        }\n        else if (typeof parsed === \"object\" && parsed !== null) {\n            _checkEndpointEnvUnset(parsed);\n            const replicas = [];\n            for (const [url, key] of Object.entries(parsed)) {\n                const cleanUrl = url.replace(/\\/$/, \"\");\n                if (typeof key === \"string\") {\n                    replicas.push({\n                        apiUrl: cleanUrl,\n                        apiKey: key,\n                    });\n                }\n                else {\n                    console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` +\n                        `expected string, got ${typeof key}`);\n                    continue;\n                }\n            }\n            return replicas;\n        }\n        else {\n            console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n                `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);\n            return [];\n        }\n    }\n    catch (e) {\n        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_2__.isConflictingEndpointsError)(e)) {\n            throw e;\n        }\n        console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n            \"objects with api_url and api_key properties, or object mapping url->apiKey\");\n        return [];\n    }\n}\nfunction _ensureWriteReplicas(replicas) {\n    // If null -> fetch from env\n    if (replicas) {\n        return replicas.map((replica) => {\n            if (Array.isArray(replica)) {\n                return {\n                    projectName: replica[0],\n                    updates: replica[1],\n                };\n            }\n            return replica;\n        });\n    }\n    return _getWriteReplicasFromEnv();\n}\nfunction _checkEndpointEnvUnset(parsed) {\n    if (Object.keys(parsed).length > 0 &&\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getLangSmithEnvironmentVariable)(\"ENDPOINT\")) {\n        throw new _utils_error_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingEndpointsError();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ087QUFDK0M7QUFDTTtBQUMxQjtBQUNTO0FBQ3JCO0FBQ007QUFDdEI7QUFDTTtBQUNiO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLEdBQUcsbUJBQW1CO0FBQ25EO0FBQ0EsV0FBVyxnREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkMsRUFBRSxZQUFZO0FBQ3ZFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtEQUFrRDtBQUMvRjtBQUNBO0FBQ0EseUNBQXlDLHdDQUF3QztBQUNqRjtBQUNBO0FBQ0EsNENBQTRDLHNDQUFzQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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VztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxjQUFjO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0RUFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhFQUErQjtBQUN2QyxrQkFBa0Isc0VBQXlCO0FBQzNDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanM/ZDQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7IGlzVHJhY2luZ0VuYWJsZWQgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmltcG9ydCB7IGlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciwgQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciwgfSBmcm9tIFwiLi91dGlscy9lcnJvci5qc1wiO1xuaW1wb3J0IHsgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSwgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZLCB9IGZyb20gXCIuL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRDb250ZXh0VmFyLCBzZXRDb250ZXh0VmFyIH0gZnJvbSBcIi4vdXRpbHMvY29udGV4dF92YXJzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0UHJvamVjdE5hbWUgfSBmcm9tIFwiLi91dGlscy9wcm9qZWN0LmpzXCI7XG5pbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gXCIuL3V0aWxzL3dhcm4uanNcIjtcbmltcG9ydCB7IHV1aWQ3RnJvbVRpbWUgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuaW1wb3J0IHsgdjUgYXMgdXVpZHY1IH0gZnJvbSBcInV1aWRcIjtcbmNvbnN0IFRJTUVTVEFNUF9MRU5HVEggPSAzNjtcbi8vIEROUyBuYW1lc3BhY2UgZm9yIFVVSUQgdjUgKHNhbWUgYXMgUHl0aG9uJ3MgdXVpZC5OQU1FU1BBQ0VfRE5TKVxuY29uc3QgVVVJRF9OQU1FU1BBQ0VfRE5TID0gXCI2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIjtcbmZ1bmN0aW9uIGdldFJlcGxpY2FLZXkocmVwbGljYSkge1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGtleSBieSBoYXNoaW5nIHRoZSByZXBsaWNhJ3MgaWRlbnRpZnlpbmcgcHJvcGVydGllc1xuICAgIC8vIFRoaXMgZW5zdXJlcyBlYWNoIHVuaXF1ZSByZXBsaWNhIChjb21iaW5hdGlvbiBvZiBwcm9qZWN0TmFtZSwgYXBpVXJsLCB3b3Jrc3BhY2VJZCwgYXBpS2V5KSBnZXRzIGEgdW5pcXVlIGtleVxuICAgIC8vIFNvcnQga2V5cyB0byBlbnN1cmUgY29uc2lzdGVudCBoYXNoaW5nXG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHJlcGxpY2EpLnNvcnQoKTtcbiAgICBjb25zdCBrZXlEYXRhID0gc29ydGVkS2V5c1xuICAgICAgICAubWFwKChrZXkpID0+IGAke2tleX06JHtyZXBsaWNhW2tleV0gPz8gXCJcIn1gKVxuICAgICAgICAuam9pbihcInxcIik7XG4gICAgcmV0dXJuIHV1aWR2NShrZXlEYXRhLCBVVUlEX05BTUVTUEFDRV9ETlMpO1xufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBnZXRNaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcoZXBvY2gsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIC8vIERhdGUgb25seSBoYXMgbWlsbGlzZWNvbmQgcHJlY2lzaW9uLCBzbyB3ZSB1c2UgdGhlIG1pY3Jvc2Vjb25kcyB0byBicmVha1xuICAgIC8vIHBvc3NpYmxlIHRpZXMsIGF2b2lkaW5nIGluY29ycmVjdCBydW4gb3JkZXJcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIHJldHVybiBgJHtuZXcgRGF0ZShlcG9jaCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMSl9JHtwYWRkZWRPcmRlcn1aYDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyA9IGdldE1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyhlcG9jaCwgZXhlY3V0aW9uT3JkZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdHRlZE9yZGVyOiBzdHJpcE5vbkFscGhhbnVtZXJpYyhtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcpICsgcnVuSWQsXG4gICAgICAgIG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyxcbiAgICB9O1xufVxuY29uc3QgSEVBREVSX1NBRkVfUkVQTElDQV9GSUVMRFMgPSBuZXcgU2V0KFtcbiAgICBcInByb2plY3ROYW1lXCIsXG4gICAgXCJ1cGRhdGVzXCIsXG4gICAgXCJyZXJvb3RcIixcbl0pO1xuZnVuY3Rpb24gZmlsdGVyUmVwbGljYUZvckhlYWRlcnMocmVwbGljYSkge1xuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVwbGljYSkpIHtcbiAgICAgICAgaWYgKEhFQURFUl9TQUZFX1JFUExJQ0FfRklFTERTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gcmVwbGljYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbi8qKlxuICogQmFnZ2FnZSBoZWFkZXIgaW5mb3JtYXRpb25cbiAqL1xuY2xhc3MgQmFnZ2FnZSB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEsIHRhZ3MsIHByb2plY3RfbmFtZSwgcmVwbGljYXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbGljYXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLnByb2plY3RfbmFtZSA9IHByb2plY3RfbmFtZTtcbiAgICAgICAgdGhpcy5yZXBsaWNhcyA9IHJlcGxpY2FzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgIGxldCB0YWdzID0gW107XG4gICAgICAgIGxldCBwcm9qZWN0X25hbWU7XG4gICAgICAgIGxldCByZXBsaWNhcztcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB1cmlWYWx1ZV0gPSBpdGVtLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLW1ldGFkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC10YWdzXCIpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1wcm9qZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtcmVwbGljYXNcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlcGxpY2FzID0gcGFyc2VkLm1hcCgocmVwbGljYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsaWNhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxpY2E7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclJlcGxpY2FGb3JIZWFkZXJzKHJlcGxpY2EpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmFnZ2FnZShtZXRhZGF0YSwgdGFncywgcHJvamVjdF9uYW1lLCByZXBsaWNhcyk7XG4gICAgfVxuICAgIHRvSGVhZGVyKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAmJiBPYmplY3Qua2V5cyh0aGlzLm1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtbWV0YWRhdGE9JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodGhpcy5tZXRhZGF0YSkpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgdGhpcy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC10YWdzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudGFncy5qb2luKFwiLFwiKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdF9uYW1lKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtcHJvamVjdD0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnByb2plY3RfbmFtZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zLmpvaW4oXCIsXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5UcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbENvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bl90eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRfcnVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5faWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfcnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4dHJhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdHRlZF9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nRW5hYmxlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfZXhlY3V0aW9uX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2htZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bi5cbiAgICAgICAgICogRWFjaCBlbnRyeSBpcyBhIHR1cGxlIG9mIFttaW1lX3R5cGUsIGJ5dGVzXVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXR0YWNobWVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2plY3RzIHRvIHJlcGxpY2F0ZSB0aGlzIHJ1biB0byB3aXRoIG9wdGlvbmFsIHVwZGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXBsaWNhc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXN0cmlidXRlZFBhcmVudElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJmYWNlXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VyaWFsaXplZF9zdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hd2FpdElucHV0c09uUG9zdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB5b3UgcGFzcyBpbiBhIHJ1biB0cmVlIGRpcmVjdGx5LCByZXR1cm4gYSBzaGFsbG93IGNsb25lXG4gICAgICAgIGlmIChpc1J1blRyZWUob3JpZ2luYWxDb25maWcpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4ub3JpZ2luYWxDb25maWcgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IFJ1blRyZWUuZ2V0RGVmYXVsdENvbmZpZygpO1xuICAgICAgICBjb25zdCB7IG1ldGFkYXRhLCAuLi5jb25maWcgfSA9IG9yaWdpbmFsQ29uZmlnO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBjb25maWcuY2xpZW50ID8/IFJ1blRyZWUuZ2V0U2hhcmVkQ2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGRlZHVwZWRNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4uY29uZmlnPy5leHRyYT8ubWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZy5leHRyYSA9IHsgLi4uY29uZmlnLmV4dHJhLCBtZXRhZGF0YTogZGVkdXBlZE1ldGFkYXRhIH07XG4gICAgICAgIGlmIChcImlkXCIgaW4gY29uZmlnICYmIGNvbmZpZy5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLmlkO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWcsIGNsaWVudCB9KTtcbiAgICAgICAgdGhpcy5leGVjdXRpb25fb3JkZXIgPz89IDE7XG4gICAgICAgIHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyID8/PSAxO1xuICAgICAgICAvLyBHZW5lcmF0ZSBzZXJpYWxpemVkIHN0YXJ0IHRpbWUgZm9yIElEIGdlbmVyYXRpb25cbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgdGhpcy5fc2VyaWFsaXplZF9zdGFydF90aW1lID0gZ2V0TWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nKHRoaXMuc3RhcnRfdGltZSwgdGhpcy5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIGlkIGZyb20gc2VyaWFsaXplZCBzdGFydF90aW1lIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1dWlkN0Zyb21UaW1lKHRoaXMuX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA/PyB0aGlzLnN0YXJ0X3RpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQgPz8gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwbGljYXMgPSBfZW5zdXJlV3JpdGVSZXBsaWNhcyh0aGlzLnJlcGxpY2FzKTtcbiAgICAgICAgLy8gTm93IHNldCB0aGUgZG90dGVkIG9yZGVyIHdpdGggdGhlIGFjdHVhbCBJRFxuICAgICAgICBpZiAoIXRoaXMuZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvdHRlZE9yZGVyIH0gPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCh0aGlzLnN0YXJ0X3RpbWUsIHRoaXMuaWQsIHRoaXMuZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IHRoaXMucGFyZW50X3J1bi5kb3R0ZWRfb3JkZXIgKyBcIi5cIiArIGRvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPSBkb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgbWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZXh0cmEsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYT8ubWV0YWRhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImNoYWluXCIsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IGdldERlZmF1bHRQcm9qZWN0TmFtZSgpLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBhcGlfdXJsOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIiksXG4gICAgICAgICAgICBjYWxsZXJfb3B0aW9uczoge30sXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDoge30sXG4gICAgICAgICAgICBpbnB1dHM6IHt9LFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2hhcmVkQ2xpZW50KCkge1xuICAgICAgICBpZiAoIVJ1blRyZWUuc2hhcmVkQ2xpZW50KSB7XG4gICAgICAgICAgICBSdW5UcmVlLnNoYXJlZENsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUnVuVHJlZS5zaGFyZWRDbGllbnQ7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKGNvbmZpZykge1xuICAgICAgICBjb25zdCBjaGlsZF9leGVjdXRpb25fb3JkZXIgPSB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgICAgIC8vIEhhbmRsZSByZXBsaWNhczogaWYgY2hpbGQgaGFzIGl0cyBvd24gcmVwbGljYXMsIHVzZSB0aG9zZTsgb3RoZXJ3aXNlIGluaGVyaXQgcGFyZW50J3MgKHdpdGggcmVyb290IHN0cmlwcGVkKVxuICAgICAgICAvLyBSZXJvb3Qgc2hvdWxkIG9ubHkgYXBwbHkgdG8gdGhlIHJ1biB3aGVyZSBpdCdzIGV4cGxpY2l0bHkgY29uZmlndXJlZCwgbm90IHByb3BhZ2F0ZSBkb3duXG4gICAgICAgIGNvbnN0IGluaGVyaXRlZFJlcGxpY2FzID0gdGhpcy5yZXBsaWNhcz8ubWFwKChyZXBsaWNhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcm9vdCwgLi4ucmVzdCB9ID0gcmVwbGljYTtcbiAgICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hpbGRSZXBsaWNhcyA9IGNvbmZpZy5yZXBsaWNhcyA/PyBpbmhlcml0ZWRSZXBsaWNhcztcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiB0aGlzLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIHJlcGxpY2FzOiBjaGlsZFJlcGxpY2FzLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiB0aGlzLnRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvcHkgY29udGV4dCB2YXJzIG92ZXIgaW50byB0aGUgbmV3IHJ1biB0cmVlLlxuICAgICAgICBpZiAoX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY2hpbGRbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPVxuICAgICAgICAgICAgICAgIHRoaXNbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgTENfQ0hJTEQgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfY29uZmlnXCIpO1xuICAgICAgICBjb25zdCBwcmVzZW50Q29uZmlnID0gY29uZmlnLmV4dHJhPy5bTENfQ0hJTERdID8/XG4gICAgICAgICAgICB0aGlzLmV4dHJhW0xDX0NISUxEXTtcbiAgICAgICAgLy8gdHJhY2luZyBmb3IgTGFuZ0NoYWluIGlzIGRlZmluZWQgYnkgdGhlIF9wYXJlbnRSdW5JZCBhbmQgcnVuTWFwIG9mIHRoZSB0cmFjZXJcbiAgICAgICAgaWYgKGlzUnVubmFibGVDb25maWdMaWtlKHByZXNlbnRDb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25maWcgPSB7IC4uLnByZXNlbnRDb25maWcgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGlzQ2FsbGJhY2tNYW5hZ2VyTGlrZShuZXdDb25maWcuY2FsbGJhY2tzKVxuICAgICAgICAgICAgICAgID8gbmV3Q29uZmlnLmNhbGxiYWNrcy5jb3B5Py4oKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFyZW50IHJ1biBpZFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2FsbGJhY2tzLCB7IF9wYXJlbnRSdW5JZDogY2hpbGQuaWQgfSk7XG4gICAgICAgICAgICAgICAgLy8gb25seSBwb3B1bGF0ZSBpZiB3ZSdyZSBpbiBhIG5ld2VyIExDLkpTIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgPy5maW5kKGlzTGFuZ0NoYWluVHJhY2VyTGlrZSlcbiAgICAgICAgICAgICAgICAgICAgPy51cGRhdGVGcm9tUnVuVHJlZT8uKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdDb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQuZXh0cmFbTENfQ0hJTERdID0gbmV3Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBjaGlsZF9leGVjdXRpb25fb3JkZXIgdXB3YXJkc1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnQuaWQpKSB7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgoY3VycmVudC5jaGlsZF9leGVjdXRpb25fb3JkZXIsIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRfcnVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRfcnVucy5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBhc3luYyBlbmQob3V0cHV0cywgZXJyb3IsIGVuZFRpbWUgPSBEYXRlLm5vdygpLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm91dHB1dHMgPSB0aGlzLm91dHB1dHMgPz8gb3V0cHV0cztcbiAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMuZXJyb3IgPz8gZXJyb3I7XG4gICAgICAgIHRoaXMuZW5kX3RpbWUgPSB0aGlzLmVuZF90aW1lID8/IGVuZFRpbWU7XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiBPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5leHRyYSA9IHRoaXMuZXh0cmFcbiAgICAgICAgICAgICAgICA/IHsgLi4udGhpcy5leHRyYSwgbWV0YWRhdGE6IHsgLi4udGhpcy5leHRyYS5tZXRhZGF0YSwgLi4ubWV0YWRhdGEgfSB9XG4gICAgICAgICAgICAgICAgOiB7IG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnZlcnRUb0NyZWF0ZShydW4sIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICAvLyBBdm9pZCBvdmVyd3JpdGluZyB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBpZiBpdCdzIGFscmVhZHkgc2V0XG4gICAgICAgIGlmIChydW5FeHRyYT8ucnVudGltZT8ubGlicmFyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVudGltZUVudikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuRXh0cmEucnVudGltZVtrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuRXh0cmEucnVudGltZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkX3J1bnM7XG4gICAgICAgIGxldCBwYXJlbnRfcnVuX2lkO1xuICAgICAgICBpZiAoIWV4Y2x1ZGVDaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBydW4uY2hpbGRfcnVucy5tYXAoKGNoaWxkX3J1bikgPT4gdGhpcy5fY29udmVydFRvQ3JlYXRlKGNoaWxkX3J1biwgcnVudGltZUVudiwgZXhjbHVkZUNoaWxkUnVucykpO1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSBydW4ucGFyZW50X3J1bj8uaWQgPz8gcnVuLnBhcmVudF9ydW5faWQ7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5fc2VyaWFsaXplZF9zdGFydF90aW1lID8/IHJ1bi5zdGFydF90aW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogcnVuLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgZXh0cmE6IHJ1bkV4dHJhLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcnVuLnNlcmlhbGl6ZWQsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHJ1bi5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBjaGlsZF9ydW5zLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBydW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyxcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBydW4uYXR0YWNobWVudHMsXG4gICAgICAgICAgICBldmVudHM6IHJ1bi5ldmVudHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zbGljZVBhcmVudElkKHBhcmVudElkLCBydW4pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNsaWNlIHRoZSBwYXJlbnQgaWQgZnJvbSBkb3R0ZWQgb3JkZXIuXG4gICAgICAgICAqIEFkZGl0aW9uYWxseSBjaGVjayBpZiB0aGUgY3VycmVudCBydW4gaXMgYSBjaGlsZCBvZiB0aGUgcGFyZW50LiBJZiBzbywgdXBkYXRlXG4gICAgICAgICAqIHRoZSBwYXJlbnRfcnVuX2lkIHRvIHVuZGVmaW5lZCwgYW5kIHNldCB0aGUgdHJhY2UgaWQgdG8gdGhlIG5ldyByb290IGlkIGFmdGVyXG4gICAgICAgICAqIHBhcmVudF9pZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChydW4uZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdzID0gcnVuLmRvdHRlZF9vcmRlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICBsZXQgc3RhcnRJZHggPSBudWxsO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBJRCBpbiB0aGUgZG90dGVkIG9yZGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZWdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdJZCA9IHNlZ3NbaWR4XS5zbGljZSgtVElNRVNUQU1QX0xFTkdUSCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ0lkID09PSBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydElkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0SWR4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpbSBzZWdtZW50cyB0byBzdGFydCBhZnRlciBwYXJlbnRfaWQgKGV4Y2x1c2l2ZSlcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkU2VncyA9IHNlZ3Muc2xpY2Uoc3RhcnRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvLyBSZWJ1aWxkIGRvdHRlZF9vcmRlclxuICAgICAgICAgICAgICAgIHJ1bi5kb3R0ZWRfb3JkZXIgPSB0cmltbWVkU2Vncy5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZFNlZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBydW4udHJhY2VfaWQgPSB0cmltbWVkU2Vnc1swXS5zbGljZSgtVElNRVNUQU1QX0xFTkdUSCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydW4udHJhY2VfaWQgPSBydW4uaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ucGFyZW50X3J1bl9pZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGZvdW5kIHRoZSBuZXcgcm9vdCBub2RlLlxuICAgICAgICAgICAgcnVuLnBhcmVudF9ydW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldFJlcGxpY2FUcmFjZVJvb3QocmVwbGljYUtleSwgdHJhY2VSb290SWQpIHtcbiAgICAgICAgLy8gU2V0IHRoZSByZXBsaWNhIHRyYWNlIHJvb3QgaW4gY29udGV4dCB2YXJzIG9uIHRoaXMgcnVuIGFuZCBhbGwgZGVzY2VuZGFudHNcbiAgICAgICAgY29uc3QgcmVwbGljYVRyYWNlUm9vdHMgPSBnZXRDb250ZXh0VmFyKHRoaXMsIF9SRVBMSUNBX1RSQUNFX1JPT1RTX0tFWSkgPz8ge307XG4gICAgICAgIHJlcGxpY2FUcmFjZVJvb3RzW3JlcGxpY2FLZXldID0gdHJhY2VSb290SWQ7XG4gICAgICAgIHNldENvbnRleHRWYXIodGhpcywgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZLCByZXBsaWNhVHJhY2VSb290cyk7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHVwZGF0ZSBhbGwgZGVzY2VuZGFudHMgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIC8vIGFyb3VuZCBydW4gdHJlZSBjcmVhdGlvbiB2cyBwcm9jZXNzaW5nIHRpbWVcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgIGNoaWxkLl9zZXRSZXBsaWNhVHJhY2VSb290KHJlcGxpY2FLZXksIHRyYWNlUm9vdElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVtYXBGb3JQcm9qZWN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3ROYW1lLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSwgcmVyb290ID0gZmFsc2UsIGRpc3RyaWJ1dGVkUGFyZW50SWQsIGFwaVVybCwgYXBpS2V5LCB3b3Jrc3BhY2VJZCwgfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3QgYmFzZVJ1biA9IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKTtcbiAgICAgICAgLy8gU2tpcCByZW1hcHBpbmcgaWYgcHJvamVjdCBuYW1lIGlzIHRoZSBzYW1lXG4gICAgICAgIGlmIChwcm9qZWN0TmFtZSA9PT0gdGhpcy5wcm9qZWN0X25hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZVJ1bixcbiAgICAgICAgICAgICAgICBzZXNzaW9uX25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSByZXJvb3QgbG9naWMgYmVmb3JlIElEIHJlbWFwcGluZ1xuICAgICAgICBpZiAocmVyb290KSB7XG4gICAgICAgICAgICBpZiAoZGlzdHJpYnV0ZWRQYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBkaXN0cmlidXRlZCBwYXJlbnQgSUQsIHNsaWNlIGF0IHRoYXQgcG9pbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9zbGljZVBhcmVudElkKGRpc3RyaWJ1dGVkUGFyZW50SWQsIGJhc2VSdW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZGlzdHJpYnV0ZWQgcGFyZW50IElELCBzaW1wbHkgbWFrZSB0aGlzIHJ1biBhIHJvb3QgcnVuXG4gICAgICAgICAgICAgICAgLy8gYnkgcmVtb3ZpbmcgcGFyZW50X3J1bl9pZCBhbmQgcmVzZXR0aW5nIHRyYWNlIGluZm9cbiAgICAgICAgICAgICAgICBiYXNlUnVuLnBhcmVudF9ydW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBydW4gYXMgdGhlIHRyYWNlIHJvb3RcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVJ1bi5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZG90dGVkIG9yZGVyIHRvIGp1c3QgdGhpcyBydW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VncyA9IGJhc2VSdW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJ1bi5kb3R0ZWRfb3JkZXIgPSBzZWdzW3NlZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUnVuLnRyYWNlX2lkID0gYmFzZVJ1bi5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoaXMgcnVuJ3Mgb3JpZ2luYWwgSUQgaW4gY29udGV4dCB2YXJzIHNvIGRlc2NlbmRhbnRzIGtub3cgdGhlIG5ldyB0cmFjZSByb290XG4gICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgb3JpZ2luYWwgSUQgKGJlZm9yZSByZW1hcHBpbmcpIHNvIGl0IGNhbiBiZSBmb3VuZCBpbiBkb3R0ZWRfb3JkZXJcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FLZXkgPSBnZXRSZXBsaWNhS2V5KHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRSZXBsaWNhVHJhY2VSb290KHJlcGxpY2FLZXksIGJhc2VSdW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGFuY2VzdG9yIHdhcyByZXJvb3RlZCBmb3IgdGhpcyByZXBsaWNhLCB1cGRhdGUgdHJhY2VfaWQgYW5kIGRvdHRlZF9vcmRlclxuICAgICAgICAvLyB0byByZWZsZWN0IHRoZSBuZXcgdHJhY2UgaGllcmFyY2h5LiBUaGlzIGlzIHRyYWNrZWQgdmlhIGNvbnRleHQgdmFyaWFibGVzLlxuICAgICAgICBsZXQgYW5jZXN0b3JSZXJvb3RlZFRyYWNlSWQ7XG4gICAgICAgIGlmICghcmVyb290KSB7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhVHJhY2VSb290cyA9IGdldENvbnRleHRWYXIodGhpcywgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZKSA/PyB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FLZXkgPSBnZXRSZXBsaWNhS2V5KHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZCA9IHJlcGxpY2FUcmFjZVJvb3RzW3JlcGxpY2FLZXldO1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yUmVyb290ZWRUcmFjZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gQW4gYW5jZXN0b3Igd2FzIHJlcm9vdGVkIGZvciB0aGlzIHJlcGxpY2EsIHNvIHNldCBvdXIgdHJhY2VfaWRcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgYW5jZXN0b3IncyBvcmlnaW5hbCAodW5tYXBwZWQpIElELiBJdCB3aWxsIGJlIHJlbWFwcGVkIGFsb25nIHdpdGggb3RoZXIgSURzLlxuICAgICAgICAgICAgICAgIGJhc2VSdW4udHJhY2VfaWQgPSBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZDtcbiAgICAgICAgICAgICAgICAvLyBBbHNvIHNsaWNlIHRoZSBkb3R0ZWRfb3JkZXIgdG8gc3RhcnQgZnJvbSB0aGUgbmV3IHRyYWNlIHJvb3RcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgZGVzY2VuZGFudHMgb2YgYSByZXJvb3RlZCBhbmNlc3RvciBoYXZlIGNvcnJlY3QgaGllcmFyY2h5XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VSdW4uZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ3MgPSBiYXNlUnVuLmRvdHRlZF9vcmRlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb290SWR4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV3IHRyYWNlIHJvb3QncyBzZWdtZW50IGluIGRvdHRlZF9vcmRlclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZWdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ0lkID0gc2Vnc1tpZHhdLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdJZCA9PT0gYW5jZXN0b3JSZXJvb3RlZFRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290SWR4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHNlZ21lbnRzIGZyb20gbmV3IHRyYWNlIHJvb3Qgb253YXJkc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFNlZ3MgPSBzZWdzLnNsaWNlKHJvb3RJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJ1bi5kb3R0ZWRfb3JkZXIgPSB0cmltbWVkU2Vncy5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1hcCBJRHMgZm9yIHRoZSByZXBsaWNhIHVzaW5nIHV1aWQ1IChkZXRlcm1pbmlzdGljKVxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgY29uc2lzdGVuY3kgYWNyb3NzIHJ1bnMgaW4gdGhlIHNhbWUgcmVwbGljYVxuICAgICAgICBjb25zdCBvbGRJZCA9IGJhc2VSdW4uaWQ7XG4gICAgICAgIGNvbnN0IG5ld0lkID0gdXVpZHY1KGAke29sZElkfToke3Byb2plY3ROYW1lfWAsIFVVSURfTkFNRVNQQUNFX0ROUyk7XG4gICAgICAgIC8vIFJlbWFwIHRyYWNlX2lkXG4gICAgICAgIGxldCBuZXdUcmFjZUlkO1xuICAgICAgICBpZiAoYmFzZVJ1bi50cmFjZV9pZCkge1xuICAgICAgICAgICAgbmV3VHJhY2VJZCA9IHV1aWR2NShgJHtiYXNlUnVuLnRyYWNlX2lkfToke3Byb2plY3ROYW1lfWAsIFVVSURfTkFNRVNQQUNFX0ROUyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdUcmFjZUlkID0gbmV3SWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtYXAgcGFyZW50X3J1bl9pZFxuICAgICAgICBsZXQgbmV3UGFyZW50SWQ7XG4gICAgICAgIGlmIChiYXNlUnVuLnBhcmVudF9ydW5faWQpIHtcbiAgICAgICAgICAgIG5ld1BhcmVudElkID0gdXVpZHY1KGAke2Jhc2VSdW4ucGFyZW50X3J1bl9pZH06JHtwcm9qZWN0TmFtZX1gLCBVVUlEX05BTUVTUEFDRV9ETlMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbWFwIGRvdHRlZF9vcmRlciBzZWdtZW50c1xuICAgICAgICBsZXQgbmV3RG90dGVkT3JkZXI7XG4gICAgICAgIGlmIChiYXNlUnVuLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3Qgc2VncyA9IGJhc2VSdW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkU2VncyA9IHNlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBVVUlEIGZyb20gdGhlIHNlZ21lbnQgKGxhc3QgVElNRVNUQU1QX0xFTkdUSCBjaGFyYWN0ZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ0lkID0gc2VnLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1hcHBlZElkID0gdXVpZHY1KGAke3NlZ0lkfToke3Byb2plY3ROYW1lfWAsIFVVSURfTkFNRVNQQUNFX0ROUyk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgVVVJRCBwYXJ0IHdoaWxlIGtlZXBpbmcgdGhlIHRpbWVzdGFtcCBwcmVmaXhcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VnLnNsaWNlKDAsIC1USU1FU1RBTVBfTEVOR1RIKSArIHJlbWFwcGVkSWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld0RvdHRlZE9yZGVyID0gcmVtYXBwZWRTZWdzLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5iYXNlUnVuLFxuICAgICAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IG5ld1RyYWNlSWQsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBuZXdQYXJlbnRJZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogbmV3RG90dGVkT3JkZXIsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwb3N0UnVuKGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIC8vIEFwcGxpZXMgd2hlbiBgcHJvY2Vzc0lucHV0c2AgaXMgYW4gYXN5bmMgZnVuY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuX2F3YWl0SW5wdXRzT25Qb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IGF3YWl0IHRoaXMuaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lRW52ID0gZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBsaWNhcyAmJiB0aGlzLnJlcGxpY2FzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcHJvamVjdE5hbWUsIGFwaUtleSwgYXBpVXJsLCB3b3Jrc3BhY2VJZCwgcmVyb290IH0gb2YgdGhpc1xuICAgICAgICAgICAgICAgICAgICAucmVwbGljYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gdGhpcy5fcmVtYXBGb3JQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBwcm9qZWN0TmFtZSA/PyB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlQ2hpbGRSdW5zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVyb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdHJpYnV0ZWRQYXJlbnRJZDogdGhpcy5kaXN0cmlidXRlZFBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocnVuQ3JlYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGlsZF9ydW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBwb3N0UnVuIGZvciBydW4gJHt0aGlzLmlkfTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGF0Y2hSdW4ob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yZXBsaWNhcyAmJiB0aGlzLnJlcGxpY2FzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9qZWN0TmFtZSwgYXBpS2V5LCBhcGlVcmwsIHdvcmtzcGFjZUlkLCB1cGRhdGVzLCByZXJvb3QsIH0gb2YgdGhpcy5yZXBsaWNhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bkRhdGEgPSB0aGlzLl9yZW1hcEZvclByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogcHJvamVjdE5hbWUgPz8gdGhpcy5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWVFbnY6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUNoaWxkUnVuczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVyb290LFxuICAgICAgICAgICAgICAgICAgICBkaXN0cmlidXRlZFBhcmVudElkOiB0aGlzLmRpc3RyaWJ1dGVkUGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcnVuRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVuRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5fdHlwZTogcnVuRGF0YS5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuRGF0YS5zdGFydF90aW1lLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBydW5EYXRhLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBydW5EYXRhLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBydW5EYXRhLnBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuRGF0YS5zZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW5EYXRhLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgICAgICAgICBlbmRfdGltZTogcnVuRGF0YS5lbmRfdGltZSxcbiAgICAgICAgICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW5EYXRhLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IHJ1bkRhdGEudHJhY2VfaWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogcnVuRGF0YS5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJ1bkRhdGEudGFncyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHJ1bkRhdGEuZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiB0aGlzLmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHRoYXQgaW5wdXRzIGlzIG5vdCBhIGtleSBpbiB0aGUgcnVuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgd2lsbCBvdmVyd3JpdGUgdGhlIHJ1biBjcmVhdGUgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gdHdvIG9wZXJhdGlvbnMgYXJlIG1lcmdlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmV4Y2x1ZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGF5bG9hZC5pbnB1dHMgPSBydW5EYXRhLmlucHV0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudXBkYXRlUnVuKHJ1bkRhdGEuaWQsIHVwZGF0ZVBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5VcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuX3R5cGU6IHRoaXMucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHRoaXMuX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA/PyB0aGlzLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiB0aGlzLnBhcmVudF9ydW4/LmlkID8/IHRoaXMucGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB0aGlzLmV4dHJhLFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogdGhpcy50cmFjZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCB0aGF0IGlucHV0cyBpcyBub3QgYSBrZXkgaW4gdGhlIHJ1biB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiBleGNsdWRlZCBiZWNhdXNlIGl0IHdpbGwgb3ZlcndyaXRlIHRoZSBydW4gY3JlYXRlIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHR3byBvcGVyYXRpb25zIGFyZSBtZXJnZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zPy5leGNsdWRlSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZGF0ZS5pbnB1dHMgPSB0aGlzLmlucHV0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudXBkYXRlUnVuKHRoaXMuaWQsIHJ1blVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBwYXRjaFJ1biBmb3IgcnVuICR7dGhpcy5pZH1gLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zID0gW107XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IHRvIHRoZSBydW4gdHJlZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBBIHNpbmdsZSBldmVudCBvciBzdHJpbmcgdG8gYWRkXG4gICAgICovXG4gICAgYWRkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICB0aW1lOiBldmVudC50aW1lID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUnVubmFibGVDb25maWcocGFyZW50Q29uZmlnLCBwcm9wcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhbmRsZSB0aGUgY2FsbGJhY2sgbWFuYWdlciBjYXNlIGZvciBub3dcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gcGFyZW50Q29uZmlnPy5jYWxsYmFja3M7XG4gICAgICAgIGxldCBwYXJlbnRSdW47XG4gICAgICAgIGxldCBwcm9qZWN0TmFtZTtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgbGV0IHRyYWNpbmdFbmFibGVkID0gaXNUcmFjaW5nRW5hYmxlZCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQ/LigpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgIHBhcmVudFJ1biA9IGxhbmdDaGFpblRyYWNlcj8uZ2V0UnVuPy4ocGFyZW50UnVuSWQpO1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgPSBsYW5nQ2hhaW5UcmFjZXI/LnByb2plY3ROYW1lO1xuICAgICAgICAgICAgY2xpZW50ID0gbGFuZ0NoYWluVHJhY2VyPy5jbGllbnQ7XG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdFbmFibGVkIHx8ICEhbGFuZ0NoYWluVHJhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmVudFJ1bi5uYW1lLFxuICAgICAgICAgICAgaWQ6IHBhcmVudFJ1bi5pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBwYXJlbnRSdW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB0YWdzOiBbXG4gICAgICAgICAgICAgICAgLi4ubmV3IFNldCgocGFyZW50UnVuPy50YWdzID8/IFtdKS5jb25jYXQocGFyZW50Q29uZmlnPy50YWdzID8/IFtdKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRSdW4/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50Q29uZmlnPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW5UcmVlLmNyZWF0ZUNoaWxkKHByb3BzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Eb3R0ZWRPcmRlcihkb3R0ZWRPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGVhZGVycyh7IFwibGFuZ3NtaXRoLXRyYWNlXCI6IGRvdHRlZE9yZGVyIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcnMoaGVhZGVycywgaW5oZXJpdEFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmF3SGVhZGVycyA9IFwiZ2V0XCIgaW4gaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogaGVhZGVycy5nZXQoXCJsYW5nc21pdGgtdHJhY2VcIiksXG4gICAgICAgICAgICAgICAgYmFnZ2FnZTogaGVhZGVycy5nZXQoXCJiYWdnYWdlXCIpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBoZWFkZXJzO1xuICAgICAgICBjb25zdCBoZWFkZXJUcmFjZSA9IHJhd0hlYWRlcnNbXCJsYW5nc21pdGgtdHJhY2VcIl07XG4gICAgICAgIGlmICghaGVhZGVyVHJhY2UgfHwgdHlwZW9mIGhlYWRlclRyYWNlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50RG90dGVkT3JkZXIgPSBoZWFkZXJUcmFjZS50cmltKCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZERvdHRlZE9yZGVyID0gcGFyZW50RG90dGVkT3JkZXIuc3BsaXQoXCIuXCIpLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0clRpbWUsIHV1aWRdID0gcGFydC5zcGxpdChcIlpcIik7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJUaW1lLCB0aW1lOiBEYXRlLnBhcnNlKHN0clRpbWUgKyBcIlpcIiksIHV1aWQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSBwYXJzZWREb3R0ZWRPcmRlclswXS51dWlkO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5pbmhlcml0QXJncyxcbiAgICAgICAgICAgIG5hbWU6IGluaGVyaXRBcmdzPy5bXCJuYW1lXCJdID8/IFwicGFyZW50XCIsXG4gICAgICAgICAgICBydW5fdHlwZTogaW5oZXJpdEFyZ3M/LltcInJ1bl90eXBlXCJdID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IGluaGVyaXRBcmdzPy5bXCJzdGFydF90aW1lXCJdID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBpZDogcGFyc2VkRG90dGVkT3JkZXIuYXQoLTEpPy51dWlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudERvdHRlZE9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gJiYgdHlwZW9mIHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBiYWdnYWdlID0gQmFnZ2FnZS5mcm9tSGVhZGVyKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdKTtcbiAgICAgICAgICAgIGNvbmZpZy5tZXRhZGF0YSA9IGJhZ2dhZ2UubWV0YWRhdGE7XG4gICAgICAgICAgICBjb25maWcudGFncyA9IGJhZ2dhZ2UudGFncztcbiAgICAgICAgICAgIGNvbmZpZy5wcm9qZWN0X25hbWUgPSBiYWdnYWdlLnByb2plY3RfbmFtZTtcbiAgICAgICAgICAgIGNvbmZpZy5yZXBsaWNhcyA9IGJhZ2dhZ2UucmVwbGljYXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuVHJlZSA9IG5ldyBSdW5UcmVlKGNvbmZpZyk7XG4gICAgICAgIC8vIFNldCB0aGUgZGlzdHJpYnV0ZWQgcGFyZW50IElEIHRvIHRoaXMgcnVuJ3MgSUQgZm9yIHJlcm9vdGluZ1xuICAgICAgICBydW5UcmVlLmRpc3RyaWJ1dGVkUGFyZW50SWQgPSBydW5UcmVlLmlkO1xuICAgICAgICByZXR1cm4gcnVuVHJlZTtcbiAgICB9XG4gICAgdG9IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBiYWdnYWdlOiBuZXcgQmFnZ2FnZSh0aGlzLmV4dHJhPy5tZXRhZGF0YSwgdGhpcy50YWdzLCB0aGlzLnByb2plY3RfbmFtZSwgdGhpcy5yZXBsaWNhcykudG9IZWFkZXIoKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5UcmVlLCBcInNoYXJlZENsaWVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IG51bGxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUnVuVHJlZSh4KSB7XG4gICAgcmV0dXJuICh4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHguY3JlYXRlQ2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgeC5wb3N0UnVuID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHgubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoeCkgJiYgeC5zb21lKChjYWxsYmFjaykgPT4gaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKGNhbGxiYWNrKSkpO1xufVxuZnVuY3Rpb24gaXNDYWxsYmFja01hbmFnZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHguaGFuZGxlcnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlQ29uZmlnTGlrZSh4KSB7XG4gICAgLy8gQ2hlY2sgdGhhdCBpdCdzIGFuIG9iamVjdCB3aXRoIGEgY2FsbGJhY2tzIGFyZ1xuICAgIC8vIHRoYXQgaGFzIGVpdGhlciBhIENhbGxiYWNrTWFuYWdlckxpa2Ugb2JqZWN0IHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyIHdpdGhpbiBpdFxuICAgIC8vIG9yIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICBjb25zdCBjYWxsYmFja3MgPSB4Py5jYWxsYmFja3M7XG4gICAgcmV0dXJuICh4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAvLyBDYWxsYmFjayBtYW5hZ2VyIHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2tzPy5oYW5kbGVycykgfHxcbiAgICAgICAgICAgIC8vIE9yIGl0J3MgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgICAgICAgICAgY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKGNhbGxiYWNrcykpKTtcbn1cbmZ1bmN0aW9uIF9nZXRXcml0ZVJlcGxpY2FzRnJvbUVudigpIHtcbiAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTXCIpO1xuICAgIGlmICghZW52VmFyKVxuICAgICAgICByZXR1cm4gW107XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShlbnZWYXIpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIiB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBpdGVtIHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBvYmplY3QsIGdvdCAke3R5cGVvZiBpdGVtfWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmFwaV91cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGFwaV91cmwgdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIGl0ZW0uYXBpX3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5hcGlfa2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBhcGlfa2V5IHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBpdGVtLmFwaV9rZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsaWNhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBpdGVtLmFwaV91cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IGl0ZW0uYXBpX2tleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2NoZWNrRW5kcG9pbnRFbnZVbnNldChwYXJzZWQpO1xuICAgICAgICAgICAgY29uc3QgcmVwbGljYXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3VybCwga2V5XSBvZiBPYmplY3QuZW50cmllcyhwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5VcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxpY2FzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBjbGVhblVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCB2YWx1ZSB0eXBlIGluIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyBmb3IgVVJMICR7dXJsfTogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbGljYXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyDigJMgbXVzdCBiZSB2YWxpZCBKU09OIGFycmF5IG9mIFwiICtcbiAgICAgICAgICAgICAgICBgb2JqZWN0cyB3aXRoIGFwaV91cmwgYW5kIGFwaV9rZXkgcHJvcGVydGllcywgb3Igb2JqZWN0IG1hcHBpbmcgdXJsLT5hcGlLZXksIGdvdCAke3R5cGVvZiBwYXJzZWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvcihlKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyDigJMgbXVzdCBiZSB2YWxpZCBKU09OIGFycmF5IG9mIFwiICtcbiAgICAgICAgICAgIFwib2JqZWN0cyB3aXRoIGFwaV91cmwgYW5kIGFwaV9rZXkgcHJvcGVydGllcywgb3Igb2JqZWN0IG1hcHBpbmcgdXJsLT5hcGlLZXlcIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZW5zdXJlV3JpdGVSZXBsaWNhcyhyZXBsaWNhcykge1xuICAgIC8vIElmIG51bGwgLT4gZmV0Y2ggZnJvbSBlbnZcbiAgICBpZiAocmVwbGljYXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxpY2FzLm1hcCgocmVwbGljYSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGljYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogcmVwbGljYVswXSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlczogcmVwbGljYVsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxpY2E7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2dldFdyaXRlUmVwbGljYXNGcm9tRW52KCk7XG59XG5mdW5jdGlvbiBfY2hlY2tFbmRwb2ludEVudlVuc2V0KHBhcnNlZCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CHILD_RUN_END_PROMISES_KEY: () => (/* binding */ _LC_CHILD_RUN_END_PROMISES_KEY),\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY),\n/* harmony export */   _REPLICA_TRACE_ROOTS_KEY: () => (/* binding */ _REPLICA_TRACE_ROOTS_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst _LC_CHILD_RUN_END_PROMISES_KEY = Symbol.for(\"lc:child_run_end_promises\");\nconst _REPLICA_TRACE_ROOTS_KEY = Symbol.for(\"langsmith:replica_trace_roots\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanM/MTBjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjb250ZXh0X3ZhcmlhYmxlc1wiKTtcbmV4cG9ydCBjb25zdCBfTENfQ0hJTERfUlVOX0VORF9QUk9NSVNFU19LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfcnVuX2VuZF9wcm9taXNlc1wiKTtcbmV4cG9ydCBjb25zdCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVkgPSBTeW1ib2wuZm9yKFwibGFuZ3NtaXRoOnJlcGxpY2FfdHJhY2Vfcm9vdHNcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   _globalFetchImplementationIsNodeFetch: () => (/* binding */ _globalFetchImplementationIsNodeFetch),\n/* harmony export */   clearFetchImplementation: () => (/* binding */ clearFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\nconst clearFetchImplementation = () => {\n    delete globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n};\nconst _globalFetchImplementationIsNodeFetch = () => {\n    const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n    if (!fetchImpl)\n        return false;\n    // Check if the implementation has node-fetch specific properties\n    return (typeof fetchImpl === \"function\" &&\n        \"Headers\" in fetchImpl &&\n        \"Request\" in fetchImpl &&\n        \"Response\" in fetchImpl);\n};\n/**\n * @internal\n */\nconst _getFetchImplementation = (debug) => {\n    return async (...args) => {\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            const [url, options] = args;\n            console.log(` ${options?.method || \"GET\"} ${url}`);\n        }\n        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n            DEFAULT_FETCH_IMPLEMENTATION)(...args);\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            console.log(` ${res.status} ${res.statusText} ${res.url}`);\n        }\n        return res;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsOEVBQStCO0FBQ3BEO0FBQ0EsNkJBQTZCLDBCQUEwQixFQUFFLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhFQUErQjtBQUNwRCw2QkFBNkIsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2ZldGNoLmpzPzFkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbi8vIFdyYXAgdGhlIGRlZmF1bHQgZmV0Y2ggY2FsbCBkdWUgdG8gaXNzdWVzIHdpdGggaWxsZWdhbCBpbnZvY2F0aW9uc1xuLy8gaW4gc29tZSBlbnZpcm9ubWVudHM6XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82OTg3Njg1OS93aHktZG9lcy1iaW5kLWZpeC1mYWlsZWQtdG8tZXhlY3V0ZS1mZXRjaC1vbi13aW5kb3ctaWxsZWdhbC1pbnZvY2F0aW9uLWVyclxuLy8gQHRzLWV4cGVjdC1lcnJvciBCcm9hZCB0eXBpbmcgdG8gc3VwcG9ydCBhIHJhbmdlIG9mIGZldGNoIGltcGxlbWVudGF0aW9uc1xuY29uc3QgREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbmNvbnN0IExBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkgPSBTeW1ib2wuZm9yKFwibHM6ZmV0Y2hfaW1wbGVtZW50YXRpb25cIik7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdXNlZCBmb3IgTGFuZ1NtaXRoIGNhbGxzLlxuICogWW91IHNob3VsZCB1c2UgdGhpcyBpZiB5b3UgbmVlZCB0byB1c2UgYW4gaW1wbGVtZW50YXRpb24gb2YgZmV0Y2hcbiAqIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgZ2xvYmFsIChlLmcuIGZvciBkZWFsaW5nIHdpdGggcHJveGllcykuXG4gKiBAcGFyYW0gZmV0Y2ggVGhlIG5ldyBmZXRjaCBmdW5jdGlubyB0byB1c2UuXG4gKi9cbmV4cG9ydCBjb25zdCBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gPSAoZmV0Y2gpID0+IHtcbiAgICBnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID0gZmV0Y2g7XG59O1xuZXhwb3J0IGNvbnN0IGNsZWFyRmV0Y2hJbXBsZW1lbnRhdGlvbiA9ICgpID0+IHtcbiAgICBkZWxldGUgZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXTtcbn07XG5leHBvcnQgY29uc3QgX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCA9ICgpID0+IHtcbiAgICBjb25zdCBmZXRjaEltcGwgPSBnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldO1xuICAgIGlmICghZmV0Y2hJbXBsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGltcGxlbWVudGF0aW9uIGhhcyBub2RlLWZldGNoIHNwZWNpZmljIHByb3BlcnRpZXNcbiAgICByZXR1cm4gKHR5cGVvZiBmZXRjaEltcGwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBcIkhlYWRlcnNcIiBpbiBmZXRjaEltcGwgJiZcbiAgICAgICAgXCJSZXF1ZXN0XCIgaW4gZmV0Y2hJbXBsICYmXG4gICAgICAgIFwiUmVzcG9uc2VcIiBpbiBmZXRjaEltcGwpO1xufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChkZWJ1ZykgPT4ge1xuICAgIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZGVidWcgfHwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkRFQlVHXCIpID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgY29uc3QgW3VybCwgb3B0aW9uc10gPSBhcmdzO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKGkiAke29wdGlvbnM/Lm1ldGhvZCB8fCBcIkdFVFwifSAke3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCAoZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXSA/P1xuICAgICAgICAgICAgREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTikoLi4uYXJncyk7XG4gICAgICAgIGlmIChkZWJ1ZyB8fCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiREVCVUdcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4oaQICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gJHtyZXMudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/otel.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/otel.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTELProviderSingleton: () => (/* binding */ OTELProviderSingleton),\n/* harmony export */   getDefaultOTLPTracerComponents: () => (/* binding */ getDefaultOTLPTracerComponents),\n/* harmony export */   getOTELContext: () => (/* binding */ getOTELContext),\n/* harmony export */   getOTELTrace: () => (/* binding */ getOTELTrace),\n/* harmony export */   setDefaultOTLPTracerComponents: () => (/* binding */ setDefaultOTLPTracerComponents),\n/* harmony export */   setOTELInstances: () => (/* binding */ setOTELInstances)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n// Should not import any OTEL packages to avoid pulling in optional deps.\n\nclass MockTracer {\n    constructor() {\n        Object.defineProperty(this, \"hasWarned\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    startActiveSpan(_name, ...args) {\n        if (!this.hasWarned && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getOtelEnabled)()) {\n            console.warn(\"You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. \" +\n                'Please add:\\n```\\nimport { initializeOTEL } from \"langsmith/experimental/otel/setup\";\\ninitializeOTEL();\\n```\\nat the beginning of your code.');\n            this.hasWarned = true;\n        }\n        // Handle different overloads:\n        // startActiveSpan(name, fn)\n        // startActiveSpan(name, options, fn)\n        // startActiveSpan(name, options, context, fn)\n        let fn;\n        if (args.length === 1 && typeof args[0] === \"function\") {\n            fn = args[0];\n        }\n        else if (args.length === 2 && typeof args[1] === \"function\") {\n            fn = args[1];\n        }\n        else if (args.length === 3 && typeof args[2] === \"function\") {\n            fn = args[2];\n        }\n        if (typeof fn === \"function\") {\n            return fn();\n        }\n        return undefined;\n    }\n}\nclass MockOTELTrace {\n    constructor() {\n        Object.defineProperty(this, \"mockTracer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockTracer()\n        });\n    }\n    getTracer(_name, _version) {\n        return this.mockTracer;\n    }\n    getActiveSpan() {\n        return undefined;\n    }\n    setSpan(context, _span) {\n        return context;\n    }\n    getSpan(_context) {\n        return undefined;\n    }\n    setSpanContext(context, _spanContext) {\n        return context;\n    }\n    getTracerProvider() {\n        return undefined;\n    }\n    setGlobalTracerProvider(_tracerProvider) {\n        return false;\n    }\n}\nclass MockOTELContext {\n    active() {\n        return {};\n    }\n    with(_context, fn) {\n        return fn();\n    }\n}\nconst OTEL_TRACE_KEY = Symbol.for(\"ls:otel_trace\");\nconst OTEL_CONTEXT_KEY = Symbol.for(\"ls:otel_context\");\nconst OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for(\"ls:otel_get_default_otlp_tracer_provider\");\nconst mockOTELTrace = new MockOTELTrace();\nconst mockOTELContext = new MockOTELContext();\nclass OTELProvider {\n    getTraceInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;\n    }\n    getContextInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;\n    }\n    initializeGlobalInstances(otel) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_TRACE_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_TRACE_KEY] = otel.trace;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_CONTEXT_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_CONTEXT_KEY] = otel.context;\n        }\n    }\n    setDefaultOTLPTracerComponents(components) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;\n    }\n    getDefaultOTLPTracerComponents() {\n        return (globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ??\n            undefined);\n    }\n}\nconst OTELProviderSingleton = new OTELProvider();\n/**\n * Get the current OTEL trace instance.\n * Returns a mock implementation if OTEL is not available.\n */\nfunction getOTELTrace() {\n    return OTELProviderSingleton.getTraceInstance();\n}\n/**\n * Get the current OTEL context instance.\n * Returns a mock implementation if OTEL is not available.\n */\nfunction getOTELContext() {\n    return OTELProviderSingleton.getContextInstance();\n}\n/**\n * Initialize the global OTEL instances.\n * Should be called once when OTEL packages are available.\n */\nfunction setOTELInstances(otel) {\n    OTELProviderSingleton.initializeGlobalInstances(otel);\n}\n/**\n * Set a getter function for the default OTLP tracer provider.\n * This allows lazy initialization of the tracer provider.\n */\nfunction setDefaultOTLPTracerComponents(components) {\n    OTELProviderSingleton.setDefaultOTLPTracerComponents(components);\n}\n/**\n * Get the default OTLP tracer provider instance.\n * Returns undefined if not set.\n */\nfunction getDefaultOTLPTracerComponents() {\n    return OTELProviderSingleton.getDefaultOTLPTracerComponents();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCLDZEQUFjO0FBQzdDO0FBQ0EsNENBQTRDLGlCQUFpQix5Q0FBeUMsbUJBQW1CO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzPzgzOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hvdWxkIG5vdCBpbXBvcnQgYW55IE9URUwgcGFja2FnZXMgdG8gYXZvaWQgcHVsbGluZyBpbiBvcHRpb25hbCBkZXBzLlxuaW1wb3J0IHsgZ2V0T3RlbEVuYWJsZWQgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG5jbGFzcyBNb2NrVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzV2FybmVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRBY3RpdmVTcGFuKF9uYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNXYXJuZWQgJiYgZ2V0T3RlbEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGhhdmUgZW5hYmxlZCBPVEVMIGV4cG9ydCB2aWEgdGhlIGBPVEVMX0VOQUJMRURgIG9yIGBMQU5HU01JVEhfT1RFTF9FTkFCTEVEYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgYnV0IGhhdmUgbm90IGluaXRpYWxpemVkIHRoZSByZXF1aXJlZCBPVEVMIGluc3RhbmNlcy4gXCIgK1xuICAgICAgICAgICAgICAgICdQbGVhc2UgYWRkOlxcbmBgYFxcbmltcG9ydCB7IGluaXRpYWxpemVPVEVMIH0gZnJvbSBcImxhbmdzbWl0aC9leHBlcmltZW50YWwvb3RlbC9zZXR1cFwiO1xcbmluaXRpYWxpemVPVEVMKCk7XFxuYGBgXFxuYXQgdGhlIGJlZ2lubmluZyBvZiB5b3VyIGNvZGUuJyk7XG4gICAgICAgICAgICB0aGlzLmhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCBvdmVybG9hZHM6XG4gICAgICAgIC8vIHN0YXJ0QWN0aXZlU3BhbihuYW1lLCBmbilcbiAgICAgICAgLy8gc3RhcnRBY3RpdmVTcGFuKG5hbWUsIG9wdGlvbnMsIGZuKVxuICAgICAgICAvLyBzdGFydEFjdGl2ZVNwYW4obmFtZSwgb3B0aW9ucywgY29udGV4dCwgZm4pXG4gICAgICAgIGxldCBmbjtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbiA9IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGFyZ3NbMl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4gPSBhcmdzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBNb2NrT1RFTFRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9ja1RyYWNlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1vY2tUcmFjZXIoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhY2VyKF9uYW1lLCBfdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2NrVHJhY2VyO1xuICAgIH1cbiAgICBnZXRBY3RpdmVTcGFuKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRTcGFuKGNvbnRleHQsIF9zcGFuKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBnZXRTcGFuKF9jb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldFNwYW5Db250ZXh0KGNvbnRleHQsIF9zcGFuQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZ2V0VHJhY2VyUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldEdsb2JhbFRyYWNlclByb3ZpZGVyKF90cmFjZXJQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgTW9ja09URUxDb250ZXh0IHtcbiAgICBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgd2l0aChfY29udGV4dCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxufVxuY29uc3QgT1RFTF9UUkFDRV9LRVkgPSBTeW1ib2wuZm9yKFwibHM6b3RlbF90cmFjZVwiKTtcbmNvbnN0IE9URUxfQ09OVEVYVF9LRVkgPSBTeW1ib2wuZm9yKFwibHM6b3RlbF9jb250ZXh0XCIpO1xuY29uc3QgT1RFTF9HRVRfREVGQVVMVF9PVExQX1RSQUNFUl9QUk9WSURFUl9LRVkgPSBTeW1ib2wuZm9yKFwibHM6b3RlbF9nZXRfZGVmYXVsdF9vdGxwX3RyYWNlcl9wcm92aWRlclwiKTtcbmNvbnN0IG1vY2tPVEVMVHJhY2UgPSBuZXcgTW9ja09URUxUcmFjZSgpO1xuY29uc3QgbW9ja09URUxDb250ZXh0ID0gbmV3IE1vY2tPVEVMQ29udGV4dCgpO1xuY2xhc3MgT1RFTFByb3ZpZGVyIHtcbiAgICBnZXRUcmFjZUluc3RhbmNlKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1tPVEVMX1RSQUNFX0tFWV0gPz8gbW9ja09URUxUcmFjZTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dEluc3RhbmNlKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1tPVEVMX0NPTlRFWFRfS0VZXSA/PyBtb2NrT1RFTENvbnRleHQ7XG4gICAgfVxuICAgIGluaXRpYWxpemVHbG9iYWxJbnN0YW5jZXMob3RlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpZiAoZ2xvYmFsVGhpc1tPVEVMX1RSQUNFX0tFWV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGdsb2JhbFRoaXNbT1RFTF9UUkFDRV9LRVldID0gb3RlbC50cmFjZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpZiAoZ2xvYmFsVGhpc1tPVEVMX0NPTlRFWFRfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tPVEVMX0NPTlRFWFRfS0VZXSA9IG90ZWwuY29udGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBnbG9iYWxUaGlzW09URUxfR0VUX0RFRkFVTFRfT1RMUF9UUkFDRVJfUFJPVklERVJfS0VZXSA9IGNvbXBvbmVudHM7XG4gICAgfVxuICAgIGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpIHtcbiAgICAgICAgcmV0dXJuIChnbG9iYWxUaGlzW09URUxfR0VUX0RFRkFVTFRfT1RMUF9UUkFDRVJfUFJPVklERVJfS0VZXSA/P1xuICAgICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgT1RFTFByb3ZpZGVyU2luZ2xldG9uID0gbmV3IE9URUxQcm92aWRlcigpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgT1RFTCB0cmFjZSBpbnN0YW5jZS5cbiAqIFJldHVybnMgYSBtb2NrIGltcGxlbWVudGF0aW9uIGlmIE9URUwgaXMgbm90IGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9URUxUcmFjZSgpIHtcbiAgICByZXR1cm4gT1RFTFByb3ZpZGVyU2luZ2xldG9uLmdldFRyYWNlSW5zdGFuY2UoKTtcbn1cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IE9URUwgY29udGV4dCBpbnN0YW5jZS5cbiAqIFJldHVybnMgYSBtb2NrIGltcGxlbWVudGF0aW9uIGlmIE9URUwgaXMgbm90IGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9URUxDb250ZXh0KCkge1xuICAgIHJldHVybiBPVEVMUHJvdmlkZXJTaW5nbGV0b24uZ2V0Q29udGV4dEluc3RhbmNlKCk7XG59XG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBPVEVMIGluc3RhbmNlcy5cbiAqIFNob3VsZCBiZSBjYWxsZWQgb25jZSB3aGVuIE9URUwgcGFja2FnZXMgYXJlIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE9URUxJbnN0YW5jZXMob3RlbCkge1xuICAgIE9URUxQcm92aWRlclNpbmdsZXRvbi5pbml0aWFsaXplR2xvYmFsSW5zdGFuY2VzKG90ZWwpO1xufVxuLyoqXG4gKiBTZXQgYSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBkZWZhdWx0IE9UTFAgdHJhY2VyIHByb3ZpZGVyLlxuICogVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBvZiB0aGUgdHJhY2VyIHByb3ZpZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgICBPVEVMUHJvdmlkZXJTaW5nbGV0b24uc2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKGNvbXBvbmVudHMpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgT1RMUCB0cmFjZXIgcHJvdmlkZXIgaW5zdGFuY2UuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3Qgc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKCkge1xuICAgIHJldHVybiBPVEVMUHJvdmlkZXJTaW5nbGV0b24uZ2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/otel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nfunction getCurrentRunTree(permitAbsentRunTree = false) {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!permitAbsentRunTree && runTree === undefined) {\n        throw new Error(\"Could not get the current run tree.\\n\\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.\");\n    }\n    return runTree;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject) => {\n        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL3RyYWNlYWJsZS5qcz9hMWE5Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE1vY2tBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJ1bihfLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBUUkFDSU5HX0FMU19LRVkgPSBTeW1ib2wuZm9yKFwibHM6dHJhY2luZ19hc3luY19sb2NhbF9zdG9yYWdlXCIpO1xuY29uc3QgbW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tBc3luY0xvY2FsU3RvcmFnZSgpO1xuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPz8gbW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFJ1blRyZWUocGVybWl0QWJzZW50UnVuVHJlZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcnVuVHJlZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5nZXRTdG9yZSgpO1xuICAgIGlmICghcGVybWl0QWJzZW50UnVuVHJlZSAmJiBydW5UcmVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCB0aGUgY3VycmVudCBydW4gdHJlZS5cXG5cXG5QbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoaW4gYSB0cmFjZWFibGUgZnVuY3Rpb24gYW5kIHRoYXQgdHJhY2luZyBpcyBlbmFibGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1blRyZWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhSdW5UcmVlKHJ1blRyZWUsIGZuKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzdG9yYWdlLnJ1bihydW5UcmVlLCAoKSA9PiB2b2lkIFByb21pc2UucmVzb2x2ZShmbigpKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFJPT1QgPSBTeW1ib2wuZm9yKFwibGFuZ3NtaXRoOnRyYWNlYWJsZTpyb290XCIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2VhYmxlRnVuY3Rpb24oeFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiICYmIFwibGFuZ3NtaXRoOnRyYWNlYWJsZVwiIGluIHg7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid),\n/* harmony export */   getUuidVersion: () => (/* binding */ getUuidVersion),\n/* harmony export */   uuid7FromTime: () => (/* binding */ uuid7FromTime),\n/* harmony export */   warnIfNotUuidV7: () => (/* binding */ warnIfNotUuidV7)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _warn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./warn.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js\");\n// Relaxed UUID validation regex (allows any valid UUID format including nil UUIDs)\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\n\nlet UUID7_WARNING_EMITTED = false;\nfunction assertUuid(str, which) {\n    // Use relaxed regex validation instead of strict uuid.validate()\n    // This allows edge cases like nil UUIDs or test UUIDs that might not pass strict validation\n    if (!UUID_REGEX.test(str)) {\n        const msg = which !== undefined\n            ? `Invalid UUID for ${which}: ${str}`\n            : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n/**\n * Generate a UUID v7 from a timestamp.\n *\n * @param timestamp - The timestamp in milliseconds\n * @returns A UUID v7 string\n */\nfunction uuid7FromTime(timestamp) {\n    const msecs = typeof timestamp === \"string\" ? Date.parse(timestamp) : timestamp;\n    // Work around uuid@10 behavior where providing only { msecs }\n    // may not set the internal timestamp used for stringification.\n    // Providing a seq ensures the implementation updates its internal state\n    // and encodes the provided milliseconds into the UUID bytes.\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({ msecs, seq: 0 });\n}\n/**\n * Get the version of a UUID string.\n * @param uuidStr - The UUID string to check\n * @returns The version number (1-7) or null if invalid\n */\nfunction getUuidVersion(uuidStr) {\n    if (!UUID_REGEX.test(uuidStr)) {\n        return null;\n    }\n    // Version is in bits 48-51\n    // Format: xxxxxxxx-xxxx-Vxxx-xxxx-xxxxxxxxxxxx\n    const versionChar = uuidStr[14];\n    return parseInt(versionChar, 16);\n}\n/**\n * Warn if a UUID is not version 7.\n *\n * @param uuidStr - The UUID string to check\n * @param idType - The type of ID (e.g., \"run_id\", \"trace_id\") for the warning message\n */\nfunction warnIfNotUuidV7(uuidStr, _idType) {\n    const version = getUuidVersion(uuidStr);\n    if (version !== null && version !== 7 && !UUID7_WARNING_EMITTED) {\n        UUID7_WARNING_EMITTED = true;\n        (0,_warn_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)(`LangSmith now uses UUID v7 for run and trace identifiers. ` +\n            `This warning appears when passing custom IDs. ` +\n            `Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); ` +\n            `Future versions will require UUID v7.`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDN0M7QUFDQztBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTSxJQUFJLElBQUk7QUFDaEQsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQU0sR0FBRyxlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBUTtBQUNoQjtBQUNBLGtDQUFrQyxTQUFTLGtCQUFrQixxQkFBcUI7QUFDbEY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanM/ZTUyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWxheGVkIFVVSUQgdmFsaWRhdGlvbiByZWdleCAoYWxsb3dzIGFueSB2YWxpZCBVVUlEIGZvcm1hdCBpbmNsdWRpbmcgbmlsIFVVSURzKVxuY29uc3QgVVVJRF9SRUdFWCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC9pO1xuaW1wb3J0IHsgdjcgYXMgdXVpZHY3IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vd2Fybi5qc1wiO1xubGV0IFVVSUQ3X1dBUk5JTkdfRU1JVFRFRCA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFV1aWQoc3RyLCB3aGljaCkge1xuICAgIC8vIFVzZSByZWxheGVkIHJlZ2V4IHZhbGlkYXRpb24gaW5zdGVhZCBvZiBzdHJpY3QgdXVpZC52YWxpZGF0ZSgpXG4gICAgLy8gVGhpcyBhbGxvd3MgZWRnZSBjYXNlcyBsaWtlIG5pbCBVVUlEcyBvciB0ZXN0IFVVSURzIHRoYXQgbWlnaHQgbm90IHBhc3Mgc3RyaWN0IHZhbGlkYXRpb25cbiAgICBpZiAoIVVVSURfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHdoaWNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYEludmFsaWQgVVVJRCBmb3IgJHt3aGljaH06ICR7c3RyfWBcbiAgICAgICAgICAgIDogYEludmFsaWQgVVVJRDogJHtzdHJ9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgVVVJRCB2NyBmcm9tIGEgdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgQSBVVUlEIHY3IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZDdGcm9tVGltZSh0aW1lc3RhbXApIHtcbiAgICBjb25zdCBtc2VjcyA9IHR5cGVvZiB0aW1lc3RhbXAgPT09IFwic3RyaW5nXCIgPyBEYXRlLnBhcnNlKHRpbWVzdGFtcCkgOiB0aW1lc3RhbXA7XG4gICAgLy8gV29yayBhcm91bmQgdXVpZEAxMCBiZWhhdmlvciB3aGVyZSBwcm92aWRpbmcgb25seSB7IG1zZWNzIH1cbiAgICAvLyBtYXkgbm90IHNldCB0aGUgaW50ZXJuYWwgdGltZXN0YW1wIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbi5cbiAgICAvLyBQcm92aWRpbmcgYSBzZXEgZW5zdXJlcyB0aGUgaW1wbGVtZW50YXRpb24gdXBkYXRlcyBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyBhbmQgZW5jb2RlcyB0aGUgcHJvdmlkZWQgbWlsbGlzZWNvbmRzIGludG8gdGhlIFVVSUQgYnl0ZXMuXG4gICAgcmV0dXJuIHV1aWR2Nyh7IG1zZWNzLCBzZXE6IDAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgdmVyc2lvbiBvZiBhIFVVSUQgc3RyaW5nLlxuICogQHBhcmFtIHV1aWRTdHIgLSBUaGUgVVVJRCBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIFRoZSB2ZXJzaW9uIG51bWJlciAoMS03KSBvciBudWxsIGlmIGludmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFV1aWRWZXJzaW9uKHV1aWRTdHIpIHtcbiAgICBpZiAoIVVVSURfUkVHRVgudGVzdCh1dWlkU3RyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVmVyc2lvbiBpcyBpbiBiaXRzIDQ4LTUxXG4gICAgLy8gRm9ybWF0OiB4eHh4eHh4eC14eHh4LVZ4eHgteHh4eC14eHh4eHh4eHh4eHhcbiAgICBjb25zdCB2ZXJzaW9uQ2hhciA9IHV1aWRTdHJbMTRdO1xuICAgIHJldHVybiBwYXJzZUludCh2ZXJzaW9uQ2hhciwgMTYpO1xufVxuLyoqXG4gKiBXYXJuIGlmIGEgVVVJRCBpcyBub3QgdmVyc2lvbiA3LlxuICpcbiAqIEBwYXJhbSB1dWlkU3RyIC0gVGhlIFVVSUQgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcGFyYW0gaWRUeXBlIC0gVGhlIHR5cGUgb2YgSUQgKGUuZy4sIFwicnVuX2lkXCIsIFwidHJhY2VfaWRcIikgZm9yIHRoZSB3YXJuaW5nIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm5JZk5vdFV1aWRWNyh1dWlkU3RyLCBfaWRUeXBlKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IGdldFV1aWRWZXJzaW9uKHV1aWRTdHIpO1xuICAgIGlmICh2ZXJzaW9uICE9PSBudWxsICYmIHZlcnNpb24gIT09IDcgJiYgIVVVSUQ3X1dBUk5JTkdfRU1JVFRFRCkge1xuICAgICAgICBVVUlEN19XQVJOSU5HX0VNSVRURUQgPSB0cnVlO1xuICAgICAgICB3YXJuT25jZShgTGFuZ1NtaXRoIG5vdyB1c2VzIFVVSUQgdjcgZm9yIHJ1biBhbmQgdHJhY2UgaWRlbnRpZmllcnMuIGAgK1xuICAgICAgICAgICAgYFRoaXMgd2FybmluZyBhcHBlYXJzIHdoZW4gcGFzc2luZyBjdXN0b20gSURzLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgdXNlOiBpbXBvcnQgeyB1dWlkdjcgfSBmcm9tICdsYW5nc21pdGgnOyBjb25zdCBpZCA9IHV1aWR2NygpOyBgICtcbiAgICAgICAgICAgIGBGdXR1cmUgdmVyc2lvbnMgd2lsbCByZXF1aXJlIFVVSUQgdjcuYCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var _utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/p-retry/index.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+p-queue@6.6.2/node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_RETRYABLE = [\n    408, // Request Timeout\n    425, // Too Early\n    429, // Too Many Requests\n    500, // Internal Server Error\n    502, // Bad Gateway\n    503, // Service Unavailable\n    504, // Gateway Timeout\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxQueueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.maxQueueSizeBytes = params.maxQueueSizeBytes;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.callWithOptions({}, callable, ...args);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        const sizeBytes = options.sizeBytes ?? 0;\n        // Check if adding this call would exceed the byte size limit\n        if (this.maxQueueSizeBytes !== undefined &&\n            sizeBytes > 0 &&\n            this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {\n            return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. ` +\n                `Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));\n        }\n        // Add to queue size tracking\n        if (sizeBytes > 0) {\n            this.queueSizeBytes += sizeBytes;\n        }\n        const onFailedResponseHook = this.onFailedResponseHook;\n        let promise = this.queue.add(() => (0,_utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt({ error }) {\n                // Rethrow the value if it's not an object\n                if (typeof error !== \"object\" || error == null)\n                    throw error;\n                const errorMessage = \"message\" in error && typeof error.message === \"string\"\n                    ? error.message\n                    : undefined;\n                if (errorMessage?.startsWith(\"Cancel\") ||\n                    errorMessage?.startsWith(\"TimeoutError\") ||\n                    errorMessage?.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                if (\"name\" in error && error.name === \"TimeoutError\") {\n                    throw error;\n                }\n                if (\"code\" in error && error.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                const response = \"response\" in error\n                    ? error.response\n                    : undefined;\n                if (onFailedResponseHook) {\n                    const handled = await onFailedResponseHook(response);\n                    if (handled)\n                        return;\n                }\n                const status = response?.status ??\n                    (\"status\" in error ? error.status : undefined);\n                if (status != null &&\n                    (typeof status === \"number\" || typeof status === \"string\") &&\n                    !STATUS_RETRYABLE.includes(+status)) {\n                    throw error;\n                }\n            },\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n        // Decrement queue size when the call completes (success or failure)\n        if (sizeBytes > 0) {\n            promise = promise.finally(() => {\n                this.queueSizeBytes -= sizeBytes;\n            });\n        }\n        // Handle signal cancellation\n        if (options.signal) {\n            return Promise.race([\n                promise,\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return promise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNmO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0JBQXdCO0FBQ3pGLHVDQUF1QyxxQkFBcUIsNkJBQTZCLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1FQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRvb2xzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbGFuZ3NtaXRoQDAuNC45X29wZW5haUA2LjE2LjAvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcz9jMTE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwUmV0cnkgZnJvbSBcIi4uL3V0aWxzL3AtcmV0cnkvaW5kZXguanNcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmNvbnN0IFNUQVRVU19SRVRSWUFCTEUgPSBbXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbiAgICA0MjUsIC8vIFRvbyBFYXJseVxuICAgIDQyOSwgLy8gVG9vIE1hbnkgUmVxdWVzdHNcbiAgICA1MDAsIC8vIEludGVybmFsIFNlcnZlciBFcnJvclxuICAgIDUwMiwgLy8gQmFkIEdhdGV3YXlcbiAgICA1MDMsIC8vIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgICA1MDQsIC8vIEdhdGV3YXkgVGltZW91dFxuXTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UXVldWVTaXplQnl0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVTaXplQnl0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIHRoaXMubWF4UXVldWVTaXplQnl0ZXMgPSBwYXJhbXMubWF4UXVldWVTaXplQnl0ZXM7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZC5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vayA9IHBhcmFtcz8ub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsV2l0aE9wdGlvbnMoe30sIGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUJ5dGVzID0gb3B0aW9ucy5zaXplQnl0ZXMgPz8gMDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWRkaW5nIHRoaXMgY2FsbCB3b3VsZCBleGNlZWQgdGhlIGJ5dGUgc2l6ZSBsaW1pdFxuICAgICAgICBpZiAodGhpcy5tYXhRdWV1ZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzaXplQnl0ZXMgPiAwICYmXG4gICAgICAgICAgICB0aGlzLnF1ZXVlU2l6ZUJ5dGVzICsgc2l6ZUJ5dGVzID4gdGhpcy5tYXhRdWV1ZVNpemVCeXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgUXVldWUgc2l6ZSBsaW1pdCAoJHt0aGlzLm1heFF1ZXVlU2l6ZUJ5dGVzfSBieXRlcykgZXhjZWVkZWQuIGAgK1xuICAgICAgICAgICAgICAgIGBDdXJyZW50IHF1ZXVlIHNpemU6ICR7dGhpcy5xdWV1ZVNpemVCeXRlc30gYnl0ZXMsIGF0dGVtcHRlZCBhZGRpdGlvbjogJHtzaXplQnl0ZXN9IGJ5dGVzLmApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdG8gcXVldWUgc2l6ZSB0cmFja2luZ1xuICAgICAgICBpZiAoc2l6ZUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVNpemVCeXRlcyArPSBzaXplQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25GYWlsZWRSZXNwb25zZUhvb2sgPSB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KHsgZXJyb3IgfSkge1xuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgdGhlIHZhbHVlIGlmIGl0J3Mgbm90IGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09IFwib2JqZWN0XCIgfHwgZXJyb3IgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gXCJtZXNzYWdlXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2U/LnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlPy5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZT8uc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBcInJlc3BvbnNlXCIgaW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvci5yZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZCA9IGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXMgPz9cbiAgICAgICAgICAgICAgICAgICAgKFwic3RhdHVzXCIgaW4gZXJyb3IgPyBlcnJvci5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHN0YXR1cyA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc3RhdHVzID09PSBcInN0cmluZ1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhU1RBVFVTX1JFVFJZQUJMRS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICAgICAgLy8gRGVjcmVtZW50IHF1ZXVlIHNpemUgd2hlbiB0aGUgY2FsbCBjb21wbGV0ZXMgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHNpemVCeXRlcyA+IDApIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTaXplQnl0ZXMgLT0gc2l6ZUJ5dGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNpZ25hbCBjYW5jZWxsYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/context_vars.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/context_vars.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContextVar: () => (/* binding */ getContextVar),\n/* harmony export */   setContextVar: () => (/* binding */ setContextVar)\n/* harmony export */ });\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/constants.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/constants.js\");\n\n/**\n * Get a context variable from a run tree instance\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVar(runTree, key) {\n    if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const contextVars = runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY];\n        return contextVars[key];\n    }\n    return undefined;\n}\n/**\n * Set a context variable on a run tree instance\n */\nfunction setContextVar(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrunTree, key, value) {\n    const contextVars = _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree\n        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY]\n        : {};\n    contextVars[key] = value;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY] = contextVars;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvY29udGV4dF92YXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSwrRUFBeUI7QUFDakM7QUFDQSxvQ0FBb0MsK0VBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLCtFQUF5QjtBQUNqRDtBQUNBLG9CQUFvQiwrRUFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRUFBeUI7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9jb250ZXh0X3ZhcnMuanM/N2JmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG4vKipcbiAqIEdldCBhIGNvbnRleHQgdmFyaWFibGUgZnJvbSBhIHJ1biB0cmVlIGluc3RhbmNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dFZhcihydW5UcmVlLCBrZXkpIHtcbiAgICBpZiAoX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSBpbiBydW5UcmVlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGNvbnRleHRWYXJzID0gcnVuVHJlZVtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRWYXJzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFNldCBhIGNvbnRleHQgdmFyaWFibGUgb24gYSBydW4gdHJlZSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dFZhcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5ydW5UcmVlLCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgY29udGV4dFZhcnMgPSBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIGluIHJ1blRyZWVcbiAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcnVuVHJlZVtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXVxuICAgICAgICA6IHt9O1xuICAgIGNvbnRleHRWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJ1blRyZWVbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPSBjb250ZXh0VmFycztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/context_vars.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getLangSmithEnvVarsMetadata: () => (/* binding */ getLangSmithEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getLangSmithEnvironmentVariables: () => (/* binding */ getLangSmithEnvironmentVariables),\n/* harmony export */   getOtelEnabled: () => (/* binding */ getOtelEnabled),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    if (globalEnv) {\n        return globalEnv;\n    }\n    // @ts-expect-error Bun types are not imported due to conflicts with Node types\n    if (typeof Bun !== \"undefined\") {\n        globalEnv = \"bun\";\n    }\n    else if (isBrowser()) {\n        globalEnv = \"browser\";\n    }\n    else if (isNode()) {\n        globalEnv = \"node\";\n    }\n    else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    }\n    else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    }\n    else if (isDeno()) {\n        globalEnv = \"deno\";\n    }\n    else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv,\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangSmith-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangSmith-specific metadata environment variables.\n */\nfunction getLangSmithEnvVarsMetadata() {\n    const allEnvVars = getLangSmithEnvironmentVariables();\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\",\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)) {\n        if (typeof value === \"string\" &&\n            !excluded.includes(key) &&\n            !key.toLowerCase().includes(\"key\") &&\n            !key.toLowerCase().includes(\"secret\") &&\n            !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            }\n            else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves only the LangChain/LangSmith-prefixed environment variables from the current runtime environment.\n * This is more efficient than copying all environment variables.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain/LangSmith environment variables.\n */\nfunction getLangSmithEnvironmentVariables() {\n    const envVars = {};\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            for (const [key, value] of Object.entries(process.env)) {\n                if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) &&\n                    value != null) {\n                    if ((key.toLowerCase().includes(\"key\") ||\n                        key.toLowerCase().includes(\"secret\") ||\n                        key.toLowerCase().includes(\"token\")) &&\n                        typeof value === \"string\") {\n                        envVars[key] =\n                            value.slice(0, 2) +\n                                \"*\".repeat(value.length - 4) +\n                                value.slice(-2);\n                    }\n                    else {\n                        envVars[key] = value;\n                    }\n                }\n            }\n        }\n    }\n    catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n    }\n    return envVars;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return (getEnvironmentVariable(`LANGSMITH_${name}`) ||\n        getEnvironmentVariable(`LANGCHAIN_${name}`));\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */\nfunction getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\",\n    ];\n    const shas = {};\n    for (const env of common_release_envs) {\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\nfunction getOtelEnabled() {\n    return (getEnvironmentVariable(\"OTEL_ENABLED\") === \"true\" ||\n        getLangSmithEnvironmentVariable(\"OTEL_ENABLED\") === \"true\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQzFDO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdEQUFnRCxLQUFLO0FBQ3JELDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRvb2xzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbGFuZ3NtaXRoQDAuNC45X29wZW5haUA2LjE2LjAvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vudi5qcz8wNDUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIElubGluZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmxleGRpbmVzaC9icm93c2VyLW9yLW5vZGVcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4uL2luZGV4LmpzXCI7XG5sZXQgZ2xvYmFsRW52O1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0IGNvbnN0IGlzSnNEb20gPSAoKSA9PiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmFtZSA9PT0gXCJub2RlanNcIikgfHxcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuZXhwb3J0IGNvbnN0IGlzRGVubyA9ICgpID0+IHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gTWFyayBub3QtYXMtbm9kZSBpZiBpbiBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhaXNEZW5vKCk7XG5leHBvcnQgY29uc3QgZ2V0RW52ID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxFbnYpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbEVudjtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBCdW4gdHlwZXMgYXJlIG5vdCBpbXBvcnRlZCBkdWUgdG8gY29uZmxpY3RzIHdpdGggTm9kZSB0eXBlc1xuICAgIGlmICh0eXBlb2YgQnVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiYnVuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05vZGUoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm5vZGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIndlYndvcmtlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0pzRG9tKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Rlbm8oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImRlbm9cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwib3RoZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbEVudjtcbn07XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gZ2V0RW52KCk7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VFbnYgPSBnZXRTaGFzKCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ3NtaXRoXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgICAgICBzZGs6IFwibGFuZ3NtaXRoLWpzXCIsXG4gICAgICAgICAgICBzZGtfdmVyc2lvbjogX192ZXJzaW9uX18sXG4gICAgICAgICAgICAuLi5yZWxlYXNlRW52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUVudmlyb25tZW50O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdTbWl0aC1zcGVjaWZpYyBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nU21pdGgtc3BlY2lmaWMgbWV0YWRhdGEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ1NtaXRoRW52VmFyc01ldGFkYXRhKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlcygpO1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtcbiAgICAgICAgXCJMQU5HQ0hBSU5fQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fU0VTU0lPTlwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9BUElfS0VZXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX0VORFBPSU5UXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HU01JVEhfUFJPSkVDVFwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9TRVNTSU9OXCIsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIG9ubHkgdGhlIExhbmdDaGFpbi9MYW5nU21pdGgtcHJlZml4ZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBjb3B5aW5nIGFsbCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4vTGFuZ1NtaXRoIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGVzKCkge1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb2Nlc3MuZW52KSkge1xuICAgICAgICAgICAgICAgIGlmICgoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpIHx8IGtleS5zdGFydHNXaXRoKFwiTEFOR1NNSVRIX1wiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudlZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIENhdGNoIGFueSBlcnJvcnMgdGhhdCBtaWdodCBvY2N1ciB3aGlsZSB0cnlpbmcgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBDZXJ0YWluIERlbm8gc2V0dXBzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeSB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2h3Y2hhc2UxNy9sYW5nY2hhaW5qcy9pc3N1ZXMvMTQxMlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudj8uW25hbWVdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIChnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HU01JVEhfJHtuYW1lfWApIHx8XG4gICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoYExBTkdDSEFJTl8ke25hbWV9YCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3RlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIChnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiT1RFTF9FTkFCTEVEXCIpID09PSBcInRydWVcIiB8fFxuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiT1RFTF9FTkFCTEVEXCIpID09PSBcInRydWVcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/error.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingEndpointsError: () => (/* binding */ ConflictingEndpointsError),\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   LangSmithNotFoundError: () => (/* binding */ LangSmithNotFoundError),\n/* harmony export */   isConflictingEndpointsError: () => (/* binding */ isConflictingEndpointsError),\n/* harmony export */   isLangSmithNotFoundError: () => (/* binding */ isLangSmithNotFoundError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null)\n        return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\")\n        return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null)\n        return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */\nclass LangSmithConflictError extends Error {\n    constructor(message) {\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithConflictError\";\n        this.status = 409;\n    }\n}\n/**\n * LangSmithNotFoundError\n *\n * Represents an error that occurs when a requested resource is not found,\n * typically corresponding to HTTP 404 status code responses.\n *\n * @extends Error\n */\nclass LangSmithNotFoundError extends Error {\n    constructor(message) {\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithNotFoundError\";\n        this.status = 404;\n    }\n}\nfunction isLangSmithNotFoundError(error) {\n    return (error != null &&\n        typeof error === \"object\" &&\n        \"name\" in error &&\n        error?.name === \"LangSmithNotFoundError\");\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */\nasync function raiseForStatus(response, context, consumeOnSuccess) {\n    let errorBody;\n    if (response.ok) {\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        if (consumeOnSuccess) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    if (response.status === 403) {\n        try {\n            const errorData = await response.json();\n            const errorCode = errorData?.error;\n            if (errorCode === \"org_scoped_key_requires_workspace\") {\n                errorBody =\n                    \"This API key is org-scoped and requires workspace specification. \" +\n                        \"Please provide 'workspaceId' parameter, \" +\n                        \"or set LANGSMITH_WORKSPACE_ID environment variable.\";\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            const errorWithStatus = new Error(`${response.status} ${response.statusText}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            errorWithStatus.status = response?.status;\n            throw errorWithStatus;\n        }\n    }\n    if (errorBody === undefined) {\n        try {\n            errorBody = await response.text();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            errorBody = \"\";\n        }\n    }\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;\n    if (response.status === 404) {\n        throw new LangSmithNotFoundError(fullMessage);\n    }\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    const err = new Error(fullMessage);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    err.status = response.status;\n    throw err;\n}\nconst ERR_CONFLICTING_ENDPOINTS = \"ERR_CONFLICTING_ENDPOINTS\";\nclass ConflictingEndpointsError extends Error {\n    constructor() {\n        super(\"You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT \" +\n            \"and LANGSMITH_RUNS_ENDPOINTS.\");\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ERR_CONFLICTING_ENDPOINTS\n        });\n        this.name = \"ConflictingEndpointsError\"; // helpful in logs\n    }\n}\nfunction isConflictingEndpointsError(err) {\n    return (typeof err === \"object\" &&\n        err !== null &&\n        err.code === ERR_CONFLICTING_ENDPOINTS);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUSxxQkFBcUIsZ0JBQWdCLEtBQUssb0JBQW9CLGFBQWEsVUFBVTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanM/ZWI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGlmICh0eXBlb2YgZSAhPT0gXCJvYmplY3RcIiB8fCBlID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGUpIHx8IHR5cGVvZiBlLnN0YWNrICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBzdGFjayA9IGUuc3RhY2s7XG4gICAgY29uc3QgcHJldkxpbmUgPSBgJHtlfWA7XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgocHJldkxpbmUpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UocHJldkxpbmUubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBjb25zdCBzdGFjayA9IGdldEVycm9yU3RhY2tUcmFjZShlKTtcbiAgICBpZiAoc3RhY2sgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUuZXJyb3Ioc3RhY2spO1xufVxuLyoqXG4gKiBMYW5nU21pdGhDb25mbGljdEVycm9yXG4gKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IG9jY3VycyB3aGVuIHRoZXJlJ3MgYSBjb25mbGljdCBkdXJpbmcgYW4gb3BlcmF0aW9uLFxuICogdHlwaWNhbGx5IGNvcnJlc3BvbmRpbmcgdG8gSFRUUCA0MDkgc3RhdHVzIGNvZGUgcmVzcG9uc2VzLlxuICpcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gYXR0ZW1wdCB0byBjcmVhdGUgb3IgbW9kaWZ5IGEgcmVzb3VyY2UgY29uZmxpY3RzXG4gKiB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZXNvdXJjZSBvbiB0aGUgc2VydmVyLiBDb21tb24gc2NlbmFyaW9zIGluY2x1ZGU6XG4gKiAtIEF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgcmVzb3VyY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICogLSBUcnlpbmcgdG8gdXBkYXRlIGEgcmVzb3VyY2UgdGhhdCBoYXMgYmVlbiBtb2RpZmllZCBieSBhbm90aGVyIHByb2Nlc3NcbiAqIC0gVmlvbGF0aW5nIGEgdW5pcXVlbmVzcyBjb25zdHJhaW50IGluIHRoZSBkYXRhXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgYXdhaXQgY3JlYXRlUHJvamVjdChcImV4aXN0aW5nUHJvamVjdFwiKTtcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbmZsaWN0RXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkEgY29uZmxpY3Qgb2NjdXJyZWQ6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICAgIC8vIEhhbmRsZSB0aGUgY29uZmxpY3QsIGUuZy4sIGJ5IHN1Z2dlc3RpbmcgYSBkaWZmZXJlbnQgcHJvamVjdCBuYW1lXG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgLy8gSGFuZGxlIG90aGVyIHR5cGVzIG9mIGVycm9yc1xuICogICB9XG4gKiB9XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBBbHdheXMgc2V0IHRvICdDb25mbGljdEVycm9yJyBmb3IgZWFzeSBpZGVudGlmaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBEZXRhaWxlZCBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyBzZXJ2ZXIgcmVzcG9uc2VcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwOVxuICovXG5leHBvcnQgY2xhc3MgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJMYW5nU21pdGhDb25mbGljdEVycm9yXCI7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDA5O1xuICAgIH1cbn1cbi8qKlxuICogTGFuZ1NtaXRoTm90Rm91bmRFcnJvclxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnMgd2hlbiBhIHJlcXVlc3RlZCByZXNvdXJjZSBpcyBub3QgZm91bmQsXG4gKiB0eXBpY2FsbHkgY29ycmVzcG9uZGluZyB0byBIVFRQIDQwNCBzdGF0dXMgY29kZSByZXNwb25zZXMuXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdTbWl0aE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTGFuZ1NtaXRoTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwNDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiBlcnJvciAmJlxuICAgICAgICBlcnJvcj8ubmFtZSA9PT0gXCJMYW5nU21pdGhOb3RGb3VuZEVycm9yXCIpO1xufVxuLyoqXG4gKiBUaHJvd3MgYW4gYXBwcm9wcmlhdGUgZXJyb3IgYmFzZWQgb24gdGhlIHJlc3BvbnNlIHN0YXR1cyBhbmQgYm9keS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgZmV0Y2ggUmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBtZXNzYWdlIChlLmcuLCBvcGVyYXRpb24gYmVpbmcgcGVyZm9ybWVkKVxuICogQHRocm93cyB7TGFuZ1NtaXRoQ29uZmxpY3RFcnJvcn0gV2hlbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGlzIDQwOVxuICogQHRocm93cyB7RXJyb3J9IEZvciBhbGwgb3RoZXIgbm9uLW9rIHJlc3BvbnNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGNvbnRleHQsIGNvbnN1bWVPblN1Y2Nlc3MpIHtcbiAgICBsZXQgZXJyb3JCb2R5O1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICAgICAgaWYgKGNvbnN1bWVPblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3JEYXRhPy5lcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFwib3JnX3Njb3BlZF9rZXlfcmVxdWlyZXNfd29ya3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvckJvZHkgPVxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgQVBJIGtleSBpcyBvcmctc2NvcGVkIGFuZCByZXF1aXJlcyB3b3Jrc3BhY2Ugc3BlY2lmaWNhdGlvbi4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSAnd29ya3NwYWNlSWQnIHBhcmFtZXRlciwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvciBzZXQgTEFOR1NNSVRIX1dPUktTUEFDRV9JRCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yV2l0aFN0YXR1cyA9IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBlcnJvcldpdGhTdGF0dXMuc3RhdHVzID0gcmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgIHRocm93IGVycm9yV2l0aFN0YXR1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3JCb2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgRmFpbGVkIHRvICR7Y29udGV4dH0uIFJlY2VpdmVkIHN0YXR1cyBbJHtyZXNwb25zZS5zdGF0dXN9XTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gTWVzc2FnZTogJHtlcnJvckJvZHl9YDtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IExhbmdTbWl0aE5vdEZvdW5kRXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IExhbmdTbWl0aENvbmZsaWN0RXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICB0aHJvdyBlcnI7XG59XG5jb25zdCBFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTID0gXCJFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTXCI7XG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJZb3UgY2Fubm90IHByb3ZpZGUgYm90aCBMQU5HU01JVEhfRU5EUE9JTlQgLyBMQU5HQ0hBSU5fRU5EUE9JTlQgXCIgK1xuICAgICAgICAgICAgXCJhbmQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTLlwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UU1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yXCI7IC8vIGhlbHBmdWwgaW4gbG9nc1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVyciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnIuY29kZSA9PT0gRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UUyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n/* eslint-disable */\n// @ts-nocheck\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        }\n        else if (val instanceof Set) {\n            return Array.from(val);\n        }\n        else if (val instanceof Date) {\n            return val.toISOString();\n        }\n        else if (val instanceof RegExp) {\n            return val.toString();\n        }\n        else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message,\n            };\n        }\n    }\n    else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function (key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nfunction serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !==\n            \"true\" &&\n            console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDcUU7QUFDckU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDZCQUE2QixhQUFhLE9BQU87QUFDaEk7QUFDQTtBQUNBLFFBQVEsOEVBQStCO0FBQ3ZDO0FBQ0EsZ0hBQWdILDZCQUE2QixhQUFhLE9BQU87QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRvb2xzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbGFuZ3NtaXRoQDAuNC45X29wZW5haUA2LjE2LjAvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanM/M2FmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbmltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vLi4vdXRpbHMvZW52LmpzXCI7XG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gXCJbLi4uXVwiO1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9IHsgcmVzdWx0OiBcIltDaXJjdWxhcl1cIiB9O1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIpO1xufVxuLy8gU2hhcmVkIGZ1bmN0aW9uIHRvIGhhbmRsZSB3ZWxsLWtub3duIHR5cGVzXG5mdW5jdGlvbiBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHZhbC5uYW1lLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbC5tZXNzYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8vIERlZmF1bHQgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHdlbGwta25vd24gdHlwZXNcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRSZXBsYWNlcih1c2VyUmVwbGFjZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIC8vIEFwcGx5IHVzZXIgcmVwbGFjZXIgZmlyc3QgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHVzZXJSZXBsYWNlcikge1xuICAgICAgICAgICAgY29uc3QgdXNlclJlc3VsdCA9IHVzZXJSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKTtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgcmVwbGFjZXIgcmV0dXJuZWQgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gb3VyIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIGlmICh1c2VyUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlclJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gb3VyIHdlbGwta25vd24gdHlwZSBoYW5kbGluZ1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplV2VsbEtub3duVHlwZXModmFsKTtcbiAgICB9O1xufVxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUob2JqLCBlcnJvckNvbnRleHQsIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIGNyZWF0ZURlZmF1bHRSZXBsYWNlcihyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG1vcmUgY29tcGxleCBzdHJpbmdpZnkgaWYgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICghZS5tZXNzYWdlPy5pbmNsdWRlcyhcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1dBUk5JTkddOiBMYW5nU21pdGggcmVjZWl2ZWQgdW5zZXJpYWxpemFibGUgdmFsdWUuJHtlcnJvckNvbnRleHQgPyBgXFxuQ29udGV4dDogJHtlcnJvckNvbnRleHR9YCA6IFwiXCJ9YCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW1Vuc2VyaWFsaXphYmxlXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiU1VQUFJFU1NfQ0lSQ1VMQVJfSlNPTl9XQVJOSU5HU1wiKSAhPT1cbiAgICAgICAgICAgIFwidHJ1ZVwiICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIGNpcmN1bGFyIEpTT04uIFRoaXMgd2lsbCBkZWNyZWFzZSB0cmFjZXIgcGVyZm9ybWFuY2UuICR7ZXJyb3JDb250ZXh0ID8gYFxcbkNvbnRleHQ6ICR7ZXJyb3JDb250ZXh0fWAgOiBcIlwifWApO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGRlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyhyZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50W2tdID0gcmVwbGFjZTtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB3ZWxsLWtub3duIHR5cGVzIGJlZm9yZSBPYmplY3Qua2V5cyBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhbCA9IHNlcmlhbGl6ZVdlbGxLbm93blR5cGVzKHZhbCk7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxufVxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gICAgfVxuICAgIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgXCJcIiwgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cbiAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gICAgZGVwdGggKz0gMTtcbiAgICB2YXIgaTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB3ZWxsLWtub3duIHR5cGVzIGJlZm9yZSBPYmplY3Qua2V5cyBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhbCA9IHNlcmlhbGl6ZVdlbGxLbm93blR5cGVzKHZhbCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgICAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRtcFtrZXldID0gdmFsW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgICAgICAgICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxufVxuLy8gd3JhcHMgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHZhbHVlcyB3ZSBjb3VsZG4ndCByZXBsYWNlXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXG5mdW5jdGlvbiByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSB7XG4gICAgcmVwbGFjZXIgPVxuICAgICAgICB0eXBlb2YgcmVwbGFjZXIgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gcmVwbGFjZXJcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFydFsyXTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/is-network-error/index.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/is-network-error/index.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isNetworkError)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n// is-network-error vendored to avoid import issues\n// Source: https://github.com/sindresorhus/is-network-error\nconst objectToString = Object.prototype.toString;\nconst isError = (value) => objectToString.call(value) === \"[object Error]\";\nconst errorMessages = new Set([\n    \"network error\", // Chrome\n    \"Failed to fetch\", // Chrome\n    \"NetworkError when attempting to fetch resource.\", // Firefox\n    \"The Internet connection appears to be offline.\", // Safari 16\n    \"Network request failed\", // `cross-fetch`\n    \"fetch failed\", // Undici (Node.js)\n    \"terminated\", // Undici (Node.js)\n    \" A network error occurred.\", // Bun (WebKit)\n    \"Network connection lost\", // Cloudflare Workers (fetch)\n]);\nfunction isNetworkError(error) {\n    const isValid = error &&\n        isError(error) &&\n        error.name === \"TypeError\" &&\n        typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    const { message, stack } = error;\n    // Safari 17+ has generic message but no stack for network errors\n    if (message === \"Load failed\") {\n        return (stack === undefined ||\n            // Sentry adds its own stack trace to the fetch error, so also check for that\n            \"__sentry_captured__\" in error);\n    }\n    // Deno network errors start with specific text\n    if (message.startsWith(\"error sending request for url\")) {\n        return true;\n    }\n    // Standard network error messages\n    return errorMessages.has(message);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvaXMtbmV0d29yay1lcnJvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRvb2xzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbGFuZ3NtaXRoQDAuNC45X29wZW5haUA2LjE2LjAvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2lzLW5ldHdvcmstZXJyb3IvaW5kZXguanM/MjQ3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8vIGlzLW5ldHdvcmstZXJyb3IgdmVuZG9yZWQgdG8gYXZvaWQgaW1wb3J0IGlzc3Vlc1xuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLW5ldHdvcmstZXJyb3JcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IGlzRXJyb3IgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRXJyb3JdXCI7XG5jb25zdCBlcnJvck1lc3NhZ2VzID0gbmV3IFNldChbXG4gICAgXCJuZXR3b3JrIGVycm9yXCIsIC8vIENocm9tZVxuICAgIFwiRmFpbGVkIHRvIGZldGNoXCIsIC8vIENocm9tZVxuICAgIFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIiwgLy8gRmlyZWZveFxuICAgIFwiVGhlIEludGVybmV0IGNvbm5lY3Rpb24gYXBwZWFycyB0byBiZSBvZmZsaW5lLlwiLCAvLyBTYWZhcmkgMTZcbiAgICBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIiwgLy8gYGNyb3NzLWZldGNoYFxuICAgIFwiZmV0Y2ggZmFpbGVkXCIsIC8vIFVuZGljaSAoTm9kZS5qcylcbiAgICBcInRlcm1pbmF0ZWRcIiwgLy8gVW5kaWNpIChOb2RlLmpzKVxuICAgIFwiIEEgbmV0d29yayBlcnJvciBvY2N1cnJlZC5cIiwgLy8gQnVuIChXZWJLaXQpXG4gICAgXCJOZXR3b3JrIGNvbm5lY3Rpb24gbG9zdFwiLCAvLyBDbG91ZGZsYXJlIFdvcmtlcnMgKGZldGNoKVxuXSk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBlcnJvciAmJlxuICAgICAgICBpc0Vycm9yKGVycm9yKSAmJlxuICAgICAgICBlcnJvci5uYW1lID09PSBcIlR5cGVFcnJvclwiICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2sgfSA9IGVycm9yO1xuICAgIC8vIFNhZmFyaSAxNysgaGFzIGdlbmVyaWMgbWVzc2FnZSBidXQgbm8gc3RhY2sgZm9yIG5ldHdvcmsgZXJyb3JzXG4gICAgaWYgKG1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICByZXR1cm4gKHN0YWNrID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8vIFNlbnRyeSBhZGRzIGl0cyBvd24gc3RhY2sgdHJhY2UgdG8gdGhlIGZldGNoIGVycm9yLCBzbyBhbHNvIGNoZWNrIGZvciB0aGF0XG4gICAgICAgICAgICBcIl9fc2VudHJ5X2NhcHR1cmVkX19cIiBpbiBlcnJvcik7XG4gICAgfVxuICAgIC8vIERlbm8gbmV0d29yayBlcnJvcnMgc3RhcnQgd2l0aCBzcGVjaWZpYyB0ZXh0XG4gICAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcImVycm9yIHNlbmRpbmcgcmVxdWVzdCBmb3IgdXJsXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTdGFuZGFyZCBuZXR3b3JrIGVycm9yIG1lc3NhZ2VzXG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZXMuaGFzKG1lc3NhZ2UpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/is-network-error/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: { content: message.content },\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs &&\n        Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = { ...message.additional_kwargs };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9tZXNzYWdlcy5qcz8xMGYwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc0xhbmdDaGFpbk1lc3NhZ2UoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWVzc2FnZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZT8uX2dldFR5cGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKSB7XG4gICAgY29uc3QgY29udmVydGVkID0ge1xuICAgICAgICB0eXBlOiBtZXNzYWdlLl9nZXRUeXBlKCksXG4gICAgICAgIGRhdGE6IHsgY29udGVudDogbWVzc2FnZS5jb250ZW50IH0sXG4gICAgfTtcbiAgICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2Yga2V5cyBpbiBhZGRpdGlvbmFsX2t3YXJnc1xuICAgIGlmIChtZXNzYWdlPy5hZGRpdGlvbmFsX2t3YXJncyAmJlxuICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnZlcnRlZC5kYXRhLmFkZGl0aW9uYWxfa3dhcmdzID0geyAuLi5tZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzIH07XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/p-retry/index.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/p-retry/index.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   \"default\": () => (/* binding */ pRetry),\n/* harmony export */   makeRetriable: () => (/* binding */ makeRetriable)\n/* harmony export */ });\n/* harmony import */ var _is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is-network-error/index.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/is-network-error/index.js\");\n/* eslint-disable */\n// @ts-nocheck\n// p-retry code vendored to avoid import issues\n// Source: https://github.com/sindresorhus/p-retry\n\nfunction validateRetries(retries) {\n    if (typeof retries === \"number\") {\n        if (retries < 0) {\n            throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n        }\n        if (Number.isNaN(retries)) {\n            throw new TypeError(\"Expected `retries` to be a valid number or Infinity, got NaN.\");\n        }\n    }\n    else if (retries !== undefined) {\n        throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n    }\n}\nfunction validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {\n    if (value === undefined) {\n        return;\n    }\n    if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? \" or Infinity\" : \"\"}.`);\n    }\n    if (!allowInfinity && !Number.isFinite(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n    }\n    if (value < min) {\n        throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n    }\n}\nclass AbortError extends Error {\n    constructor(message) {\n        super();\n        if (message instanceof Error) {\n            this.originalError = message;\n            ({ message } = message);\n        }\n        else {\n            this.originalError = new Error(message);\n            this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n    }\n}\nfunction calculateDelay(retriesConsumed, options) {\n    const attempt = Math.max(1, retriesConsumed + 1);\n    const random = options.randomize ? Math.random() + 1 : 1;\n    let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));\n    timeout = Math.min(timeout, options.maxTimeout);\n    return timeout;\n}\nfunction calculateRemainingTime(start, max) {\n    if (!Number.isFinite(max)) {\n        return max;\n    }\n    return max - (performance.now() - start);\n}\nasync function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options, }) {\n    const normalizedError = error instanceof Error\n        ? error\n        : new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n    if (normalizedError instanceof AbortError) {\n        throw normalizedError.originalError;\n    }\n    const retriesLeft = Number.isFinite(options.retries)\n        ? Math.max(0, options.retries - retriesConsumed)\n        : options.retries;\n    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n    const context = Object.freeze({\n        error: normalizedError,\n        attemptNumber,\n        retriesLeft,\n        retriesConsumed,\n    });\n    await options.onFailedAttempt(context);\n    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n        throw normalizedError;\n    }\n    const consumeRetry = await options.shouldConsumeRetry(context);\n    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n    if (remainingTime <= 0 || retriesLeft <= 0) {\n        throw normalizedError;\n    }\n    if (normalizedError instanceof TypeError &&\n        !(0,_is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(normalizedError)) {\n        if (consumeRetry) {\n            throw normalizedError;\n        }\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    if (!(await options.shouldRetry(context))) {\n        throw normalizedError;\n    }\n    if (!consumeRetry) {\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    const delayTime = calculateDelay(retriesConsumed, options);\n    const finalDelay = Math.min(delayTime, remainingTime);\n    if (finalDelay > 0) {\n        await new Promise((resolve, reject) => {\n            const onAbort = () => {\n                clearTimeout(timeoutToken);\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                reject(options.signal.reason);\n            };\n            const timeoutToken = setTimeout(() => {\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                resolve();\n            }, finalDelay);\n            if (options.unref) {\n                timeoutToken.unref?.();\n            }\n            options.signal?.addEventListener(\"abort\", onAbort, { once: true });\n        });\n    }\n    options.signal?.throwIfAborted();\n    return true;\n}\nasync function pRetry(input, options = {}) {\n    options = { ...options };\n    validateRetries(options.retries);\n    if (Object.hasOwn(options, \"forever\")) {\n        throw new Error(\"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\");\n    }\n    options.retries ??= 10;\n    options.factor ??= 2;\n    options.minTimeout ??= 1000;\n    options.maxTimeout ??= Number.POSITIVE_INFINITY;\n    options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n    options.randomize ??= false;\n    options.onFailedAttempt ??= () => { };\n    options.shouldRetry ??= () => true;\n    options.shouldConsumeRetry ??= () => true;\n    // Validate numeric options and normalize edge cases\n    validateNumberOption(\"factor\", options.factor, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"minTimeout\", options.minTimeout, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n        min: 0,\n        allowInfinity: true,\n    });\n    validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n        min: 0,\n        allowInfinity: true,\n    });\n    // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n    if (!(options.factor > 0)) {\n        options.factor = 1;\n    }\n    options.signal?.throwIfAborted();\n    let attemptNumber = 0;\n    let retriesConsumed = 0;\n    const startTime = performance.now();\n    while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {\n        attemptNumber++;\n        try {\n            options.signal?.throwIfAborted();\n            const result = await input(attemptNumber);\n            options.signal?.throwIfAborted();\n            return result;\n        }\n        catch (error) {\n            if (await onAttemptFailure({\n                error,\n                attemptNumber,\n                retriesConsumed,\n                startTime,\n                options,\n            })) {\n                retriesConsumed++;\n            }\n        }\n    }\n    // Should not reach here, but in case it does, throw an error\n    throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\nfunction makeRetriable(function_, options) {\n    return function (...arguments_) {\n        return pRetry(() => function_.apply(this, arguments_), options);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcC1yZXRyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQWlDLElBQUk7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSyxtQkFBbUIsb0NBQW9DO0FBQ3RHO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0EsMENBQTBDLEtBQUssa0JBQWtCLElBQUk7QUFDckU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNFQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNlLHlDQUF5QztBQUN4RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRvb2xzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbGFuZ3NtaXRoQDAuNC45X29wZW5haUA2LjE2LjAvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL3AtcmV0cnkvaW5kZXguanM/NTUxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8vIHAtcmV0cnkgY29kZSB2ZW5kb3JlZCB0byBhdm9pZCBpbXBvcnQgaXNzdWVzXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1yZXRyeVxuaW1wb3J0IGlzTmV0d29ya0Vycm9yIGZyb20gXCIuLi9pcy1uZXR3b3JrLWVycm9yL2luZGV4LmpzXCI7XG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJpZXMocmV0cmllcykge1xuICAgIGlmICh0eXBlb2YgcmV0cmllcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAocmV0cmllcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgcmV0cmllc2AgdG8gYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHJldHJpZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYHJldHJpZXNgIHRvIGJlIGEgdmFsaWQgbnVtYmVyIG9yIEluZmluaXR5LCBnb3QgTmFOLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXRyaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGByZXRyaWVzYCB0byBiZSBhIG51bWJlciBvciBJbmZpbml0eS5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJPcHRpb24obmFtZSwgdmFsdWUsIHsgbWluID0gMCwgYWxsb3dJbmZpbml0eSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCBOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYCR7bmFtZX1cXGAgdG8gYmUgYSBudW1iZXIke2FsbG93SW5maW5pdHkgPyBcIiBvciBJbmZpbml0eVwiIDogXCJcIn0uYCk7XG4gICAgfVxuICAgIGlmICghYWxsb3dJbmZpbml0eSAmJiAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGAke25hbWV9XFxgIHRvIGJlIGEgZmluaXRlIG51bWJlci5gKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYCR7bmFtZX1cXGAgdG8gYmUgXFx1MjI2NSAke21pbn0uYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBtZXNzYWdlO1xuICAgICAgICAgICAgKHsgbWVzc2FnZSB9ID0gbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3Iuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbGF5KHJldHJpZXNDb25zdW1lZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF0dGVtcHQgPSBNYXRoLm1heCgxLCByZXRyaWVzQ29uc3VtZWQgKyAxKTtcbiAgICBjb25zdCByYW5kb20gPSBvcHRpb25zLnJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgKyAxIDogMTtcbiAgICBsZXQgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogb3B0aW9ucy5taW5UaW1lb3V0ICogb3B0aW9ucy5mYWN0b3IgKiogKGF0dGVtcHQgLSAxKSk7XG4gICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQsIG9wdGlvbnMubWF4VGltZW91dCk7XG4gICAgcmV0dXJuIHRpbWVvdXQ7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZW1haW5pbmdUaW1lKHN0YXJ0LCBtYXgpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtYXgpKSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJldHVybiBtYXggLSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCk7XG59XG5hc3luYyBmdW5jdGlvbiBvbkF0dGVtcHRGYWlsdXJlKHsgZXJyb3IsIGF0dGVtcHROdW1iZXIsIHJldHJpZXNDb25zdW1lZCwgc3RhcnRUaW1lLCBvcHRpb25zLCB9KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEVycm9yID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/IGVycm9yXG4gICAgICAgIDogbmV3IFR5cGVFcnJvcihgTm9uLWVycm9yIHdhcyB0aHJvd246IFwiJHtlcnJvcn1cIi4gWW91IHNob3VsZCBvbmx5IHRocm93IGVycm9ycy5gKTtcbiAgICBpZiAobm9ybWFsaXplZEVycm9yIGluc3RhbmNlb2YgQWJvcnRFcnJvcikge1xuICAgICAgICB0aHJvdyBub3JtYWxpemVkRXJyb3Iub3JpZ2luYWxFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgcmV0cmllc0xlZnQgPSBOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5yZXRyaWVzKVxuICAgICAgICA/IE1hdGgubWF4KDAsIG9wdGlvbnMucmV0cmllcyAtIHJldHJpZXNDb25zdW1lZClcbiAgICAgICAgOiBvcHRpb25zLnJldHJpZXM7XG4gICAgY29uc3QgbWF4UmV0cnlUaW1lID0gb3B0aW9ucy5tYXhSZXRyeVRpbWUgPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZXJyb3I6IG5vcm1hbGl6ZWRFcnJvcixcbiAgICAgICAgYXR0ZW1wdE51bWJlcixcbiAgICAgICAgcmV0cmllc0xlZnQsXG4gICAgICAgIHJldHJpZXNDb25zdW1lZCxcbiAgICB9KTtcbiAgICBhd2FpdCBvcHRpb25zLm9uRmFpbGVkQXR0ZW1wdChjb250ZXh0KTtcbiAgICBpZiAoY2FsY3VsYXRlUmVtYWluaW5nVGltZShzdGFydFRpbWUsIG1heFJldHJ5VGltZSkgPD0gMCkge1xuICAgICAgICB0aHJvdyBub3JtYWxpemVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN1bWVSZXRyeSA9IGF3YWl0IG9wdGlvbnMuc2hvdWxkQ29uc3VtZVJldHJ5KGNvbnRleHQpO1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBjYWxjdWxhdGVSZW1haW5pbmdUaW1lKHN0YXJ0VGltZSwgbWF4UmV0cnlUaW1lKTtcbiAgICBpZiAocmVtYWluaW5nVGltZSA8PSAwIHx8IHJldHJpZXNMZWZ0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbm9ybWFsaXplZEVycm9yO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZEVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmXG4gICAgICAgICFpc05ldHdvcmtFcnJvcihub3JtYWxpemVkRXJyb3IpKSB7XG4gICAgICAgIGlmIChjb25zdW1lUmV0cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5vcm1hbGl6ZWRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIShhd2FpdCBvcHRpb25zLnNob3VsZFJldHJ5KGNvbnRleHQpKSkge1xuICAgICAgICB0aHJvdyBub3JtYWxpemVkRXJyb3I7XG4gICAgfVxuICAgIGlmICghY29uc3VtZVJldHJ5KSB7XG4gICAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5VGltZSA9IGNhbGN1bGF0ZURlbGF5KHJldHJpZXNDb25zdW1lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmluYWxEZWxheSA9IE1hdGgubWluKGRlbGF5VGltZSwgcmVtYWluaW5nVGltZSk7XG4gICAgaWYgKGZpbmFsRGVsYXkgPiAwKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUb2tlbik7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgICAgICAgICByZWplY3Qob3B0aW9ucy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0VG9rZW4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZpbmFsRGVsYXkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0VG9rZW4udW5yZWY/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBSZXRyeShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIHZhbGlkYXRlUmV0cmllcyhvcHRpb25zLnJldHJpZXMpO1xuICAgIGlmIChPYmplY3QuaGFzT3duKG9wdGlvbnMsIFwiZm9yZXZlclwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGZvcmV2ZXJgIG9wdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBGb3IgbWFueSB1c2UtY2FzZXMsIHlvdSBjYW4gc2V0IGByZXRyaWVzOiBJbmZpbml0eWAgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMucmV0cmllcyA/Pz0gMTA7XG4gICAgb3B0aW9ucy5mYWN0b3IgPz89IDI7XG4gICAgb3B0aW9ucy5taW5UaW1lb3V0ID8/PSAxMDAwO1xuICAgIG9wdGlvbnMubWF4VGltZW91dCA/Pz0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIG9wdGlvbnMubWF4UmV0cnlUaW1lID8/PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgb3B0aW9ucy5yYW5kb21pemUgPz89IGZhbHNlO1xuICAgIG9wdGlvbnMub25GYWlsZWRBdHRlbXB0ID8/PSAoKSA9PiB7IH07XG4gICAgb3B0aW9ucy5zaG91bGRSZXRyeSA/Pz0gKCkgPT4gdHJ1ZTtcbiAgICBvcHRpb25zLnNob3VsZENvbnN1bWVSZXRyeSA/Pz0gKCkgPT4gdHJ1ZTtcbiAgICAvLyBWYWxpZGF0ZSBudW1lcmljIG9wdGlvbnMgYW5kIG5vcm1hbGl6ZSBlZGdlIGNhc2VzXG4gICAgdmFsaWRhdGVOdW1iZXJPcHRpb24oXCJmYWN0b3JcIiwgb3B0aW9ucy5mYWN0b3IsIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZU51bWJlck9wdGlvbihcIm1pblRpbWVvdXRcIiwgb3B0aW9ucy5taW5UaW1lb3V0LCB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dJbmZpbml0eTogZmFsc2UsXG4gICAgfSk7XG4gICAgdmFsaWRhdGVOdW1iZXJPcHRpb24oXCJtYXhUaW1lb3V0XCIsIG9wdGlvbnMubWF4VGltZW91dCwge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93SW5maW5pdHk6IHRydWUsXG4gICAgfSk7XG4gICAgdmFsaWRhdGVOdW1iZXJPcHRpb24oXCJtYXhSZXRyeVRpbWVcIiwgb3B0aW9ucy5tYXhSZXRyeVRpbWUsIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd0luZmluaXR5OiB0cnVlLFxuICAgIH0pO1xuICAgIC8vIFRyZWF0IG5vbi1wb3NpdGl2ZSBmYWN0b3IgYXMgMSB0byBhdm9pZCB6ZXJvIGJhY2tvZmYgb3IgbmVnYXRpdmUgYmVoYXZpb3JcbiAgICBpZiAoIShvcHRpb25zLmZhY3RvciA+IDApKSB7XG4gICAgICAgIG9wdGlvbnMuZmFjdG9yID0gMTtcbiAgICB9XG4gICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgbGV0IGF0dGVtcHROdW1iZXIgPSAwO1xuICAgIGxldCByZXRyaWVzQ29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHdoaWxlIChOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5yZXRyaWVzKSA/IHJldHJpZXNDb25zdW1lZCA8PSBvcHRpb25zLnJldHJpZXMgOiB0cnVlKSB7XG4gICAgICAgIGF0dGVtcHROdW1iZXIrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW5wdXQoYXR0ZW1wdE51bWJlcik7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgb25BdHRlbXB0RmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgYXR0ZW1wdE51bWJlcixcbiAgICAgICAgICAgICAgICByZXRyaWVzQ29uc3VtZWQsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHJldHJpZXNDb25zdW1lZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNob3VsZCBub3QgcmVhY2ggaGVyZSwgYnV0IGluIGNhc2UgaXQgZG9lcywgdGhyb3cgYW4gZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXRyeSBhdHRlbXB0cyBleGhhdXN0ZWQgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJldHJpYWJsZShmdW5jdGlvbl8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcbiAgICAgICAgcmV0dXJuIHBSZXRyeSgoKSA9PiBmdW5jdGlvbl8uYXBwbHkodGhpcywgYXJndW1lbnRzXyksIG9wdGlvbnMpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/p-retry/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/project.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/project.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProjectName: () => (/* binding */ getDefaultProjectName)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/env.js\");\n\nconst getDefaultProjectName = () => {\n    return ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"PROJECT\") ??\n        (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n        \"default\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRjtBQUM3RTtBQUNQLFlBQVksd0VBQStCO0FBQzNDLFFBQVEsK0RBQXNCO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9qZWN0LmpzPzk0MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSwgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0UHJvamVjdE5hbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiUFJPSkVDVFwiKSA/P1xuICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1NFU1NJT05cIikgPz8gLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgICAgIFwiZGVmYXVsdFwiKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/project.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+semver@7.7.3/node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier ||\n        identifier.split(\"/\").length > 2 ||\n        identifier.startsWith(\"/\") ||\n        identifier.endsWith(\"/\") ||\n        identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [owner, name, commit];\n    }\n    else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\"-\", ownerNamePart, commit];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEM7QUFDUCxvQkFBb0IsNkNBQVk7QUFDaEMsbUJBQW1CLDZDQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzPzM0ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VWZXJzaW9uIH0gZnJvbSBcInNlbXZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKGN1cnJlbnRfdmVyc2lvbiwgdGFyZ2V0X3ZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VWZXJzaW9uKGN1cnJlbnRfdmVyc2lvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VWZXJzaW9uKHRhcmdldF92ZXJzaW9uKTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuY29tcGFyZSh0YXJnZXQpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9tcHRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWlkZW50aWZpZXIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIi9cIikubGVuZ3RoID4gMiB8fFxuICAgICAgICBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuZW5kc1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtvd25lck5hbWVQYXJ0LCBjb21taXRQYXJ0XSA9IGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGNvbW1pdCA9IGNvbW1pdFBhcnQgfHwgXCJsYXRlc3RcIjtcbiAgICBpZiAob3duZXJOYW1lUGFydC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBuYW1lXSA9IG93bmVyTmFtZVBhcnQuc3BsaXQoXCIvXCIsIDIpO1xuICAgICAgICBpZiAoIW93bmVyIHx8ICFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW293bmVyLCBuYW1lLCBjb21taXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvd25lck5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wiLVwiLCBvd25lck5hbWVQYXJ0LCBjb21taXRdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prompts_cache_fs.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache_fs.js\");\n/**\n * Prompt caching module for LangSmith SDK.\n *\n * Provides an LRU cache with background refresh for prompt caching.\n * Uses stale-while-revalidate pattern for optimal performance.\n *\n * Works in all environments. File operations (dump/load) use helpers\n * that are swapped for browser builds via package.json browser field.\n */\n\n/**\n * Check if a cache entry is stale based on TTL.\n */\nfunction isStale(entry, ttlSeconds) {\n    if (ttlSeconds === null) {\n        return false; // Infinite TTL, never stale\n    }\n    const ageMs = Date.now() - entry.createdAt;\n    return ageMs > ttlSeconds * 1000;\n}\n/**\n * LRU cache with background refresh for prompts.\n *\n * Features:\n * - In-memory LRU cache with configurable max size\n * - Background refresh using setInterval\n * - Stale-while-revalidate: returns stale data while refresh happens\n * - JSON dump/load for offline use\n *\n * @example\n * ```typescript\n * const cache = new Cache({\n *   maxSize: 100,\n *   ttlSeconds: 3600,\n *   fetchFunc: async (key) => client.pullPromptCommit(key),\n * });\n *\n * // Use the cache\n * cache.set(\"my-prompt:latest\", promptCommit);\n * const cached = cache.get(\"my-prompt:latest\");\n *\n * // Cleanup\n * cache.stop();\n * ```\n */\nclass Cache {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ttlSeconds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"refreshIntervalSeconds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchFunc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"refreshTimer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_metrics\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                hits: 0,\n                misses: 0,\n                refreshes: 0,\n                refreshErrors: 0,\n            }\n        });\n        this.maxSize = config.maxSize ?? 100;\n        this.ttlSeconds = config.ttlSeconds ?? 3600;\n        this.refreshIntervalSeconds = config.refreshIntervalSeconds ?? 60;\n        this.fetchFunc = config.fetchFunc;\n        // Start background refresh if fetch function provided and TTL is set\n        if (this.fetchFunc && this.ttlSeconds !== null) {\n            this.startRefreshLoop();\n        }\n    }\n    /**\n     * Get cache performance metrics.\n     */\n    get metrics() {\n        return { ...this._metrics };\n    }\n    /**\n     * Get total cache requests (hits + misses).\n     */\n    get totalRequests() {\n        return this._metrics.hits + this._metrics.misses;\n    }\n    /**\n     * Get cache hit rate (0.0 to 1.0).\n     */\n    get hitRate() {\n        const total = this.totalRequests;\n        return total > 0 ? this._metrics.hits / total : 0;\n    }\n    /**\n     * Reset all metrics to zero.\n     */\n    resetMetrics() {\n        this._metrics = {\n            hits: 0,\n            misses: 0,\n            refreshes: 0,\n            refreshErrors: 0,\n        };\n    }\n    /**\n     * Get a value from cache.\n     *\n     * Returns the cached value or undefined if not found.\n     * Stale entries are still returned (background refresh handles updates).\n     */\n    get(key) {\n        const entry = this.cache.get(key);\n        if (!entry) {\n            this._metrics.misses += 1;\n            return undefined;\n        }\n        // Move to end for LRU (delete and re-add)\n        this.cache.delete(key);\n        this.cache.set(key, entry);\n        this._metrics.hits += 1;\n        return entry.value;\n    }\n    /**\n     * Set a value in the cache.\n     */\n    set(key, value) {\n        // Check if we need to evict (and key is new)\n        if (!this.cache.has(key) && this.cache.size >= this.maxSize) {\n            // Evict oldest (first item in Map)\n            const oldestKey = this.cache.keys().next().value;\n            if (oldestKey !== undefined) {\n                this.cache.delete(oldestKey);\n            }\n        }\n        const entry = {\n            value,\n            createdAt: Date.now(),\n        };\n        // Delete first to ensure it's at the end\n        this.cache.delete(key);\n        this.cache.set(key, entry);\n    }\n    /**\n     * Remove a specific entry from cache.\n     */\n    invalidate(key) {\n        this.cache.delete(key);\n    }\n    /**\n     * Clear all cache entries.\n     */\n    clear() {\n        this.cache.clear();\n    }\n    /**\n     * Get the number of entries in the cache.\n     */\n    get size() {\n        return this.cache.size;\n    }\n    /**\n     * Stop background refresh.\n     * Should be called when the client is being cleaned up.\n     */\n    stop() {\n        if (this.refreshTimer) {\n            clearInterval(this.refreshTimer);\n            this.refreshTimer = undefined;\n        }\n    }\n    /**\n     * Dump cache contents to a JSON file for offline use.\n     */\n    dump(filePath) {\n        const entries = {};\n        for (const [key, entry] of this.cache.entries()) {\n            entries[key] = entry.value;\n        }\n        (0,_prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__.dumpCache)(filePath, entries);\n    }\n    /**\n     * Load cache contents from a JSON file.\n     *\n     * Loaded entries get a fresh TTL starting from load time.\n     *\n     * @returns Number of entries loaded.\n     */\n    load(filePath) {\n        const entries = (0,_prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__.loadCache)(filePath);\n        if (!entries) {\n            return 0;\n        }\n        let loaded = 0;\n        const now = Date.now();\n        for (const [key, value] of Object.entries(entries)) {\n            if (this.cache.size >= this.maxSize) {\n                break;\n            }\n            const entry = {\n                value: value,\n                createdAt: now, // Fresh TTL from load time\n            };\n            this.cache.set(key, entry);\n            loaded += 1;\n        }\n        return loaded;\n    }\n    /**\n     * Start the background refresh loop.\n     */\n    startRefreshLoop() {\n        this.refreshTimer = setInterval(() => {\n            this.refreshStaleEntries().catch((e) => {\n                // Log but don't die - keep the refresh loop running\n                console.warn(\"Unexpected error in cache refresh loop:\", e);\n            });\n        }, this.refreshIntervalSeconds * 1000);\n        // Don't block Node.js from exiting\n        if (this.refreshTimer.unref) {\n            this.refreshTimer.unref();\n        }\n    }\n    /**\n     * Get list of stale cache keys.\n     */\n    getStaleKeys() {\n        const staleKeys = [];\n        for (const [key, entry] of this.cache.entries()) {\n            if (isStale(entry, this.ttlSeconds)) {\n                staleKeys.push(key);\n            }\n        }\n        return staleKeys;\n    }\n    /**\n     * Check for stale entries and refresh them.\n     */\n    async refreshStaleEntries() {\n        if (!this.fetchFunc) {\n            return;\n        }\n        const staleKeys = this.getStaleKeys();\n        if (staleKeys.length === 0) {\n            return;\n        }\n        for (const key of staleKeys) {\n            try {\n                const newValue = await this.fetchFunc(key);\n                this.set(key, newValue);\n                this._metrics.refreshes += 1;\n            }\n            catch (e) {\n                // Keep stale data on refresh failure\n                this._metrics.refreshErrors += 1;\n                console.warn(`Failed to refresh cache entry ${key}:`, e);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzX2NhY2hlLmpzPzVjNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9tcHQgY2FjaGluZyBtb2R1bGUgZm9yIExhbmdTbWl0aCBTREsuXG4gKlxuICogUHJvdmlkZXMgYW4gTFJVIGNhY2hlIHdpdGggYmFja2dyb3VuZCByZWZyZXNoIGZvciBwcm9tcHQgY2FjaGluZy5cbiAqIFVzZXMgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZSBwYXR0ZXJuIGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLlxuICpcbiAqIFdvcmtzIGluIGFsbCBlbnZpcm9ubWVudHMuIEZpbGUgb3BlcmF0aW9ucyAoZHVtcC9sb2FkKSB1c2UgaGVscGVyc1xuICogdGhhdCBhcmUgc3dhcHBlZCBmb3IgYnJvd3NlciBidWlsZHMgdmlhIHBhY2thZ2UuanNvbiBicm93c2VyIGZpZWxkLlxuICovXG5pbXBvcnQgeyBkdW1wQ2FjaGUsIGxvYWRDYWNoZSB9IGZyb20gXCIuL3Byb21wdHNfY2FjaGVfZnMuanNcIjtcbi8qKlxuICogQ2hlY2sgaWYgYSBjYWNoZSBlbnRyeSBpcyBzdGFsZSBiYXNlZCBvbiBUVEwuXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbGUoZW50cnksIHR0bFNlY29uZHMpIHtcbiAgICBpZiAodHRsU2Vjb25kcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEluZmluaXRlIFRUTCwgbmV2ZXIgc3RhbGVcbiAgICB9XG4gICAgY29uc3QgYWdlTXMgPSBEYXRlLm5vdygpIC0gZW50cnkuY3JlYXRlZEF0O1xuICAgIHJldHVybiBhZ2VNcyA+IHR0bFNlY29uZHMgKiAxMDAwO1xufVxuLyoqXG4gKiBMUlUgY2FjaGUgd2l0aCBiYWNrZ3JvdW5kIHJlZnJlc2ggZm9yIHByb21wdHMuXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEluLW1lbW9yeSBMUlUgY2FjaGUgd2l0aCBjb25maWd1cmFibGUgbWF4IHNpemVcbiAqIC0gQmFja2dyb3VuZCByZWZyZXNoIHVzaW5nIHNldEludGVydmFsXG4gKiAtIFN0YWxlLXdoaWxlLXJldmFsaWRhdGU6IHJldHVybnMgc3RhbGUgZGF0YSB3aGlsZSByZWZyZXNoIGhhcHBlbnNcbiAqIC0gSlNPTiBkdW1wL2xvYWQgZm9yIG9mZmxpbmUgdXNlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKHtcbiAqICAgbWF4U2l6ZTogMTAwLFxuICogICB0dGxTZWNvbmRzOiAzNjAwLFxuICogICBmZXRjaEZ1bmM6IGFzeW5jIChrZXkpID0+IGNsaWVudC5wdWxsUHJvbXB0Q29tbWl0KGtleSksXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2UgdGhlIGNhY2hlXG4gKiBjYWNoZS5zZXQoXCJteS1wcm9tcHQ6bGF0ZXN0XCIsIHByb21wdENvbW1pdCk7XG4gKiBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoXCJteS1wcm9tcHQ6bGF0ZXN0XCIpO1xuICpcbiAqIC8vIENsZWFudXBcbiAqIGNhY2hlLnN0b3AoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHRsU2Vjb25kc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZyZXNoSW50ZXJ2YWxTZWNvbmRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoRnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZyZXNoVGltZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21ldHJpY3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICAgICAgICByZWZyZXNoZXM6IDAsXG4gICAgICAgICAgICAgICAgcmVmcmVzaEVycm9yczogMCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IGNvbmZpZy5tYXhTaXplID8/IDEwMDtcbiAgICAgICAgdGhpcy50dGxTZWNvbmRzID0gY29uZmlnLnR0bFNlY29uZHMgPz8gMzYwMDtcbiAgICAgICAgdGhpcy5yZWZyZXNoSW50ZXJ2YWxTZWNvbmRzID0gY29uZmlnLnJlZnJlc2hJbnRlcnZhbFNlY29uZHMgPz8gNjA7XG4gICAgICAgIHRoaXMuZmV0Y2hGdW5jID0gY29uZmlnLmZldGNoRnVuYztcbiAgICAgICAgLy8gU3RhcnQgYmFja2dyb3VuZCByZWZyZXNoIGlmIGZldGNoIGZ1bmN0aW9uIHByb3ZpZGVkIGFuZCBUVEwgaXMgc2V0XG4gICAgICAgIGlmICh0aGlzLmZldGNoRnVuYyAmJiB0aGlzLnR0bFNlY29uZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZWZyZXNoTG9vcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBwZXJmb3JtYW5jZSBtZXRyaWNzLlxuICAgICAqL1xuICAgIGdldCBtZXRyaWNzKCkge1xuICAgICAgICByZXR1cm4geyAuLi50aGlzLl9tZXRyaWNzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0b3RhbCBjYWNoZSByZXF1ZXN0cyAoaGl0cyArIG1pc3NlcykuXG4gICAgICovXG4gICAgZ2V0IHRvdGFsUmVxdWVzdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRyaWNzLmhpdHMgKyB0aGlzLl9tZXRyaWNzLm1pc3NlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGhpdCByYXRlICgwLjAgdG8gMS4wKS5cbiAgICAgKi9cbiAgICBnZXQgaGl0UmF0ZSgpIHtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0aGlzLnRvdGFsUmVxdWVzdHM7XG4gICAgICAgIHJldHVybiB0b3RhbCA+IDAgPyB0aGlzLl9tZXRyaWNzLmhpdHMgLyB0b3RhbCA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IGFsbCBtZXRyaWNzIHRvIHplcm8uXG4gICAgICovXG4gICAgcmVzZXRNZXRyaWNzKCkge1xuICAgICAgICB0aGlzLl9tZXRyaWNzID0ge1xuICAgICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICAgIHJlZnJlc2hlczogMCxcbiAgICAgICAgICAgIHJlZnJlc2hFcnJvcnM6IDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gY2FjaGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBTdGFsZSBlbnRyaWVzIGFyZSBzdGlsbCByZXR1cm5lZCAoYmFja2dyb3VuZCByZWZyZXNoIGhhbmRsZXMgdXBkYXRlcykuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldHJpY3MubWlzc2VzICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgdG8gZW5kIGZvciBMUlUgKGRlbGV0ZSBhbmQgcmUtYWRkKVxuICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgdGhpcy5fbWV0cmljcy5oaXRzICs9IDE7XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgdmFsdWUgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gZXZpY3QgKGFuZCBrZXkgaXMgbmV3KVxuICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkgJiYgdGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgLy8gRXZpY3Qgb2xkZXN0IChmaXJzdCBpdGVtIGluIE1hcClcbiAgICAgICAgICAgIGNvbnN0IG9sZGVzdEtleSA9IHRoaXMuY2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChvbGRlc3RLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKG9sZGVzdEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGVsZXRlIGZpcnN0IHRvIGVuc3VyZSBpdCdzIGF0IHRoZSBlbmRcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNwZWNpZmljIGVudHJ5IGZyb20gY2FjaGUuXG4gICAgICovXG4gICAgaW52YWxpZGF0ZShrZXkpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGNhY2hlIGVudHJpZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgYmFja2dyb3VuZCByZWZyZXNoLlxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY2xpZW50IGlzIGJlaW5nIGNsZWFuZWQgdXAuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVmcmVzaFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1bXAgY2FjaGUgY29udGVudHMgdG8gYSBKU09OIGZpbGUgZm9yIG9mZmxpbmUgdXNlLlxuICAgICAqL1xuICAgIGR1bXAoZmlsZVBhdGgpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLmNhY2hlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgZW50cmllc1trZXldID0gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZHVtcENhY2hlKGZpbGVQYXRoLCBlbnRyaWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBjYWNoZSBjb250ZW50cyBmcm9tIGEgSlNPTiBmaWxlLlxuICAgICAqXG4gICAgICogTG9hZGVkIGVudHJpZXMgZ2V0IGEgZnJlc2ggVFRMIHN0YXJ0aW5nIGZyb20gbG9hZCB0aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGVudHJpZXMgbG9hZGVkLlxuICAgICAqL1xuICAgIGxvYWQoZmlsZVBhdGgpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGxvYWRDYWNoZShmaWxlUGF0aCk7XG4gICAgICAgIGlmICghZW50cmllcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvYWRlZCA9IDA7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGVudHJpZXMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LCAvLyBGcmVzaCBUVEwgZnJvbSBsb2FkIHRpbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgICAgIGxvYWRlZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBiYWNrZ3JvdW5kIHJlZnJlc2ggbG9vcC5cbiAgICAgKi9cbiAgICBzdGFydFJlZnJlc2hMb29wKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFN0YWxlRW50cmllcygpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTG9nIGJ1dCBkb24ndCBkaWUgLSBrZWVwIHRoZSByZWZyZXNoIGxvb3AgcnVubmluZ1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgZXJyb3IgaW4gY2FjaGUgcmVmcmVzaCBsb29wOlwiLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLnJlZnJlc2hJbnRlcnZhbFNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgLy8gRG9uJ3QgYmxvY2sgTm9kZS5qcyBmcm9tIGV4aXRpbmdcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWVyLnVucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lci51bnJlZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsaXN0IG9mIHN0YWxlIGNhY2hlIGtleXMuXG4gICAgICovXG4gICAgZ2V0U3RhbGVLZXlzKCkge1xuICAgICAgICBjb25zdCBzdGFsZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5jYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpc1N0YWxlKGVudHJ5LCB0aGlzLnR0bFNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgc3RhbGVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhbGVLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3Igc3RhbGUgZW50cmllcyBhbmQgcmVmcmVzaCB0aGVtLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hTdGFsZUVudHJpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5mZXRjaEZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFsZUtleXMgPSB0aGlzLmdldFN0YWxlS2V5cygpO1xuICAgICAgICBpZiAoc3RhbGVLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHN0YWxlS2V5cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGF3YWl0IHRoaXMuZmV0Y2hGdW5jKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0cmljcy5yZWZyZXNoZXMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBzdGFsZSBkYXRhIG9uIHJlZnJlc2ggZmFpbHVyZVxuICAgICAgICAgICAgICAgIHRoaXMuX21ldHJpY3MucmVmcmVzaEVycm9ycyArPSAxO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlZnJlc2ggY2FjaGUgZW50cnkgJHtrZXl9OmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache_fs.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache_fs.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dumpCache: () => (/* binding */ dumpCache),\n/* harmony export */   loadCache: () => (/* binding */ loadCache)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/**\n * File system operations for prompt cache (Node.js version).\n *\n * This file is swapped with prompts_cache_fs.browser.ts for browser builds\n * via the package.json browser field.\n */\n\n\n/**\n * Dump cache entries to a JSON file.\n */\nfunction dumpCache(filePath, entries) {\n    const dir = node_path__WEBPACK_IMPORTED_MODULE_1__.dirname(filePath);\n    if (!node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(dir)) {\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync(dir, { recursive: true });\n    }\n    const data = { entries };\n    // Atomic write: write to temp file then rename\n    const tempPath = `${filePath}.tmp`;\n    try {\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync(tempPath, JSON.stringify(data, null, 2));\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.renameSync(tempPath, filePath);\n    }\n    catch (e) {\n        // Clean up temp file on failure\n        if (node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(tempPath)) {\n            node_fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync(tempPath);\n        }\n        throw e;\n    }\n}\n/**\n * Load cache entries from a JSON file.\n *\n * @returns The entries object, or null if file doesn't exist or is invalid.\n */\nfunction loadCache(filePath) {\n    if (!node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath)) {\n        return null;\n    }\n    try {\n        const content = node_fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(filePath, \"utf-8\");\n        const data = JSON.parse(content);\n        return data.entries ?? null;\n    }\n    catch {\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZV9mcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhCO0FBQ0k7QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsOENBQVk7QUFDNUIsU0FBUywrQ0FBYTtBQUN0QixRQUFRLDhDQUFZLFFBQVEsaUJBQWlCO0FBQzdDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQSxRQUFRLGtEQUFnQjtBQUN4QixRQUFRLCtDQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQWE7QUFDekIsWUFBWSwrQ0FBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsK0NBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZV9mcy5qcz9iNGYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlsZSBzeXN0ZW0gb3BlcmF0aW9ucyBmb3IgcHJvbXB0IGNhY2hlIChOb2RlLmpzIHZlcnNpb24pLlxuICpcbiAqIFRoaXMgZmlsZSBpcyBzd2FwcGVkIHdpdGggcHJvbXB0c19jYWNoZV9mcy5icm93c2VyLnRzIGZvciBicm93c2VyIGJ1aWxkc1xuICogdmlhIHRoZSBwYWNrYWdlLmpzb24gYnJvd3NlciBmaWVsZC5cbiAqL1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcIm5vZGU6cGF0aFwiO1xuLyoqXG4gKiBEdW1wIGNhY2hlIGVudHJpZXMgdG8gYSBKU09OIGZpbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkdW1wQ2FjaGUoZmlsZVBhdGgsIGVudHJpZXMpIHtcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0geyBlbnRyaWVzIH07XG4gICAgLy8gQXRvbWljIHdyaXRlOiB3cml0ZSB0byB0ZW1wIGZpbGUgdGhlbiByZW5hbWVcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGAke2ZpbGVQYXRofS50bXBgO1xuICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmModGVtcFBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICAgICAgZnMucmVuYW1lU3luYyh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDbGVhbiB1cCB0ZW1wIGZpbGUgb24gZmFpbHVyZVxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyh0ZW1wUGF0aCkpIHtcbiAgICAgICAgICAgIGZzLnVubGlua1N5bmModGVtcFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuLyoqXG4gKiBMb2FkIGNhY2hlIGVudHJpZXMgZnJvbSBhIEpTT04gZmlsZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW50cmllcyBvYmplY3QsIG9yIG51bGwgaWYgZmlsZSBkb2Vzbid0IGV4aXN0IG9yIGlzIGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ2FjaGUoZmlsZVBhdGgpIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIGRhdGEuZW50cmllcyA/PyBudWxsO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/prompts_cache_fs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2xhbmdzbWl0aEAwLjQuOV9vcGVuYWlANi4xNi4wL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy93YXJuLmpzPzU5M2MiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgd2FybmVkTWVzc2FnZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gICAgaWYgKCF3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/uuid.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/uuid.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid7: () => (/* binding */ uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/utils/_uuid.js\");\n\n\n/**\n * Generate a random UUID v7 string.\n */\nfunction uuid7() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXVpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9DO0FBQ2E7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGdEQUFNO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdG9vbHMvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStsYW5nc21pdGhAMC40Ljlfb3BlbmFpQDYuMTYuMC9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXVpZC5qcz8xMDBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY3IGFzIHV1aWR2NyB9IGZyb20gXCJ1dWlkXCI7XG5leHBvcnQgeyB1dWlkN0Zyb21UaW1lIH0gZnJvbSBcIi4vdXRpbHMvX3V1aWQuanNcIjtcbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gVVVJRCB2NyBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkNygpIHtcbiAgICByZXR1cm4gdXVpZHY3KCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Cache),
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),
/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultProjectName),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation),
/* harmony export */   uuid7: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7),
/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/index.js");


/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/run_trees.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/run_trees.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),
/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),
/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)
/* harmony export */ });
/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/run_trees.js");


/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/singletons/traceable.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),
/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),
/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),
/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)
/* harmony export */ });
/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ "(ssr)/./node_modules/.pnpm/registry.npmmirror.com+langsmith@0.4.9_openai@6.16.0/node_modules/langsmith/dist/singletons/traceable.js");


/***/ })

};
;